â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./blockchain/scripts/compile.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// scripts/compile.ts
import * as solc from 'solc';
import * as fs from 'fs';
import * as path from 'path';

function findImports(importPath: string) {
	try {
		const contractsDir = path.join(__dirname, '../contract');
		const filePath = path.join(contractsDir, importPath);
		return {
			contents: fs.readFileSync(filePath, 'utf8')
		};
	} catch (error) {
		return { error: 'File not found' };
	}
}

function compileContract() {
	console.log('Compiling TournamentRegistry.sol...\n');
	const contractPath = path.join(__dirname, '../contract/TournamentRegistry.sol');
	const sourceCode = fs.readFileSync(contractPath, 'utf8');
	
	const input = {
		language: 'Solidity',
		sources: {
			'TournamentRegistry.sol': {
				content: sourceCode
			}
		},
		settings: {
			outputSelection: {
				'*': {
					'*': ['abi', 'evm.bytecode.object', 'evm.deployedBytecode']
				}
			},
			optimizer: {
				enabled: true,
				runs: 200
			}
		}
	};
	
	const output = JSON.parse(
		solc.compile(JSON.stringify(input), { import: findImports })
	);

	if (output.errors) {
		let hasError = false;
		output.errors.forEach((error: any) => {
			if (error.severity === 'error') {
				console.error('Error:', error.formattedMessage);
				hasError = true;
			} else {
				console.warn('Warning:', error.formattedMessage);
			}
		});
		
		if (hasError) {
			throw new Error('Compilation failed');
		}
	}
	
	const contract = output.contracts['TournamentRegistry.sol']['TournamentRegistry'];
	
	if (!contract) {
		throw new Error('Contract not found in compilation output');
	}
	
	const compiledContract = {
		abi: contract.abi,
		bytecode: '0x' + contract.evm.bytecode.object
	};
	
	const buildDir = path.join(__dirname, '../build');
	if (!fs.existsSync(buildDir)) {
		fs.mkdirSync(buildDir, { recursive: true });
	}

	const outputPath = path.join(buildDir, 'TournamentRegistry.json');
	fs.writeFileSync(
		outputPath,
		JSON.stringify(compiledContract, null, 2)
	);
	
	console.log('âœ… Compilation successful!');
	console.log(`Output: ${outputPath}`);
	console.log(`ABI entries: ${compiledContract.abi.length}`);
	console.log(`Bytecode length: ${compiledContract.bytecode.length} characters\n`);
	
	return compiledContract;
}

try {
	compileContract();
} catch (error) {
	console.error('Compilation failed:', error);
	process.exit(1);
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./blockchain/scripts/deploy.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// scripts/deploy-contract.ts
import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';
import * as compiledContract from '../build/TournamentRegistry.json';

const NETWORKS = {
	fuji: {
		name: 'Avalanche Fuji Testnet',
		rpcUrl: 'https://api.avax-test.network/ext/bc/C/rpc',
		chainId: 43113,
		explorer: 'https://testnet.snowtrace.io'
	},
	mainnet: {
		name: 'Avalanche C-Chain',
		rpcUrl: 'https://api.avax.network/ext/bc/C/rpc',
		chainId: 43114,
		explorer: 'https://snowtrace.io'
	}
};

// Contract Bytecode
const CONTRACT_BYTECODE = compiledContract.bytecode
const CONTRACT_ABI = compiledContract.abi

/**
 * Fonction principale de dÃ©ploiement
 */
async function deployContract(networkName: 'fuji' | 'mainnet') {
	console.log('\nStarting contract deployment...\n');
	
	// 1. Charger la configuration du rÃ©seau
	const network = NETWORKS[networkName];
	console.log(`Network: ${network.name}`);
	console.log(`RPC URL: ${network.rpcUrl}`);
	console.log(`Chain ID: ${network.chainId}\n`);
	
	// 2. VÃ©rifier la clÃ© privÃ©e
	const privateKey = process.env.BLOCKCHAIN_PRIVATE_KEY;
	if (!privateKey) {
		throw new Error('BLOCKCHAIN_PRIVATE_KEY not found in environment variables');
	}
	console.log(privateKey)
	
	// 3. Connexion au rÃ©seau
	console.log('Connecting to network...');
	const provider = new ethers.JsonRpcProvider(network.rpcUrl);
	const wallet = new ethers.Wallet(privateKey, provider);
	
	// 4. VÃ©rifier le solde
	const balance = await provider.getBalance(wallet.address);
	console.log(`Wallet address: ${wallet.address}`);
	console.log(`ğŸ’µ Balance: ${ethers.formatEther(balance)} AVAX\n`);
	
	if (balance === 0n) {
		console.log('WARNING: Wallet has zero balance!');
		if (networkName === 'fuji') {
			console.log('Get testnet AVAX from: https://faucet.avax.network/');
		}
		throw new Error('Insufficient balance');
	}
	
	// 5. CrÃ©er la factory du contrat
	console.log('Preparing contract deployment...');
	const factory = new ethers.ContractFactory(
		CONTRACT_ABI,
		CONTRACT_BYTECODE,
		wallet
	);
	
	// 6. Estimer le gas
	console.log('Estimating gas...');
	const deployTransaction = await factory.getDeployTransaction();
	const estimatedGas = await provider.estimateGas({
		...deployTransaction,
		from: wallet.address
	});
	
	const feeData = await provider.getFeeData();
	const estimatedCost = estimatedGas * (feeData.gasPrice || 0n);
	
	console.log(`Estimated gas: ${estimatedGas.toString()}`);
	console.log(`Estimated cost: ${ethers.formatEther(estimatedCost)} AVAX\n`);
	
	// 7. DÃ©ployer le contrat
	console.log('Deploying contract...');
	const contract = await factory.deploy();
	
	console.log(`Transaction sent: ${contract.deploymentTransaction()?.hash}`);
	console.log('Waiting for confirmation...\n');
	
	// 8. Attendre la confirmation
	await contract.waitForDeployment();
	const contractAddress = await contract.getAddress();
	
	// 9. Afficher les rÃ©sultats
	console.log('Contract deployed successfully!\n');
	console.log('â•'.repeat(60));
	console.log(`Contract Address: ${contractAddress}`);
	console.log(`Explorer: ${network.explorer}/address/${contractAddress}`);
	console.log(`Network: ${network.name}`);
	console.log('â•'.repeat(60));
	
	// 10. Sauvegarder les informations
	const deploymentInfo = {
		network: networkName,
		contractAddress,
		deployedAt: new Date().toISOString(),
		deployer: wallet.address,
		transactionHash: contract.deploymentTransaction()?.hash,
		explorerUrl: `${network.explorer}/address/${contractAddress}`
	};
	
	const outputPath = path.join(__dirname, `deployment-${networkName}.json`);
	fs.writeFileSync(
		outputPath,
		JSON.stringify(deploymentInfo, null, 2)
	);
	
	console.log(`\nDeployment info saved to: ${outputPath}\n`);
	
	// 11. Instructions suivantes
	console.log('Next steps:');
	console.log('1. Add this to your .env file:');
	console.log(`   BLOCKCHAIN_CONTRACT_ADDRESS=${contractAddress}`);
	console.log(`   AVALANCHE_RPC_URL=${network.rpcUrl}`);
	console.log('2. Verify your contract on the explorer (optional)');
	console.log('3. Start using the contract in your application\n');
	
	return contractAddress;
}

/**
 * CLI Interface
 */
async function main() {
	const args = process.argv.slice(2);
	const networkArg = args[0];
	
	if (!networkArg || !['fuji', 'mainnet'].includes(networkArg)) {
		console.log('Usage: ts-node deploy-contract.ts <network>');
		console.log('Networks: fuji | mainnet');
		console.log('\nExample: ts-node deploy-contract.ts fuji');
		process.exit(1);
	}
	
	try {
		await deployContract(networkArg as 'fuji' | 'mainnet');
	} catch (error) {
		console.error('\nâŒ Deployment failed:');
		console.error(error);
		process.exit(1);
	}
}

main();



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./blockchain/scripts/test.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { ethers } from 'ethers';
import * as compiledContract from '../build/TournamentRegistry.json';
import * as deploymentInfo from './deployment-fuji.json';

async function testContract() {
	console.log('Testing deployed contract...\n');
	
	const provider = new ethers.JsonRpcProvider(
		'https://api.avax-test.network/ext/bc/C/rpc'
	);
	
	const wallet = new ethers.Wallet(
		process.env.BLOCKCHAIN_PRIVATE_KEY!,
		provider
	);
	
	const contract = new ethers.Contract(
		deploymentInfo.contractAddress,
		compiledContract.abi,
		wallet
	);
	
	// Enregistrer un tournoi
	console.log('Registering test tournament...');
	const tx = await contract.registerTournament(
		'test-tournament-1',
		'Test Tournament',
		8,
		'player-123',
		'TestWinner'
	);
	
	console.log(`Transaction: ${tx.hash}`);
	await tx.wait();
	console.log('âœ… Tournament registered!\n');
	
	// RÃ©cupÃ©rer le tournoi
	console.log('Reading tournament data...');
	const tournament = await contract.getTournament('test-tournament-1');
	
	console.log('Tournament details:');
	console.log(`  Name: ${tournament[0]}`);
	console.log(`  Max Players: ${tournament[1]}`);
	console.log(`  Winner ID: ${tournament[2]}`);
	console.log(`  Winner Name: ${tournament[3]}`);
	console.log(`  Timestamp: ${new Date(Number(tournament[4]) * 1000).toISOString()}\n`);
	
	// Test 3: Compter les tournois
	const count = await contract.getTournamentCount();
	console.log(`Total tournaments: ${count}\n`);
	
	console.log('âœ… All tests passed!');
}

testContract().catch(console.error);



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/server.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify from 'fastify'
import websocket from '@fastify/websocket'
import { handleGame } from './game/game'
import { setMatchForRoom } from './game/session/session'
import { cleanupSession } from './game/session/session'

const fastify = Fastify({
	logger: true
})

await fastify.register(websocket)

fastify.get('/game/:roomId', { websocket: true }, function gameHandler (connection, _req)
	{
		handleGame(connection, _req, fastify)
	}
)

fastify.delete('/game/:roomId', async (request, reply) => {
    const { roomId } = request.params as { roomId: string };
    const deleted = cleanupSession(roomId);
    return reply.send({ success: deleted });
});

type CreateBody = {
    roomId: string;
    player1: {id: string; username: string; selectedSkill?: 'smash' | 'dash'};
    player2: {id: string; username: string; selectedSkill?: 'smash' | 'dash'};
	isTournament?: boolean;
    tournamentId?: string;
    matchId?: string;
}

fastify.post('/create', async (request, reply) => {

    console.log('Body:', JSON.stringify(request.body, null, 2));
	const body = request.body as Partial<CreateBody>;
    if (!body?.roomId || !body?.player1?.id || !body?.player2?.id)
    {
        reply.code(400).send({success: false, error: 'Invalid payload'});
        return;
    }
    setMatchForRoom(
		body.roomId,
		{
			left: {
				id: body.player1.id, 
				username: body.player1.username || 'p1',
				selectedSkill: body.player1.selectedSkill || 'smash'
			},
			right: {
				id: body.player2.id, 
				username: body.player2.username || 'p2',
				selectedSkill: body.player2.selectedSkill || 'smash'
			}
		},
		{
			isTournament: body.isTournament,
			tournamentId: body.tournamentId,
			matchId: body.matchId
		},
		fastify.log
	);

    reply.send({success: true});
})

fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

fastify.get('/health', async (request, reply) => {
    return { status: 'ok', service: 'game-backend' };
});

fastify.listen({ port: 3010, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/session/session.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { WebSocket, WebsocketHandler } from "@fastify/websocket";
import type { FastifyBaseLogger } from "fastify";
import { GameWorld } from "../engine/world";
import { SERVER_DT, SERVER_TICK_HZ, BROADCAST_HZ, TIMEOUT_MS } from "../engine/constants";
import type { ClientMessage, ServerMessage } from "../ws/messageTypes";
import { safeParse } from "../ws/messageTypes";
import type { SkillType } from "../engine/types";

type Role = 'left' | 'right' | 'spectator';
type Player = {id: string; username: string; selectedSkill?: SkillType};

interface GameStats {
	paddle_hits: number;
	max_ball_speed: number;
	power_ups_collected: number;
	skills_used: number;
	smashes: Array<{time: number; successful: boolean; id?: number}>;
	dashes: Array<{time: number; successful: boolean; id?: number}>;
}

const rooms = new Map<string, GameSession>();

class GameSession {
	private log?: FastifyBaseLogger;
	private world = new GameWorld();

	private clients = new Set<WebSocket>();
	private roles = new Map<WebSocket, Role>();
	private leftCtrl?: WebSocket;
	private rightCtrl?: WebSocket;
    
    private expected: {left?: Player; right?: Player} = {};

	private leftStats: GameStats = {
		paddle_hits: 0,
		max_ball_speed: 0,
		power_ups_collected: 0,
		skills_used: 0,
		smashes: [],
		dashes: []
	};
	private rightStats: GameStats = {
		paddle_hits: 0,
		max_ball_speed: 0,
		power_ups_collected: 0,
		skills_used: 0,
		smashes: [],
		dashes: []
	};

	private tickTimer?: NodeJS.Timeout;
	private broadcastTimer?: NodeJS.Timeout;

	private leftCtrlDisconnectedAt: number | null = null;
	private rightCtrlDisconnectedAt: number | null = null;
	private hadBothCtrl = false;

	private reportedGameOver = false;

	private lastPaused = false;
	private lastGameOver = false;

    private timeScale = 1;

	private emptySince: number | null = null;

	private isTournament: boolean = false;
	private tournamentId?: string;
	private matchId?: string;

	constructor(private readonly roomId?: string, log?: FastifyBaseLogger) {
		this.startLoops();
		this.log = log;
		
		this.world.setCallbacks({
			onPaddleHit: (side) => {
				const stats = side === 'left' ? this.leftStats : this.rightStats;
				stats.paddle_hits++;
			},
			onPowerUpCollected: (side, type, gameTime) => {
				const stats = side === 'left' ? this.leftStats : this.rightStats;
				stats.power_ups_collected++;
				
				if (this.roomId && this.expected[side]) {
					this.savePowerUpUsed(side, type, gameTime).catch(err => {
						this.log?.error({ error: err }, 'Failed to save power-up usage');
					});
				}
			},
			onBallSpeedUpdate: (speed) => {
				this.leftStats.max_ball_speed = Math.max(this.leftStats.max_ball_speed, speed);
				this.rightStats.max_ball_speed = Math.max(this.rightStats.max_ball_speed, speed);
			},
			onSkillSuccess: (side, skillType, gameTime) => {
				const stats = side === 'left' ? this.leftStats : this.rightStats;
				const skillArray = skillType === 'smash' ? stats.smashes : stats.dashes;
				for (let i = skillArray.length - 1; i >= 0; i--) {
					if (!skillArray[i].successful && Math.abs(skillArray[i].time - gameTime) < 1) {
						skillArray[i].successful = true;
						break;
					}
				}
			},
			onGoalScored: (scorerSide, ballYPosition, gameTime) => {
				if (this.roomId) {
					this.saveGoalScored(scorerSide, ballYPosition, gameTime).catch(err => {
						this.log?.error({ error: err }, 'Failed to save goal');
					});
				}
			}
		});
	}

	private destroy() {
		if (this.tickTimer)
		{
			clearInterval(this.tickTimer);
		}
		if (this.broadcastTimer)
		{
			clearInterval(this.broadcastTimer);
		}
		this.clients.clear();
		this.roles.clear();
		this.leftCtrl = undefined;
		this.rightCtrl = undefined;
	}

    setPlayers(players: {left: Player; right: Player}, metadata?: {
		isTournament?: boolean;
		tournamentId?: string;
		matchId?: string;
	}) {
        this.expected.left = players.left;
        this.expected.right = players.right;

		if (players.left.selectedSkill) {
			this.world.setSkill('left', players.left.selectedSkill);
		}
		if (players.right.selectedSkill) {
			this.world.setSkill('right', players.right.selectedSkill);
		}

		if (metadata) {
            this.isTournament = metadata.isTournament || false;
            this.tournamentId = metadata.tournamentId;
            this.matchId = metadata.matchId;
        }

        this.log?.info({roomId: this.roomId, players: this.expected}, 'match set');
    }

	addClient(ws: WebSocket) {
		ws.on('message', (raw: Buffer) => this.onMessage(ws, raw));
		ws.on('close', () => this.onClose(ws));
		ws.on('error', () => this.onClose(ws));
	}

	private assignRole(ws: WebSocket, playerId?: string): Role {
		if (!this.expected.left?.id && !this.expected.right?.id)
		{
			throw new Error("Invalid room: no players expected")
		}
		if (this.expected.left?.id || this.expected.right?.id) 
        {
            if (playerId && this.expected.left?.id === playerId && !this.leftCtrl)
            {
                this.leftCtrl = ws;
                this.leftCtrlDisconnectedAt = null;
                return ('left');
            }
            if (playerId && this.expected.right?.id === playerId && !this.rightCtrl)
            {
                this.rightCtrl = ws;
                this.rightCtrlDisconnectedAt = null;
                return ('right');
            }
            return ('spectator');
        }
        return ('spectator');
	}

    private onMessage(ws: WebSocket, raw: Buffer) {
        const msg = safeParse<ClientMessage>(raw.toString());
        if (!msg) {
            return;
        }
        const role = this.roles.get(ws);
        const canCtrl = (role === 'left' && ws === this.leftCtrl) ||
            (role === 'right' && ws === this.rightCtrl);
        switch (msg.type) {
            case 'input': {
                if (role === 'left' && ws === this.leftCtrl) {
                    const intention = msg.up && !msg.down ? -1 : msg.down && !msg.up ? 1 : 0;
                    this.world.applyInput('left', intention);
                }
                else if (role === 'right' && ws === this.rightCtrl) {
                    const intention = msg.up && !msg.down ? -1 : msg.down && !msg.up ? 1 : 0;
                    this.world.applyInput('right', intention)
                }
                break;
            }
            case 'skill': {
                if (role === 'left' || role === 'right') {
					const skillType = this.world.state.selectedSkills[role];
                    this.world.useSkill(role);
					const stats = role === 'left' ? this.leftStats : this.rightStats;
					stats.skills_used++;
					
					if (skillType === 'smash') {
						stats.smashes.push({
							time: this.world.state.clock,
							successful: false
						});
					} else if (skillType === 'dash') {
						stats.dashes.push({
							time: this.world.state.clock,
							successful: false
						});
					}

                    const smashActivated = this.world.pressSmash(role);
					if (smashActivated) {
						const legacyStats = role === 'left' ? this.leftStats : this.rightStats;
						legacyStats.skills_used++;
						legacyStats.smashes.push({
							time: this.world.state.clock,
							successful: false
						});
					}
                }
                break;
            }
            case 'pause':
                if (!canCtrl) {
                    this.send(ws, { type: 'error', message: 'Spectators can\'t pause the game' });
                    break;
                }
                this.world.pause();
                break;
            case 'resume': {
                if (!canCtrl) {
                    this.send(ws, { type: 'error', message: 'Spectators can\'t resume the game' });
                    break;
                }
                this.world.resume();
                break;
            }
            case 'forfeit': {
                if (!canCtrl) {
                    this.send(ws, { type: 'error', message: 'Spectators can\'t forfeit' });
                    break;
                }
                // Determine who forfeited and who wins
                const forfeitingSide = role as 'left' | 'right';
                const winningSide = forfeitingSide === 'left' ? 'right' : 'left';
                
                // End the game immediately
                this.world.state.isGameOver = true;
                this.world.state.winner = winningSide;
                
                // Broadcast game over
                this.broadcast({
                    type: 'gameover',
                    winner: winningSide,
                    isTournament: this.isTournament,
                    tournamentId: this.tournamentId
                });
                
                // Save game end with forfeit reason
                this.notifyGameEnd('forfeit', winningSide);
                
                this.log?.info({ roomId: this.roomId, forfeitingSide, winningSide }, 'Player forfeited');
                break;
            }
            case 'logIn':
                try {
                    const assRole = this.assignRole(ws, msg.id);
                    this.clients.add(ws);
                    this.roles.set(ws, assRole);

                    this.send(ws, {
                        type: 'welcome',
                        side: assRole,
                        isTournament: this.isTournament,
                        tournamentId: this.tournamentId,
                        players: {
                            left: this.expected.left?.username,
                            right: this.expected.right?.username
                        }
                    });

                    this.log?.info({ roomId: this.roomId, assRole, clients: this.clients.size, playerId: msg.id }, 'client connected');

                    const haveBoth = !!this.leftCtrl && !!this.rightCtrl;
                    if (haveBoth && !this.hadBothCtrl) {
                        this.world.startCountdown();
                        this.notifyGameStarted();
                    }
                    this.hadBothCtrl = haveBoth;
                }
                catch (err) {
                    this.send(ws, { type: 'error', message: 'no player expected for this room.' })
                }
                break;
            case 'ping':
                this.send(ws, { type: 'pong', t: msg.t });
                break;
            case 'debug': {
                const allowDebug = (process.env.ALLOW_DEBUG === '1');
                if (!allowDebug) {
                    this.send(ws, { type: 'error', message: 'Debug disabled on server' });
                    break;
                }

                try {
                    switch (msg.action) {
                        case 'activate_powerup':
                            this.world.debugActivatePowerUp(msg.payload.kind);
                            break;
                        case 'clear_powerups':
                            this.world.debugClearPowerUps();
                            break;
                        case 'score_change':
                            this.world.debugChangeScore(msg.payload.side, msg.payload.amount);
                            break;
                        case 'reset_score':
                            this.world.debugResetScore();
                            break;
                        case 'set_score':
                            this.world.debugSetScore(msg.payload.left, msg.payload.right);
                            break;
                        case 'ball_control':
                            this.world.debugBallControl(msg.payload.mode);
                            break;
                        case 'ball_speed':
                            this.world.debugBallSpeed(msg.payload.mode);
                            break;
                        case 'time_scale':
                            this.timeScale = Math.max(0.1, Math.min(4, msg.payload.scale));
                            break;
                        case 'change_skill':
                            this.world.setSkill(msg.payload.side, msg.payload.skill);
                            break;
                    }
                } catch (e) {
                    this.send(ws, { type: 'error', message: 'Debug action failed' });
                }
                break;
            }
        }
    }

	private onClose(ws: WebSocket) {
		this.clients.delete(ws);
		const role = this.roles.get(ws);
		this.roles.delete(ws);
		if (this.leftCtrl === ws)
		{
			this.leftCtrl = undefined;
            this.leftCtrlDisconnectedAt = Date.now();
            this.log?.info({roomId: this.roomId, role}, 'client disconnected starting 30s timeout');
		}
		if (this.rightCtrl === ws)
		{
			this.rightCtrl = undefined;
            this.rightCtrlDisconnectedAt = Date.now();
            this.log?.info({roomId: this.roomId, role}, 'client disconnected starting 30s timeout');
		}
        if (!this.leftCtrl && !this.rightCtrl)
        {
            this.log?.info({roomId: this.roomId, role}, 'Both client disconnected');
        }
		this.log?.info({roomId: this.roomId, role}, 'client disconnected');
		if (this.clients.size === 0 && this.emptySince === null)
		{
			this.emptySince = Date.now();
		}
		this.hadBothCtrl = !!this.leftCtrl && !!this.rightCtrl;
	}

    private async notifyGameStarted(): Promise<void> {
        if (!this.roomId) return;
        
        try
        {
            const url = `http://database:3020/games/room/${this.roomId}/start`;
            
            await fetch(url, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
            });
            
            this.log?.info({ roomId: this.roomId }, 'Game start notified to database');
        }
        catch (err)
        {
            this.log?.error({ roomId: this.roomId, error: err }, 'Failed to notify game start');
        }
    }

	private async savePowerUpUsed(side: 'left' | 'right', type: 'split' | 'blackout' | 'blackhole', gameTime: number): Promise<void> {
		if (!this.roomId) return;

		const player = side === 'left' ? this.expected.left : this.expected.right;
		if (!player) return;

		try {
			const gameResponse = await fetch(`http://database:3020/games/room/${this.roomId}`);
			const gameData = await gameResponse.json();
			
			if (!gameData.success || !gameData.game?.id) {
				return;
			}

			await fetch(`http://database:3020/power-ups`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					game_id: gameData.game.id,
					player_id: player.id,
					power_up_type: type,
					collected_at_game_time: gameTime,
					activated_at_game_time: gameTime
				})
			});

			this.log?.info({ gameId: gameData.game.id, playerId: player.id, type, gameTime }, 'Power-up saved');
		} catch (err) {
			this.log?.error({ error: err }, 'Failed to save power-up');
		}
	}

	private async saveGoalScored(scorerSide: 'left' | 'right', ballYPosition: number, gameTime: number): Promise<void> {
		if (!this.roomId) return;

		try {
			const gameResponse = await fetch(`http://database:3020/games/room/${this.roomId}`);
			const gameData = await gameResponse.json();
			
			if (!gameData.success || !gameData.game?.id) {
				return;
			}

			const scoredAgainstSide = scorerSide === 'left' ? 'right' : 'left';

			await fetch(`http://database:3020/goals`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					game_id: gameData.game.id,
					scorer_side: scorerSide,
					scored_against_side: scoredAgainstSide,
					ball_y_position: ballYPosition,
					scored_at_game_time: gameTime
				})
			});

			this.log?.info({ gameId: gameData.game.id, scorerSide, ballYPosition, gameTime }, 'Goal saved');
		} catch (err) {
			this.log?.error({ error: err }, 'Failed to save goal');
		}
	}

	private async saveGameStats(gameId: string): Promise<void> {
		if (!this.expected.left || !this.expected.right || !this.roomId) {
			return;
		}

		const savePlayerStats = async (side: 'left' | 'right') => {
			const player = side === 'left' ? this.expected.left : this.expected.right;
			const stats = side === 'left' ? this.leftStats : this.rightStats;

			if (!player) return;

			try {
				await fetch(`http://database:3020/game-stats`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						game_id: gameId,
						player_id: player.id,
						side: side,
						paddle_hits: stats.paddle_hits,
						max_ball_speed: Math.round(stats.max_ball_speed),
						power_ups_collected: stats.power_ups_collected,
						skills_used: stats.skills_used
					})
				});

				for (const smash of stats.smashes) {
					await fetch(`http://database:3020/skills`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							game_id: gameId,
							player_id: player.id,
							skill_type: 'smash',
							activated_at_game_time: smash.time,
							was_successful: smash.successful
						})
					});
				}

				for (const dash of stats.dashes) {
					await fetch(`http://database:3020/skills`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							game_id: gameId,
							player_id: player.id,
							skill_type: 'dash',
							activated_at_game_time: dash.time,
							was_successful: dash.successful
						})
					});
				}

				this.log?.info({ gameId, playerId: player.id, side }, 'Game stats saved');
			} catch (err) {
				this.log?.error({ gameId, playerId: player.id, error: err }, 'Failed to save game stats');
			}
		};

		await Promise.all([
			savePlayerStats('left'),
			savePlayerStats('right')
		]);
	}

	private async notifyGameEnd(reason: 'score' | 'timeout', winner?: 'left' | 'right'): Promise<void> {
        if (this.reportedGameOver)
		{
            return;
        }
        this.reportedGameOver = true;

		const winnerId = winner === 'left' ? this.expected.left?.id : this.expected.right?.id;

		if (this.isTournament && this.matchId && winnerId)
		{
            await this.notifyTournamentMatchEnd(this.matchId, winnerId);
        }

        const url = `http://quickplayback:3030/room-finished`;

        try
		{
            const payload = {
                roomId: this.roomId,
                reason: reason,
                winner: winner ? {
                    id: winner === 'left' ? this.expected.left?.id : this.expected.right?.id,
                    username: winner === 'left' ? this.expected.left?.username : this.expected.right?.username
                } : null,
                score: this.world.state.score
            };

            await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            this.log?.info({ roomId: this.roomId, reason }, 'Game end notified to quickplay');

			if (this.roomId) {
				try {
					const gameResponse = await fetch(`http://database:3020/games/room/${this.roomId}`);
					const gameData = await gameResponse.json();
					if (gameData.success && gameData.game?.id) {
						await this.saveGameStats(gameData.game.id);
					}
				} catch (err) {
					this.log?.error({ error: err }, 'Failed to retrieve game ID for stats');
				}
			}
        }
		catch (err)
		{
            this.log?.error({ roomId: this.roomId, error: err }, 'Failed to notify game end');
        }
    }

	private async notifyTournamentMatchEnd(matchId: string, winnerId: string): Promise<void> {
        const url = `http://tournamentback:3040/match-finished`;

        try
		{
            await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    matchId,
                    winnerId
                })
            });

            this.log?.info({ 
                roomId: this.roomId, 
                matchId, 
                winnerId 
            }, 'Tournament match end notified');
        }
		catch (err)
		{
            this.log?.error({ 
                roomId: this.roomId, 
                error: err 
            }, 'Failed to notify tournament match end');
        }
    }

	private startLoops() {
		this.tickTimer = setInterval(() => {
			this.world.update(SERVER_DT * this.timeScale);
		}, Math.round(1000 / SERVER_TICK_HZ));

		this.broadcastTimer = setInterval(() => {
            const now = Date.now();
            const leftDisconnected = this.leftCtrlDisconnectedAt !== null && !this.leftCtrl;
            const rightDisconnected = this.rightCtrlDisconnectedAt !== null && !this.rightCtrl;
            const bothDisconnected = !this.leftCtrl && !this.rightCtrl;

            if ((leftDisconnected || rightDisconnected) && !this.world.state.isGameOver)
            {
                this.world.pause();
            }
            let leftRemaining = 0;
            let rightRemaining = 0;

            if (leftDisconnected && this.leftCtrlDisconnectedAt)
            {
                const elapsed = now - this.leftCtrlDisconnectedAt;
                leftRemaining = Math.max(0, TIMEOUT_MS - elapsed);
                if (leftRemaining === 0 && !this.world.state.isGameOver)
                {
                    this.world.state.isGameOver = true;
                    this.world.state.winner = 'right';
                    this.world.state.isTimeoutLeft = true;
					this.notifyGameEnd('timeout', 'right');
                }
            }

            if (rightDisconnected && this.rightCtrlDisconnectedAt)
            {
                const elapsed = now - this.rightCtrlDisconnectedAt;
                rightRemaining = Math.max(0, TIMEOUT_MS - elapsed);
                if (rightRemaining === 0 && !this.world.state.isGameOver)
                {
                    this.world.state.isGameOver = true;
                    this.world.state.winner = 'left';
                    this.world.state.isTimeoutRight = true;
					this.notifyGameEnd('timeout', 'left');
                }
            }

            if ((leftDisconnected || rightDisconnected) && !this.world.state.isGameOver)
            {
                this.broadcast({
                    type: 'timeout_status',
                    left: {
                        active: leftDisconnected,
                        remainingMs: leftRemaining
                    },
                    right: {
                        active: rightDisconnected,
                        remainingMs: rightRemaining
                    }
                });
            }
			const state = this.world.publicState();
			this.broadcast({type: 'state', state, serverTime: Date.now()});
			if (state.countdownValue > 0)
			{
				this.broadcast({type: 'countdown', value: state.countdownValue});
			}
			const pausedNow = state.isPaused;
			if (pausedNow !== this.lastPaused)
			{
				this.broadcast({type: pausedNow ? 'paused' : 'resumed'});
				this.lastPaused = pausedNow
			}
			if (state.isGameOver && !this.lastGameOver)
			{
				this.lastGameOver = true;
				this.broadcast({
					type: 'gameover', 
					winner: state.winner || 'left',
					isTournament: this.isTournament,
					tournamentId: this.tournamentId
				});
				this.notifyGameEnd('score', state.winner as 'left' | 'right');
			}
			if (this.clients.size === 0)
			{
				if (this.emptySince && (Date.now() - this.emptySince > 5 * 60_000))
				{
					rooms.delete(this.roomId || '');
					this.destroy();
					return;
				}
			}
			else
			{
				this.emptySince = null;
			}
		}, Math.round(1000 / BROADCAST_HZ));
	}

	private send(ws: WebSocket | undefined, msg: ServerMessage) {
		if (!ws || ws.readyState !== 1)
		{
			return;
		}
		ws.send(JSON.stringify(msg));
	}

	private broadcast(msg: ServerMessage) {
		for (const c of this.clients)
		{
			this.send(c, msg);
		}
	}

	cleanup(): void
	{
        if (this.tickTimer)
		{
            clearInterval(this.tickTimer);
            this.tickTimer = undefined;
        }
        if (this.broadcastTimer)
		{
            clearInterval(this.broadcastTimer);
            this.broadcastTimer = undefined;
        }
        this.clients.clear();
        this.roles.clear();
        this.log?.info({ roomId: this.roomId }, 'GameSession cleaned up');
    }
}

export const getSessionForRoom = (roomId: string, log?: FastifyBaseLogger) => {
    if (!rooms.has(roomId))
    {
        log?.warn(`Attempt to access non-existent room: ${roomId}`);
        return null;
    }
    return (rooms.get(roomId)!);
}

export const setMatchForRoom = (
	roomId: string,
	players: {left: Player; right: Player},
	metadata?: {
		isTournament?: boolean;
		tournamentId?: string;
		matchId?: string;
	},
	log?: FastifyBaseLogger
) => {
    const session = new GameSession(roomId, log);
	if (!session)
		return null;
	rooms.set(roomId, session);
    session.setPlayers(players, metadata);
    return session;
}

export const cleanupSession = (roomId: string): boolean => {
    const session = rooms.get(roomId);
    if (session) {
        session.cleanup();
        rooms.delete(roomId);
        return true;
    }
    return false;
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/ws/messageTypes.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export type ClientMessage =
	| {type: 'input'; up: boolean; down: boolean }
	| {type: 'pause'}
	| {type: 'resume'}
	| {type: 'ping'; t: number}
	| {type: 'skill'}
	| {type: 'forfeit'}
	| {type: 'logIn'; id: string}
    | {type: 'debug'; action: 'activate_powerup'; payload: {kind: 'split' | 'blackout' | 'blackhole'}}
    | {type: 'debug'; action: 'clear_powerups'}
    | {type: 'debug'; action: 'score_change'; payload: {side: 'left' | 'right'; amount: number}}
    | {type: 'debug'; action: 'reset_score'}
    | {type: 'debug'; action: 'set_score'; payload: {left: number; right: number}}
    | {type: 'debug'; action: 'ball_control'; payload: {mode: 'add' | 'remove' | 'reset'}}
    | {type: 'debug'; action: 'ball_speed'; payload: {mode: 'multiply' | 'divide' | 'freeze'}}
    | {type: 'debug'; action: 'time_scale'; payload: {scale: number}}
    | {type: 'debug'; action: 'change_skill'; payload: {side: 'left' | 'right'; skill: 'smash' | 'dash'}};

export type ServerMessage = 
	| {type: 'welcome'; side: 'left' | 'right' | 'spectator'; isTournament?: boolean; tournamentId?: string; players?: {left?: string; right?: string}}
	| {type: 'state'; state: PublicState; serverTime: number}
	| {type: 'countdown'; value: number}
	| {type: 'paused'}
	| {type: 'resumed'}
    | {type: 'timeout_status'; left: {active: boolean; remainingMs: number};
                               right: {active: boolean; remainingMs: number}}
	| {type: 'gameover'; winner: 'left' | 'right' | 'nobody'; isTournament?: boolean; tournamentId?: string}
	| {type: 'pong'; t: number}
	| {type: 'error'; message: string};

export type PublicState = {
	leftPaddle: {y: number; speed: number; intention: number};
	rightPaddle: {y: number; speed: number; intention: number};
	balls: {x: number; y: number; vx: number, vy: number; radius: number}[];
	score: {left: number; right: number;};
	isPaused: boolean;
	isGameOver: boolean;
    isTimeoutLeft: boolean;
    isTimeoutRight: boolean;
	winner: '' | 'left' | 'right' | 'nobody';
	countdownValue: number;
	powerUps: {x: number; y: number; radius: number; type: 'split' | 'blackout' | 'blackhole'}[];
	splitActive: boolean;
	clock: number;
	blackoutLeft: boolean;
	blackoutRight: boolean;
	blackoutLeftIntensity: number;
	blackoutRightIntensity: number;
	blackholeActive: boolean;
	blackholeProgress: number;
	blackholeCenterX: number;
	blackholeCenterY: number;

	selectedSkills: {
		left: 'smash' | 'dash';
		right: 'smash' | 'dash';
	};
	skillStates: {
		left: {cooldownRemaining: number; lastActivationAt: number};
		right: {cooldownRemaining: number; lastActivationAt: number};
	};
};

export function safeParse<T>(raw: string): T | null {
	try 
	{
		return JSON.parse(raw) as T;
	}
	catch
	{
		return (null);
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/game.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify, { FastifyInstance, FastifyRequest } from 'fastify'
import type { WebSocket } from 'ws'
import { getSessionForRoom } from './session/session'

export const handleGame = (conn: WebSocket, _req: FastifyRequest, fastify: FastifyInstance) : void => {
	fastify.log.info({ url: _req.url, params: _req.params, query: _req.query }, 'WS connect');
    const {roomId} = (_req.params ?? {}) as {roomId?: string};

    const room = getSessionForRoom(roomId || '', fastify.log);
    if (!room)
    {
        fastify.log.warn(`Closing connection to invalid room: ${roomId}`);
        conn.close(1008, 'Room does not exist');
        return;
    }
    room.addClient(conn);
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/engine/world.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { 
	WORLD_WIDTH, WORLD_HEIGHT, PADDLE_MARGIN, PADDLE_HEIGHT, PADDLE_SPEED,
	PADDLE_SPEED_INCREASE, BALL_INITIAL_SPEED, BALL_SPEED_INCREASE, BALL_MAX_SPEED,
	BALL_RADIUS, SCORE_TO_WIN, PADDLE_MAX_SPEED, SMASH_ANIM_DURATION,
	PADDLE_WIDTH, MAX_BALLS_ON_FIELD, PADDLE_TO_BALL_SPEED_RATIO} from "./constants";
import type { Ball, GameState, Side, SkillType } from "./types";
import { clamp } from "./helpers";
import { bounceOnWalls, checkPaddleCollision, resolveBallBallCollision } from "./physics";
import { activateSplit, endSplit, pruneExpiredPowerUps, scheduleNextPowerUp, spawnPowerUp,
	activateBlackout, updateBlackout, activateBlackhole, updateBlackhole, endBlackhole } from "./powerups";
import { activateSkill, isSmashActive, isDashActive, getSmashSpeedMultiplier, getDashSpeed, getSkillCooldown } from "./skills";
import type { PublicState } from "../ws/messageTypes";

const newBall = (vx: number, vy: number): Ball => ({
	x: WORLD_WIDTH / 2,
	y: WORLD_HEIGHT / 2,
	vx,
	vy,
	radius: BALL_RADIUS,
	lastPaddleHit: ''
});

export interface GameEventCallbacks {
	onPaddleHit?: (side: 'left' | 'right') => void;
	onPowerUpCollected?: (side: 'left' | 'right', type: 'split' | 'blackout' | 'blackhole', gameTime: number) => void;
	onBallSpeedUpdate?: (speed: number) => void;
	onSkillSuccess?: (side: 'left' | 'right', skillType: SkillType, gameTime: number) => void;
	onSmashSuccess?: (side: 'left' | 'right', gameTime: number) => void;
	onGoalScored?: (scorerSide: 'left' | 'right', ballYPosition: number, gameTime: number) => void;
}

export class GameWorld {
	state: GameState;
	callbacks: GameEventCallbacks = {};

	constructor() {
		this.state = this._freshState();
	}

	setCallbacks(callbacks: GameEventCallbacks) {
		this.callbacks = callbacks;
	}

	private _freshState(): GameState {
		return {
			leftPaddle: {speed: PADDLE_SPEED, y: WORLD_HEIGHT / 2, intention: 0},
			rightPaddle: {speed: PADDLE_SPEED, y: WORLD_HEIGHT / 2, intention: 0},
			balls: [newBall(Math.random() < 0.5 ? -BALL_INITIAL_SPEED : BALL_INITIAL_SPEED, 0)],
			score: {left: 0, right: 0},
			isPaused: false,
			isGameOver: false,
            isTimeoutLeft: false,
            isTimeoutRight: false,
			winner: '',
			clock: 0,
			countdownValue: 0,
			countdownTimer: 0,
			powerUps: [],
			nextPowerUpAt: 5 + Math.random() * 10,
			splitActive: false,
			splitEndsAt: 0,
			blackoutLeft: false,
			blackoutRight: false,
			blackoutLeftEndsAt: 0,
			blackoutRightEndsAt: 0,
			blackoutLeftIntensity: 0,
			blackoutRightIntensity: 0,
			blackholeActive: false,
			blackholeStartAt: 0,
			blackholeEndsAt: 0,
			blackholeCenterX: WORLD_WIDTH / 2,
			blackholeCenterY: WORLD_HEIGHT / 2,
			selectedSkills: {
				left: 'smash',
				right: 'smash'
			},
			skillStates: {
				left: {availableAt: 0, lastPressAt: -1e9, lastActivationAt: -1e9},
				right: {availableAt: 0, lastPressAt: -1e9, lastActivationAt: -1e9}
			}
		};
	}

	applyInput(side: 'left' | 'right', intention: -1 | 0 | 1) {
		(side === 'left' ? this.state.leftPaddle : this.state.rightPaddle).intention = intention;
	}

	useSkill(side: Side) {
		activateSkill(this.state, side);
	}

	setSkill(side: Side, skillType: SkillType) {
		this.state.selectedSkills[side] = skillType;
	}

	private getMaxBallSpeed(): number {
		let maxSpeed = BALL_INITIAL_SPEED;
		for (const ball of this.state.balls) {
			const speed = Math.hypot(ball.vx, ball.vy);
			if (speed > maxSpeed) {
				maxSpeed = speed;
			}
		}
		return maxSpeed;
	}

	pressSmash(side: Side): boolean
	{
		const sm = this.state.skillStates[side];
        if (this.state.clock >= sm.availableAt)
        {
            sm.lastActivationAt = this.state.clock;
            sm.availableAt = this.state.clock + SMASH_COOLDOWN;
            sm.lastPressAt = this.state.clock;
			return true;
        }
		return false;
	}

	startCountdown() {
		this.state.countdownValue = 3;
		this.state.countdownTimer = 0;
		this.state.isPaused = true;
	}

	pause() {
		if (this.state.countdownValue === 0)
		{
			this.state.isPaused = true;
		}
	}
	
	resume() {
		if (this.state.countdownValue === 0)
		{
			this.startCountdown();
		}
	}

	update(dt: number) {
		const s = this.state;

		if (s.countdownValue > 0)
		{
			s.countdownTimer += dt;
			if (s.countdownTimer >= 1)
			{
				s.countdownValue--;
				s.countdownTimer = 0;
				if (s.countdownValue <= 0)
				{
					s.isPaused = false;
				}
			}
			return;
		}
		if (s.isPaused || s.isGameOver)
		{
			return;
		}
		s.clock += dt;
		updateBlackout(s, dt);
		updateBlackhole(s, dt);

		const maxBallSpeed = this.getMaxBallSpeed();
		const calculatedPaddleSpeed = Math.min(
			Math.max(PADDLE_SPEED, maxBallSpeed * PADDLE_TO_BALL_SPEED_RATIO),
			PADDLE_MAX_SPEED
		);
		s.leftPaddle.speed = calculatedPaddleSpeed;
		s.rightPaddle.speed = calculatedPaddleSpeed;

		const leftDashActive = isDashActive(s, 'left');
		const rightDashActive = isDashActive(s, 'right');
		const leftSpeed = leftDashActive ? getDashSpeed() : s.leftPaddle.speed;
		const rightSpeed = rightDashActive ? getDashSpeed() : s.rightPaddle.speed;

		if (leftDashActive && s.leftPaddle.intention !== 0) {
			this.callbacks.onSkillSuccess?.('left', 'dash', s.clock);
		}
		if (rightDashActive && s.rightPaddle.intention !== 0) {
			this.callbacks.onSkillSuccess?.('right', 'dash', s.clock);
		}

		s.leftPaddle.y = clamp(s.leftPaddle.y + s.leftPaddle.intention * leftSpeed * dt,
			PADDLE_HEIGHT / 2, WORLD_HEIGHT - PADDLE_HEIGHT / 2);
		s.rightPaddle.y = clamp(s.rightPaddle.y + s.rightPaddle.intention * rightSpeed * dt,
			PADDLE_HEIGHT / 2, WORLD_HEIGHT - PADDLE_HEIGHT / 2);
		
		if (s.clock >= s.nextPowerUpAt)
		{
			spawnPowerUp(s);
			scheduleNextPowerUp(s);
		}

		pruneExpiredPowerUps(s);

		const leftX = PADDLE_MARGIN;
		const rightX = WORLD_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;

		for (let i = s.powerUps.length - 1; i >= 0; i--)
		{
			const pu = s.powerUps[i];
			let picked = false;
			for (const b of s.balls)
			{
				const dx = b.x - pu.x;
				const dy = b.y - pu.y;
				if (Math.hypot(dx, dy) <= b.radius + pu.radius)
				{
					s.powerUps.splice(i, 1);
					
					const side: 'left' | 'right' = b.lastPaddleHit === 'left' ? 'left' : 
												  b.lastPaddleHit === 'right' ? 'right' :
												  b.x < WORLD_WIDTH / 2 ? 'left' : 'right';
					
					this.callbacks.onPowerUpCollected?.(side, pu.type, s.clock);
					
					if (pu.type === 'split')
					{
						activateSplit(s, b);
					}
					else if (pu.type === 'blackout')
					{
						activateBlackout(s, b);
					}
					else if (pu.type === 'blackhole')
					{
						activateBlackhole(s);
					}
					picked = true;
					break;
				}
			}
			if (picked)
			{
				continue;
			}
		}

		for (const b of s.balls)
		{
			b.x += b.vx * dt;
			b.y += b.vy * dt;
			bounceOnWalls(b);
			if (b.lastPaddleHit === 'left' && b.x - b.radius > leftX + PADDLE_WIDTH + 2)
			{
				b.lastPaddleHit = '';
			}
			if (b.lastPaddleHit === 'right' && b.x + b.radius < rightX - 2)
			{
				b.lastPaddleHit = '';
			}
			const hitL = checkPaddleCollision(b, leftX, s.leftPaddle.y, true);
			const hitR = checkPaddleCollision(b, rightX, s.rightPaddle.y, false);
			if (hitL || hitR)
			{
				if (hitL) this.callbacks.onPaddleHit?.('left');
				if (hitR) this.callbacks.onPaddleHit?.('right');
				
				const curr = Math.max(1e-6, Math.hypot(b.vx, b.vy));
				let target = Math.min(curr * BALL_SPEED_INCREASE, BALL_MAX_SPEED);

				const side: Side | '' = hitL ? 'left' : hitR ? 'right' : '';
				if (side)
				{
					if (isSmashActive(s, side))
					{
						target = Math.min(target * getSmashSpeedMultiplier(), BALL_MAX_SPEED);
						this.callbacks.onSkillSuccess?.(side, 'smash', s.clock);
					}
				}

				const norm = Math.max(1e-6, Math.hypot(b.vx, b.vy));
				const k = target / norm;
				b.vx *= k;
				b.vy *= k;
				
				this.callbacks.onBallSpeedUpdate?.(target);
			}
		}
		if (s.balls.length > 1)
		{
			for (let i = 0; i < s.balls.length; i++)
			{
				for (let j = i + 1; j < s.balls.length; j++)
				{
					resolveBallBallCollision(s.balls[i], s.balls[j]);
				}
			}
		}
		if (s.splitActive && s.clock >= s.splitEndsAt)
		{
			endSplit(s);
		}
		const removed: number[] = [];
		for (let i = 0; i < s.balls.length; i++)
		{
			const b = s.balls[i];
			if (b.x + b.radius <= 0)
			{
				s.score.right++;
				removed.push(i);
				// Notifier le goal marquÃ© par le joueur de droite
				this.callbacks.onGoalScored?.('right', b.y, s.clock);
			}
			else if (b.x - b.radius >= WORLD_WIDTH)
			{
				s.score.left++;
				removed.push(i);
				// Notifier le goal marquÃ© par le joueur de gauche
				this.callbacks.onGoalScored?.('left', b.y, s.clock);
			}
		}
		for (let i = removed.length - 1; i >= 0; i--)
		{
			s.balls.splice(removed[i], 1);
		}
		if (s.score.left >= SCORE_TO_WIN || s.score.right >= SCORE_TO_WIN)
		{
			s.isGameOver = true;
			s.isPaused = true;
			s.winner = s.score.left >= SCORE_TO_WIN ? 'left' : 'right';
			return;
		}
		if (s.balls.length === 0)
		{
			s.balls = [newBall((Math.random() < 0.5 ? -1 : 1) * BALL_INITIAL_SPEED, 0)];
			s.splitActive = false;
			s.splitEndsAt = 0;
			scheduleNextPowerUp(s);
		}
	}

    public debugActivatePowerUp(kind: 'split' | 'blackout' | 'blackhole'): void {
        switch (kind) {
            case 'split':
                activateSplit(this.state);
                break;
            case 'blackout': {
                const b = this.state.balls[0];
                if (!b) return;
                if (!b.lastPaddleHit) 
                {
                    b.lastPaddleHit = 'left';
                }
                activateBlackout(this.state, b);
                break;
            }
            case 'blackhole':
                activateBlackhole(this.state);
                break;
        }
    }

    public debugClearPowerUps(): void {
        const s = this.state;
        s.powerUps = [];
        s.splitActive = false;
        s.splitEndsAt = 0;
        s.blackoutLeft = false;
        s.blackoutRight = false;
        s.blackoutLeftEndsAt = 0;
        s.blackoutRightEndsAt = 0;
        s.blackoutLeftIntensity = 0;
        s.blackoutRightIntensity = 0;
        if (s.blackholeActive) {
        endBlackhole(s);
        }
    }

    public debugChangeScore(side: 'left' | 'right', amount: number): void {
        const s = this.state;
        s.score[side] = Math.max(0, s.score[side] + amount);
        if (s.score.left >= SCORE_TO_WIN || s.score.right >= SCORE_TO_WIN) {
        s.isGameOver = true;
        s.isPaused = true;
        s.winner = s.score.left >= SCORE_TO_WIN ? 'left' : 'right';
        }
    }

    public debugResetScore(): void {
        const s = this.state;
        s.score.left = 0;
        s.score.right = 0;
        s.isGameOver = false;
        s.winner = '';
        s.isPaused = false;
    }

     public debugSetScore(left: number, right: number): void {
        const s = this.state;
        s.score.left = Math.max(0, left);
        s.score.right = Math.max(0, right);
        if (s.score.left >= SCORE_TO_WIN || s.score.right >= SCORE_TO_WIN) {
        s.isGameOver = true;
        s.isPaused = true;
        s.winner = s.score.left >= SCORE_TO_WIN ? 'left' : 'right';
        }
    }

    public debugBallControl(mode: 'add' | 'remove' | 'reset'): void {
        const s = this.state;
        switch (mode) {
        case 'add':
            if (s.balls.length < MAX_BALLS_ON_FIELD) {
            s.balls.push({
                x: WORLD_WIDTH / 2,
                y: WORLD_HEIGHT / 2,
                vx: (Math.random() < 0.5 ? -1 : 1) * BALL_INITIAL_SPEED,
                vy: (Math.random() - 0.5) * 200,
                radius: BALL_RADIUS,
                lastPaddleHit: ''
            });
            }
            break;
        case 'remove':
            if (s.balls.length > 1) {
            s.balls.pop();
            }
            break;
        case 'reset':
            s.balls = [{
            x: WORLD_WIDTH / 2,
            y: WORLD_HEIGHT / 2,
            vx: BALL_INITIAL_SPEED,
            vy: 0,
            radius: BALL_RADIUS,
            lastPaddleHit: ''
            }];
            break;
        }
    }

    private frozenVelocities: Map<number, { vx: number; vy: number }> = new Map();
    private isFrozen: boolean = false;

    public debugBallSpeed(mode: 'multiply' | 'divide' | 'freeze'): void {
        const s = this.state;
        
        if (mode === 'freeze') {
            if (!this.isFrozen) {
                this.frozenVelocities.clear();
                for (let i = 0; i < s.balls.length; i++) {
                    const b = s.balls[i];
                    this.frozenVelocities.set(i, { vx: b.vx, vy: b.vy });
                    b.vx = 0;
                    b.vy = 0;
                }
                this.isFrozen = true;
            } else {
                for (let i = 0; i < s.balls.length; i++) {
                    const b = s.balls[i];
                    const saved = this.frozenVelocities.get(i);
                    if (saved) {
                        b.vx = saved.vx;
                        b.vy = saved.vy;
                    }
                }
                this.frozenVelocities.clear();
                this.isFrozen = false;
            }
            return;
        }
        
        for (const b of s.balls) {
            const factor = mode === 'multiply' ? 2 : 0.5;
            b.vx *= factor;
            b.vy *= factor;
            const sp = Math.max(1e-6, Math.hypot(b.vx, b.vy));
            if (sp > BALL_MAX_SPEED) {
                const k = BALL_MAX_SPEED / sp;
                b.vx *= k;
                b.vy *= k;
            }
        }
    }

	publicState(): PublicState {
		const s = this.state;
		const progress = s.blackholeActive ? 
		Math.max(0, Math.min(1, 1 - (s.blackholeEndsAt - s.clock) / Math.max(1e-6, (s.blackholeEndsAt - s.blackholeStartAt)))) 
		: 0;
		return {
			leftPaddle: {...s.leftPaddle},
			rightPaddle: {...s.rightPaddle},
			balls: s.balls.map(({x, y, vx, vy, radius}) => ({x, y, vx, vy, radius})),
			score: {...s.score},
			isPaused: s.isPaused,
			isGameOver: s.isGameOver,
            isTimeoutLeft: s.isTimeoutLeft,
            isTimeoutRight: s.isTimeoutRight,
			winner: s.winner,
			countdownValue: s.countdownValue,
			powerUps: s.powerUps.map(({x, y, radius, type}) => ({x, y, radius, type})),
			splitActive: s.splitActive,
			clock: s.clock,
			blackoutLeft: s.blackoutLeft,
			blackoutRight: s.blackoutRight,
			blackoutLeftIntensity: s.blackoutLeftIntensity,
			blackoutRightIntensity: s.blackoutRightIntensity,
			blackholeActive: s.blackholeActive,
			blackholeProgress: progress,
			blackholeCenterX: s.blackholeCenterX,
			blackholeCenterY: s.blackholeCenterY,
			selectedSkills: {...s.selectedSkills},
			skillStates: {
				left: {
					cooldownRemaining: Math.max(0, s.skillStates.left.availableAt - s.clock),
					lastActivationAt: s.skillStates.left.lastActivationAt
				},
				right: {
					cooldownRemaining: Math.max(0, s.skillStates.right.availableAt - s.clock),
					lastActivationAt: s.skillStates.right.lastActivationAt
				}
			}
		};
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/engine/skills.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { GameState, Side, SkillType } from "./types";
import { SMASH_COOLDOWN, SMASH_TIMING_WINDOW, SMASH_SPEED_MULTIPLIER, DASH_COOLDOWN, DASH_DURATION, DASH_SPEED } from "./constants";

export const activateSkill = (state: GameState, side: Side): void => {
	const skillType = state.selectedSkills[side];
	const skill = state.skillStates[side];
	
	if (state.clock < skill.availableAt) {
		return;
	}

	const cooldown = skillType === 'smash' ? SMASH_COOLDOWN : DASH_COOLDOWN;
	skill.lastActivationAt = state.clock;
	skill.availableAt = state.clock + cooldown;
	skill.lastPressAt = state.clock;
};

export const isSmashActive = (state: GameState, side: Side): boolean => {
	if (state.selectedSkills[side] !== 'smash') return false;
	const skill = state.skillStates[side];
	return (state.clock - skill.lastActivationAt) <= SMASH_TIMING_WINDOW;
};

export const isDashActive = (state: GameState, side: Side): boolean => {
	if (state.selectedSkills[side] !== 'dash') return false;
	const skill = state.skillStates[side];
	return (state.clock - skill.lastActivationAt) <= DASH_DURATION;
};

export const getSmashSpeedMultiplier = (): number => {
	return SMASH_SPEED_MULTIPLIER;
};

export const getDashSpeed = (): number => {
	return DASH_SPEED;
};

export const getSkillCooldown = (skillType: SkillType): number => {
	return skillType === 'smash' ? SMASH_COOLDOWN : DASH_COOLDOWN;
};




â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/engine/physics.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { PADDLE_HEIGHT, PADDLE_WIDTH, MAX_BOUNCE_DEG, WORLD_HEIGHT, BALL_MAX_SPEED } from "./constants";
import { clamp } from "./helpers";
import type { Ball } from "./types";

export const checkPaddleCollision = (
	ball: Ball,
	paddleX: number,
	paddleY: number,
	isLeftPaddle: boolean
): boolean => {
	const paddleName = isLeftPaddle ? 'left' : 'right';
	if (ball.lastPaddleHit === paddleName)
	{
		return false;
	}

	const speedBefore = Math.max(1e-6, Math.hypot(ball.vx, ball.vy));
	const rectLeft = paddleX;
	const rectRight = paddleX + PADDLE_WIDTH;
	const rectTop = paddleY - PADDLE_HEIGHT / 2;
	const rectBottom = paddleY + PADDLE_HEIGHT / 2;

	const cx = clamp(ball.x, rectLeft, rectRight);
	const cy = clamp(ball.y, rectTop, rectBottom);

	let nx = ball.x - cx;
	let ny = ball.y - cy;

	const r = ball.radius;
	const dist2 = nx * nx + ny * ny;
	if (dist2 > r * r) 
	{
		return false;
	}

	let dist = Math.sqrt(dist2);
	if (dist === 0)
	{
		const midX = (rectLeft + rectRight) / 2;
		const midY = (rectTop + rectBottom) / 2;
		const penX = Math.min(Math.abs(ball.x - rectLeft), Math.abs(rectRight - ball.x));
		const penY = Math.min(Math.abs(ball.y - rectTop), Math.abs(rectBottom - ball.y));
		if (penX < penY)
		{
			nx = ball.x < midX ? -1 : 1;
			ny = 0;
		}
		else
		{
			nx = 0;
			ny = ball.y < midY ? -1 : 1;
		}
		dist = 0;
	}
	else
	{
		nx /= dist;
		ny /= dist;
	}

	const penetration = r - dist + 0.01;
	ball.x += nx * penetration;
	ball.y += ny * penetration;

	const MAX_BOUNCE_RAD = (MAX_BOUNCE_DEG * Math.PI) / 180;
	const rel = clamp((ball.y - paddleY) / (PADDLE_HEIGHT / 2), -1, 1);
	const angle = rel * MAX_BOUNCE_RAD;
	const dir = isLeftPaddle ? 1 : -1;
	ball.vx = Math.cos(angle) * speedBefore * dir;
	ball.vy = Math.sin(angle) * speedBefore;
	ball.lastPaddleHit = paddleName;
	return true;
};

export const resolveBallBallCollision = (a: Ball, b: Ball) => {
	const dx = b.x - a.x;
	const dy = b.y - a.y;
	const dist = Math.max(1e-6, Math.hypot(dx, dy));
	const minDist = a.radius + b.radius;
	if (dist >= minDist)
	{
		return;
	}
	const nx = dx / dist;
	const ny = dy / dist;
	const tx = -ny;
	const ty = nx;
	
	const va_n = a.vx * nx + a.vy * ny;
	const va_t = a.vx * tx + a.vy * ty;
	const vb_n = b.vx * nx + b.vy * ny;
	const vb_t = b.vx * tx + b.vy * ty;

	const va_n_after = vb_n; 
	const vb_n_after = va_n;

	a.vx = va_n_after * nx + va_t * tx;
	a.vy = va_n_after * ny + va_t * ty;
	b.vx = vb_n_after * nx + vb_t * tx;
	b.vy = vb_n_after * ny + vb_t * ty;

	const overlap = minDist - dist + 0.5;
	a.x -= nx * overlap * 0.5;
	a.y -= ny * overlap * 0.5;
	b.x += nx * overlap * 0.5;
	b.y += ny * overlap * 0.5;
};

export const bounceOnWalls = (b: Ball) => {
	if (b.y - b.radius <= 0)
	{
		b.y = b.radius;
		b.vy = Math.abs(b.vy);
	}
	else if (b.y + b.radius >= WORLD_HEIGHT)
	{
		b.y = WORLD_HEIGHT - b.radius;
		b.vy = -Math.abs(b.vy);
	}
};


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/engine/types.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export type Side = 'left' | 'right';
export type SkillType = 'smash' | 'dash';

export type Ball = {
	x: number;
	y: number;
	vx: number;
	vy: number;
	radius: number;
	lastPaddleHit: '' | 'left' | 'right';
	bhSpeed?: number;
};

export type PowerUp = {
	id: number;
	x: number;
	y: number;
	radius: number;
	expiresAt: number;
	type: 'split' | 'blackout' | 'blackhole';
};

export type SkillState = {
	availableAt: number;
	lastPressAt: number;
	lastActivationAt: number;
};

export type GameState = {
	leftPaddle: {speed: number; y: number; intention: number};
	rightPaddle: {speed: number; y: number; intention: number};
	balls: Ball[];
	score: { left: number; right: number};
	isPaused: boolean;
	isGameOver: boolean;
    isTimeoutLeft: boolean;
    isTimeoutRight: boolean;
	winner: '' | 'left' | 'right';
	clock: number;
	countdownValue: number;
	countdownTimer: number;
	powerUps: PowerUp[];
	nextPowerUpAt: number;
	splitActive: boolean;
	splitEndsAt: number;

	blackoutLeft: boolean;
	blackoutRight: boolean;
	blackoutLeftEndsAt: number;
	blackoutRightEndsAt: number;
	blackoutLeftIntensity: number;
	blackoutRightIntensity: number;

	blackholeActive: boolean;
	blackholeStartAt: number;
	blackholeEndsAt: number;
	blackholeCenterX: number;
	blackholeCenterY: number;

	selectedSkills: {
		left: SkillType;
		right: SkillType;
	};
	skillStates: {
		left: SkillState;
		right: SkillState;
	}
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/engine/powerups.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { WORLD_WIDTH, WORLD_HEIGHT, POWERUP_MIN_DELAY_SEC,
	POWERUP_EXTRA_RANDOM_SEC, POWERUP_LIFETIME_SEC, SPLIT_DURATION_SEC, 
	POWERUP_RADIUS, MAX_BALLS_ON_FIELD, SPLIT_SPAWN_PER_PICKUP, SPLIT_SPREAD_DEG,
	POWERUP_MAX_ON_SCREEN, BLACKOUT_DURATION_SEC, BLACKOUT_FADE_DURATION_SEC,
	BLACKHOLE_DURATION_SEC, BLACKHOLE_PULL, BLACKHOLE_SWIRL, BALL_MAX_SPEED,
	BALL_INITIAL_SPEED} from "./constants";
import { length2, scheduleAfter } from "./helpers";
import type { Ball, GameState } from "./types";

let PU_ID = 1;

export const scheduleNextPowerUp = (state: GameState) => {
	state.nextPowerUpAt = scheduleAfter(state.clock, POWERUP_MIN_DELAY_SEC, POWERUP_EXTRA_RANDOM_SEC);
};

export const spawnPowerUp = (state: GameState) => {
	if (state.powerUps.length >= POWERUP_MAX_ON_SCREEN)
	{
		return;
	}
	const types: Array<'split' | 'blackout' | 'blackhole'> = ['split', 'blackout', 'blackhole'];
	const type = types[Math.floor(Math.random() * types.length)];
	const margin = 150;
	state.powerUps.push({
		id: PU_ID++,
		x: margin + Math.random() * (WORLD_WIDTH - 2 * margin),
		y: margin + Math.random() * (WORLD_HEIGHT - 2 * margin),
		radius: POWERUP_RADIUS,
		expiresAt: state.clock + POWERUP_LIFETIME_SEC,
		type: type
	});
};

export const pruneExpiredPowerUps = (state: GameState) => {
	state.powerUps = state.powerUps.filter(p => p.expiresAt > state.clock);
}

export const activateSplit = (state: GameState, fromBall?: Ball) => {
	const spreadRad = (SPLIT_SPREAD_DEG * Math.PI) / 180;
	state.splitActive = true;
	state.splitEndsAt = Math.max(state.splitEndsAt, state.clock + SPLIT_DURATION_SEC);
	if (state.balls.length === 0)
	{
		return ;
	}
	const canAdd = Math.max(0, MAX_BALLS_ON_FIELD - state.balls.length);
	const toAdd = Math.min(SPLIT_SPAWN_PER_PICKUP, canAdd);
	if (toAdd <= 0)
	{
		return;
	}
	const src = fromBall ?? state.balls[0];
	const speed = Math.max(1e-6, length2(src.vx, src.vy));
	const base = Math.atan2(src.vy, src.vx);

	const makeAtAngle = (angle : number): Ball => ({
		...src,
		vx: Math.cos(angle) * speed,
		vy: Math.sin(angle) * speed,
		lastPaddleHit: src.lastPaddleHit
	});

	for (let i = 0; i < toAdd; i++)
	{
		const offset = (Math.random() * 2 - 1) * spreadRad;
		state.balls.push(makeAtAngle(base + offset));
	}
};

export const endSplit = (state: GameState) => {
	state.splitActive = false;
	if (state.balls.length > 1)
	{
		let keep = 0;
		let best = -Infinity;
		for (let i = 0; i < state.balls.length; i++)
		{
			const k = Math.abs(state.balls[i].vx);
			if (k > best)
			{
				best = k;
				keep = i;
			}
		}
		state.balls = [state.balls[keep]];
		scheduleNextPowerUp(state);
	}
};

export const activateBlackout = (state: GameState, ball: Ball) => {
	const lastHit = ball.lastPaddleHit || (ball.vx >= 0 ? 'left' : 'right');

	if (lastHit === 'left')
	{
		state.blackoutRight = true;
		state.blackoutRightEndsAt = state.clock + BLACKOUT_DURATION_SEC;
		state.blackoutRightIntensity = 0;
	}
	else if (lastHit === 'right')
	{
		state.blackoutLeft = true;
		state.blackoutLeftEndsAt = state.clock + BLACKOUT_DURATION_SEC;
		state.blackoutLeftIntensity = 0;
	}
};

export const updateBlackout = (state: GameState, dt: number) => {
	if (state.blackoutLeft) 
	{
		const timeRemaining = state.blackoutLeftEndsAt - state.clock;
		if (timeRemaining <= 0)
		{
			state.blackoutLeftIntensity = Math.max(0, state.blackoutLeftIntensity - (dt / BLACKOUT_FADE_DURATION_SEC));
			if (state.blackoutLeftIntensity <= 0)
			{
				state.blackoutLeft = false;
				state.blackoutLeftIntensity = 0;
			}
		}
		else if (timeRemaining > BLACKOUT_DURATION_SEC - BLACKOUT_FADE_DURATION_SEC)
		{
				const fadeProgress = (BLACKOUT_DURATION_SEC - timeRemaining) / BLACKOUT_FADE_DURATION_SEC;
				state.blackoutLeftIntensity = Math.min(1, fadeProgress);
		}
		else if (timeRemaining <= BLACKOUT_FADE_DURATION_SEC) 
		{
			state.blackoutLeftIntensity = 1;
		}
		else
		{
				state.blackoutLeftIntensity = 1;
		}
	}
	if (state.blackoutRight) 
	{
		const timeRemaining = state.blackoutRightEndsAt - state.clock;
		
		if (timeRemaining <= 0) 
		{
			state.blackoutRightIntensity = Math.max(0, state.blackoutRightIntensity - (dt / BLACKOUT_FADE_DURATION_SEC));
			
			if (state.blackoutRightIntensity <= 0) {
				state.blackoutRight = false;
				state.blackoutRightIntensity = 0;
			}
		} 
		else if (timeRemaining > BLACKOUT_DURATION_SEC - BLACKOUT_FADE_DURATION_SEC) 
		{
			const fadeProgress = (BLACKOUT_DURATION_SEC - timeRemaining) / BLACKOUT_FADE_DURATION_SEC;
			state.blackoutRightIntensity = Math.min(1, fadeProgress);
		} 
		else if (timeRemaining <= BLACKOUT_FADE_DURATION_SEC) 
		{
			state.blackoutRightIntensity = 1;
		} 
		else 
		{
			state.blackoutRightIntensity = 1;
		}
	}

};

export const activateBlackhole = (state: GameState) => {
	state.blackholeActive = true;
	state.blackholeStartAt = state.clock;
	state.blackholeEndsAt = state.clock + BLACKHOLE_DURATION_SEC;
	state.blackholeCenterX = WORLD_WIDTH / 2;
	state.blackholeCenterY = WORLD_HEIGHT / 2;
	for (const b of state.balls)
	{
		const sp = Math.max(1e-6, Math.hypot(b.vx, b.vy));
		b.bhSpeed = sp > 1e-6 ? sp : BALL_INITIAL_SPEED;
	}
};

export const updateBlackhole = (state: GameState, dt: number) => {
	if (!state.blackholeActive)
	{
		return;
	}

	const cx = state.blackholeCenterX;
	const cy = state.blackholeCenterY;
	const progress = Math.max(0, Math.min(1, 1 - (state.blackholeEndsAt - state.clock) / BLACKHOLE_DURATION_SEC));
	const pull = BLACKHOLE_PULL * (0.6 + 0.8 * progress);
	const swirl = BLACKHOLE_SWIRL * (0.6 + 0.8 * progress);

	for (const b of state.balls)
	{
		if (b.bhSpeed === undefined)
		{
			const sp0 = Math.max(1e-6, Math.hypot(b.vx, b.vy));
			b.bhSpeed = sp0 > 1e-6 ? sp0 : BALL_INITIAL_SPEED;
		}
		const dx = cx - b.x;
		const dy = cy - b.y;
		const dist = Math.max(1e-3, Math.hypot(dx, dy));
		const nx = dx / dist;
		const ny = dy / dist;

		const tx = -ny;
		const ty = nx;

		const ax = nx * pull + tx * swirl;
		const ay = ny * pull + ty * swirl;

		b.vx += ax * dt;
		b.vy += ay * dt;

		const target = b.bhSpeed!;
		const cur = Math.max(1e-6, Math.hypot(b.vx, b.vy));
		const k = target / cur;
		b.vx *= k;
		b.vy *= k;
	}
	if (state.clock >= state.blackholeEndsAt)
	{
		endBlackhole(state);
	}
};

export const endBlackhole = (state: GameState) => {
	for (const b of state.balls)
	{
		delete b.bhSpeed;
	}
	state.blackholeActive = false;
	scheduleNextPowerUp(state);
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/engine/helpers.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export const clamp = (v: number, min: number, max: number) =>
	Math.max(min, Math.min(max, v));
export const length2 = (x: number, y: number) => Math.sqrt(x * x + y * y);
export const scheduleAfter = (now: number, min: number, rand: number) =>
	now + min + Math.random() * rand;


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/gameback/game/engine/constants.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export const WORLD_WIDTH = 1920
export const WORLD_HEIGHT = 1080;

export const PADDLE_WIDTH = 15;
export const PADDLE_HEIGHT = 100;
export const PADDLE_MARGIN = 30;
export const PADDLE_SPEED = 400;
export const PADDLE_SPEED_INCREASE = 1.05;
export const PADDLE_MAX_SPEED = 1600;
export const PADDLE_TO_BALL_SPEED_RATIO = 0.6;


export const BALL_RADIUS = 15;
export const BALL_INITIAL_SPEED = 600;
export const BALL_SPEED_INCREASE = 1.05;
export const BALL_MAX_SPEED = 1500;
export const MAX_BOUNCE_DEG = 45;

export const SCORE_TO_WIN = 11;

export const POWERUP_RADIUS = 55;
export const POWERUP_MIN_DELAY_SEC = 6;
export const POWERUP_EXTRA_RANDOM_SEC = 6;
export const POWERUP_LIFETIME_SEC = 9;
export const POWERUP_MAX_ON_SCREEN = 5;

export const MAX_BALLS_ON_FIELD = 10;
export const SPLIT_DURATION_SEC = 10;
export const SPLIT_SPAWN_PER_PICKUP = 1;
export const SPLIT_SPREAD_DEG = 20;

export const BLACKOUT_DURATION_SEC = 5;
export const BLACKOUT_FADE_DURATION_SEC = 0.5;

export const BLACKHOLE_DURATION_SEC = 8;
export const BLACKHOLE_PULL = 400;
export const BLACKHOLE_SWIRL = 1;

export const SMASH_COOLDOWN = 3;
export const SMASH_TIMING_WINDOW = 0.2;
export const SMASH_SPEED_MULTIPLIER = 1.2;
export const SMASH_ANIM_DURATION = 0.12;

export const DASH_COOLDOWN = 5;
export const DASH_DURATION = 0.3;
export const DASH_SPEED = 2000;

export const SERVER_TICK_HZ = 240;
export const SERVER_DT = 1 / SERVER_TICK_HZ;
export const BROADCAST_HZ = 60;
export const TIMEOUT_MS = 30000;



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/quickplayback/TounamentQuickPlay.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { FastifyInstance } from 'fastify'
import { RoomManager } from './RoomManager'
import { v4 as uuidv4 } from 'uuid'

export function handleTournamentQuickPlay(fastify: FastifyInstance, roomManager: RoomManager)
{
	fastify.post('/tournament-match', async (request, reply) => {
		const { matchId, tournamentId, player1, player2 } = request.body as {
			matchId: string;
			tournamentId: string;
			player1: { id: string; username: string };
			player2: { id: string; username: string };
		};

		if (!matchId || !tournamentId || !player1 || !player2)
		{
			return reply.code(400).send({ error: 'Invalid payload' });
		}

		const roomId = uuidv4();

		console.log(`Creating tournament match: ${player1.username} vs ${player2.username} (roomId: ${roomId})`);

		try
		{
			const room = roomManager.createTournamentRoom(
                roomId,
                { id: player1.id, username: player1.username, isReady: true },
                { id: player2.id, username: player2.username, isReady: true },
                tournamentId,
                matchId
            );

			const fetchURL = `http://gameback:3010/create`;

			const gameResponse = await fetch(fetchURL, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					roomId,
					player1,
					player2,
					isTournament: true,
					tournamentId,
					matchId
				})
			});

			if (!gameResponse.ok) {
				const errorText = await gameResponse.text();
				fastify.log.error({ status: gameResponse.status, error: errorText }, 'Tournament game creation failed');
				throw new Error(`Game creation failed: ${gameResponse.status}`);
			}

			console.log(`Tournament match created successfully: roomId=${roomId}`);

			return { 
				success: true, 
				roomId,
				matchId 
			};
		}
		catch (err)
		{
			fastify.log.error(err);
			return reply.code(500).send({ error: 'Failed to initialize game' });
		}
	});
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/quickplayback/server.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify from 'fastify'
import { handleQuickPlay } from './quickplay'
import { handleTournamentQuickPlay } from './TounamentQuickPlay'
import { RoomManager } from './RoomManager'

const fastify = Fastify({
	logger: true
})

export const roomManager = new RoomManager()

fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

fastify.get('/health', async (request, reply) => {
    return { status: 'ok', service: 'quickplay-backend' };
});

handleQuickPlay(fastify, roomManager);
handleTournamentQuickPlay(fastify, roomManager)

fastify.listen({ port: 3030, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/quickplayback/types.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export interface Player
{
	id: string;
	username: string;
	roomId ?: string;
	isReady: boolean;
	selectedSkill?: 'smash' | 'dash';
}

export interface Room
{
	id: string;
	players: Player[];
	status: 'waiting' | 'playing' | 'finished';
	createdAt: Date;
	isTournament?: boolean;
    tournamentId?: string;
    matchId?: string;
}

export type RoomFinishedPayload =
{
	roomId: string;
	reason: 'score' | 'timeout';
	winner?: Player | null;
	score?: { left: number; right: number };
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/quickplayback/quickplay.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { FastifyInstance } from 'fastify'
import { RoomManager } from './RoomManager'
import { Player } from './types'
import type { RoomFinishedPayload } from './types'
import { v4 as uuidv4 } from 'uuid'

async function callDatabase(endpoint: string, method: string = 'GET', body?: any) {
	const url = `http://database:3020${endpoint}`;
	
	const options: RequestInit = {
		method,
	};

	if (body && method !== 'GET') {
		options.headers = { 'Content-Type': 'application/json' };
		options.body = JSON.stringify(body);
	}
	
	const response = await fetch(url, options);
	return response.json();
}

export function handleQuickPlay(fastify: FastifyInstance, roomManager: RoomManager)
{
	fastify.post('/join', async (request, reply) => {
		const { username, playerId, selectedSkill } = request.body as { username: string; playerId: string; selectedSkill?: 'smash' | 'dash' };
		
		if (!username || !playerId) {
			return reply.code(400).send({ error: 'Username and playerId required' });
		}

		const normalizedSkill: 'smash' | 'dash' =
			selectedSkill === 'dash' ? 'dash' : 'smash';

		try
		{
			const userResult = await callDatabase('/users', 'POST', {
				id: playerId,
				username
			});
			
			if (!userResult.success)
			{
				fastify.log.warn({ playerId, username, error: userResult.error }, 'Failed to create user in DB');
				
				// VÃ©rifier si l'utilisateur existe dÃ©jÃ  avec cet ID
				const existingUser = await callDatabase(`/users/${playerId}`);
				//if (!existingUser.success)
				// {
				// 	// L'utilisateur n'existe pas avec cet ID, on ne peut pas continuer
				// 	return reply.code(500).send({ error: 'Failed to create or find user in database' });
				// }
			}
		}
		catch (err)
		{
			fastify.log.error({ playerId, username, err }, 'User creation request failed');
			return reply.code(500).send({ error: 'Failed to create user' });
		}

		try
		{
			await callDatabase(`/users/${playerId}/last-seen`, 'PATCH');
		}
		catch (err)
		{
			fastify.log.error({ playerId, err }, 'Failed to update last-seen');
		}

		const player: Player = {
			id: playerId,
			username,
			isReady: false,
			selectedSkill: normalizedSkill
		};

		const room = roomManager.findOrCreateRoom(player);
		
		if (room.players.length === 2)
		{
			const fetchURL = `http://gameback:3010/create`;

			const gameId = uuidv4();

			try
			{
				const leftPlayer = room.players[0];
				const rightPlayer = room.players[1];

				await callDatabase('/games', 'POST', {
					id: gameId,
					room_id: room.id,
					game_type: 'quickplay',
					player_left_id: room.players[0].id,
					player_right_id: room.players[1].id
				});

				const gameResponse = await fetch(fetchURL, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						roomId: room.id,
						player1: { 
							id: leftPlayer.id, 
							username: leftPlayer.username,
							selectedSkill: leftPlayer.selectedSkill || 'smash'
						},
						player2: { 
							id: rightPlayer.id, 
							username: rightPlayer.username,
							selectedSkill: rightPlayer.selectedSkill || 'smash'
						},
					}),
				});

				if (!gameResponse.ok) {
					const errorText = await gameResponse.text();
					fastify.log.error({ status: gameResponse.status, error: errorText }, 'Game creation failed');
					throw new Error(`Game creation failed: ${gameResponse.status}`);
				}

				room.status = 'playing';
			}
			catch (err)
			{
				fastify.log.error(err);
				return reply.code(500).send({ error: 'Failed to initialize game' });
			}
		}

		return { success: true, roomId: room.id, status: room.status };
	});

	fastify.get('/status/:roomId', async (request, reply) => {
		const { roomId } = request.params as { roomId: string };
		const room = roomManager.getRoom(roomId);
		
		if (!room)
		{
			return reply.code(404).send({ error: 'Room not found' });
		}

		if (room.status === 'playing')
		{
			const host = process.env.VITE_HOST;
			const game_endpoint = process.env.VITE_GAME_ENDPOINT;
			const baseGameWs = `wss://${host || 'localhost:8443'}${game_endpoint || '/gameback/game'}/${roomId}`;
			
			return {
				success: true,
				status: 'ready',
				roomId,
				gameServerURL: baseGameWs,
				players: room.players.length,
				isTournament: room.isTournament || false,
				tournamentId: room.tournamentId,
				matchId: room.matchId
			};
		}

		return { 
			success: true,
			status: room.status, 
			players: room.players.length,
			maxPlayers: 2
		};
	});

	fastify.post('/room-finished', async (request, reply) => {
		try
		{
			const body = request.body as Partial<RoomFinishedPayload> | undefined;
			if (!body || !body.roomId)
			{
				return reply.code(400).send({ success: false, error: 'Invalid payload' });
			}

			fastify.log.info({
			route: '/room-finished',
			body
			}, 'room-finished received');

			const room = roomManager.getRoom(body.roomId);
			
			if (room && body.winner && body.score) {
				const gameData = await callDatabase(`/games/room/${body.roomId}`);
				
				if (gameData.success && gameData.game)
				{
					try
					{
						const gameData = await callDatabase(`/games/room/${body.roomId}`);
						
						if (gameData.success && gameData.game)
						{
							const gameId = gameData.game.id;
							
							if (gameData.game.status === 'waiting')
							{
								await callDatabase(`/games/room/${body.roomId}/start`, 'PATCH');
								fastify.log.info('Game started before finishing');
							}
							
							const finishResult = await callDatabase(`/games/room/${body.roomId}/finish`, 'PATCH', {
								score_left: body.score.left,
								score_right: body.score.right,
								winner_id: body.winner.id,
								end_reason: body.reason
							});
							
							if (!finishResult.success)
							{
								fastify.log.error({ finishResult }, 'Failed to finish game in DB');
							}

							const isLeftWinner = body.winner.id === room.players[0].id;
							
							await callDatabase(`/users/${room.players[0].id}/stats`, 'PATCH', {
								won: isLeftWinner
							});
							
							await callDatabase(`/users/${room.players[1].id}/stats`, 'PATCH', {
								won: !isLeftWinner
							});
						}
					}
					catch (err)
					{
						fastify.log.error({ err }, 'Error updating game in database');
					}
				}
			}

			const deleted = roomManager.deleteRoom(body.roomId);
			return reply.send({ success: true, deleted });
		}
		catch (err)
		{
			fastify.log.error(err);
			return reply.code(500).send({ success: false, error: 'Internal server error' });
		}
	})
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/quickplayback/RoomManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Room, Player } from "./types";
import { v4 as uuidv4 } from 'uuid'

export class RoomManager
{
	private rooms: Map<string, Room> = new Map();
	private waitingRoom: Room | null = null

	public findOrCreateRoom(player: Player) : Room
	{
		// VÃ©rifier si le joueur est dÃ©jÃ  dans la waitingRoom
		if (this.waitingRoom && this.waitingRoom.players.some(p => p.id === player.id))
		{
			const existing = this.waitingRoom.players.find(p => p.id === player.id);
			if (existing)
			{
				existing.username = player.username;
				existing.selectedSkill = player.selectedSkill;
			}
			console.log(`Player ${player.username} (${player.id}) is already in waiting room ${this.waitingRoom.id}`)
			return this.waitingRoom
		}

		// VÃ©rifier si le joueur est dÃ©jÃ  dans une autre room active
		for (const [roomId, room] of this.rooms)
		{
			const existing = room.players.find(p => p.id === player.id);
			if (existing)
			{
				existing.username = player.username;
				existing.selectedSkill = player.selectedSkill;
				console.log(`Player ${player.username} (${player.id}) is already in room ${roomId}`)
				return room
			}
		}

		if (this.waitingRoom && this.waitingRoom.players.length === 1)
		{
			this.waitingRoom.players.push(player)
			player.roomId = this.waitingRoom.id

			const completedRoom = this.waitingRoom
			this.waitingRoom = null
			completedRoom.status = 'playing'

			this.rooms.set(completedRoom.id, completedRoom)

			console.log(`Room ${completedRoom.id} is complete with 2 players`)
			return completedRoom
		}

		const newRoom: Room = {
			id: uuidv4(),
			players: [player],
			status: 'waiting',
			createdAt: new Date()
		}

		player.roomId = newRoom.id
		this.rooms.set(newRoom.id, newRoom)
		this.waitingRoom = newRoom

		console.log(`Created new room ${newRoom.id}, waiting for a second player...`)
		return newRoom
	}

	public createTournamentRoom(
        roomId: string, 
        player1: Player, 
        player2: Player,
        tournamentId: string,
        matchId: string
    ): Room {
        const room: Room = {
            id: roomId,
            players: [
				{ ...player1, selectedSkill: player1.selectedSkill || 'smash' },
				{ ...player2, selectedSkill: player2.selectedSkill || 'smash' }
			],
            status: 'playing',
            createdAt: new Date(),
            isTournament: true,
            tournamentId,
            matchId
        };

        this.rooms.set(room.id, room);
        console.log(`Tournament room ${roomId} created for match ${matchId}`);
        return room;
    }

	public deleteRoom(roomId: string): boolean
	{
		const room = this.rooms.get(roomId);
		if (!room)
		{
			console.log(`deleteRoom: room ${roomId} not found`);
			if (this.waitingRoom?.id === roomId)
			{
				this.waitingRoom = null;
			}
			return false;
		}

		this.rooms.delete(roomId);

		if (this.waitingRoom?.id === roomId)
		{
			this.waitingRoom = null;
		}

		console.log(`Room ${roomId} deleted (room-finished received)`);
		this.debugRooms();
		return true;
	}

	public getRoom(roomId: string): Room | undefined
	{
		return (this.rooms.get(roomId))
	}

	public removePlayerFromRoom(player: Player): void
	{
		if (!player.roomId) return

		const room = this.rooms.get(player.roomId)
		if (!room) return

		room.players = room.players.filter(p => p.id !== player.id)
		console.log(`Player ${player.username} removed from the room`)

		if (room.players.length === 0 && room.status === 'waiting')
		{
			this.rooms.delete(room.id)
			if (this.waitingRoom?.id === room.id)
			{
				this.waitingRoom = null
			}
			console.log(`Room ${room.id} deleted (empty)`)
		}
		else if (room.players.length === 1)
		{
			const remainingPlayer = room.players[0]

			room.status = 'waiting'
			this.waitingRoom = room
			console.log(`Room ${room.id} waiting for a new player (one disconnected)`)
		}
	}

	public debugRooms(): void
	{
		console.log('=== Ã‰TAT DES ROOMS ===');
		console.log(`Rooms actives: ${this.rooms.size}`);
		console.log(`Room en attente: ${this.waitingRoom?.id || 'aucune'}`);
		this.rooms.forEach(room => {
			const playerNames = room.players.map(p => p.username).join(', ');
			console.log(`Room ${room.id}:`);
			console.log(`  - Joueurs (${room.players.length}): ${playerNames}`);
			console.log(`  - Status: ${room.status}`);
			console.log(`  - CrÃ©Ã©e il y a: ${Math.round((Date.now() - room.createdAt.getTime()) / 1000)}s`);
		});
		console.log('=====================');
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/database/connection.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import * as sqlite3 from 'sqlite3';
import * as path from 'path';
import * as fs from 'fs';

interface DatabaseInterface {
	connect(): Promise<void>;
	init(): Promise<void>;
	getDb(): sqlite3.Database;
}

class Database implements DatabaseInterface
{
	private db: sqlite3.Database | null = null;

	async connect(): Promise<void> 
	{
		const dbPath = path.join(__dirname, '../../data/transcendence.db');

		const dataDir = path.dirname(dbPath)
		if (!fs.existsSync(dataDir))
		{
			fs.mkdirSync(dataDir, {recursive: true})
		}

		return new Promise((resolve, reject) => {
			this.db = new sqlite3.Database(dbPath, (err: Error | null) => {
				if (err)
				{
					reject(err);
				}
				else
				{
					console.log('Connected to SQlite db');
					this.db!.run('PRAGMA foreign_keys = ON;', (pragmaErr) => {
						if (pragmaErr)
						{
							console.error('Failed to enable foreign keys:', pragmaErr);
							reject(pragmaErr);
						}
						else
						{
							console.log('Foreign key constraints enabled');
							resolve();
						}
					});
				}
			})
		})
	}

	async init(): Promise<void>
	{
		if (!this.db)
		{
			throw new Error('Db not connected.');
		}

		const schemaPath = path.join(__dirname, 'schema.sql')
		const schema = fs.readFileSync(schemaPath, 'utf8')

		return new Promise((resolve, reject) => {
			this.db!.exec(schema, (err: Error | null) => {
				if (err)
				{
					reject(err)
				}
				else
				{
					console.log('Db schema initialized')
					resolve()
				}
			})
		})
	}

	getDb(): sqlite3.Database {
		if (!this.db)
		{
			throw new Error('Db not connected.');
		}
		return this.db
	}
}

export default new Database;



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/server.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify, { FastifyInstance } from 'fastify'
import cors from '@fastify/cors'
import database from './database/connection'
import { registerUserRoutes } from './routes/users'
import { registerTournamentRoutes } from './routes/tournaments'
import { registerTournamentRegistrationRoutes } from './routes/tournament-registrations'
import { registerGameRoutes } from './routes/games'
import { registerGameStatsRoutes } from './routes/game-stats'
import { registerPowerUpRoutes } from './routes/power-ups'
import { registerSkillRoutes } from './routes/skills'
import { registerGoalRoutes } from './routes/goals'

const fastify: FastifyInstance = Fastify({
	logger: true
})

fastify.register(cors, {
	origin: true,
	credentials: true
})

declare module 'fastify'
{
	interface FastifyInstance
	{
		db: import('sqlite3').Database
	}
}

fastify.setErrorHandler((error, request, reply) => {
	fastify.log.error(error)
	reply.status(500).send({
		success: false,
		error: 'Internal server error'
	})
})

// Cache pour les stats globales
let statsCache: any = null;
let lastStatsFetch = 0;
const CACHE_DURATION = 5000; // 5 secondes

const start = async (): Promise<void> => {
	try
	{
		await database.connect()
		await database.init()

		// Adding db to fastify instance
		fastify.decorate('db', database.getDb())

		registerUserRoutes(fastify)
		registerTournamentRoutes(fastify)
		registerTournamentRegistrationRoutes(fastify)
		registerGameRoutes(fastify)
		registerGameStatsRoutes(fastify)
		registerPowerUpRoutes(fastify)
		registerSkillRoutes(fastify)
		registerGoalRoutes(fastify)

		// Route pour les statistiques globales
		fastify.get('/stats/global', async (request, reply) => {
			const now = Date.now();
			
			// Retourner le cache si toujours valide
			if (statsCache && (now - lastStatsFetch) < CACHE_DURATION) {
				return reply.send(statsCache);
			}

			return new Promise((resolve) => {
				fastify.db.get(
					`SELECT COUNT(*) as total_users FROM users`,
					[],
					(err, userCount: any) => {
						if (err) {
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
							return;
						}

						fastify.db.get(
							`SELECT COUNT(*) as active_games FROM games 
							 WHERE status = 'in_progress'`,
							[],
							(err2, gameCount: any) => {
								if (err2) {
									resolve(reply.status(500).send({
										success: false,
										error: err2.message
									}));
									return;
								}

								fastify.db.get(
									`SELECT COUNT(*) as online_players FROM users 
									 WHERE last_seen >= datetime('now', '-5 minutes')`,
									[],
									(err3, onlineCount: any) => {
										if (err3) {
											resolve(reply.status(500).send({
												success: false,
												error: err3.message
											}));
											return;
										}

										const result = {
											success: true,
											stats: {
												total_users: userCount.total_users,
												active_games: gameCount.active_games,
												online_players: onlineCount.online_players
											}
										};

										// Mettre en cache
										statsCache = result;
										lastStatsFetch = now;

										resolve(reply.send(result));
									}
								);
							}
						);
					}
				);
			});
		});

		await fastify.listen({
			port: 3020,
			host: '0.0.0.0'
		})
		console.log('Database API service running on port 3020')
	}
	catch (err)
	{
		fastify.log.error(err)
		process.exit(1)
	}
}

process.on('SIGINT', async () => {
	console.log('Shutting down database API service...')
	await fastify.close()
	process.exit()
})

start()

fastify.get('/health', async (request, reply) => {
	return {
		status: 'ok',
		timestamp: new Date().toISOString(),
		service: 'database'
	}
})



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/routes/goals.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { FastifyInstance } from 'fastify';

interface Goal {
	id: number;
	game_id: string;
	scorer_side: 'left' | 'right';
	scored_against_side: 'left' | 'right';
	ball_y_position: number;
	scored_at_game_time: number;
	scored_at: string;
}

export function registerGoalRoutes(fastify: FastifyInstance): void
{
	// CREATE - Enregistrer un goal
	fastify.post<{ Body: {
		game_id: string;
		scorer_side: 'left' | 'right';
		scored_against_side: 'left' | 'right';
		ball_y_position: number;
		scored_at_game_time: number;
	}}>(
		'/goals',
		async (request, reply) => {
			const {
				game_id,
				scorer_side,
				scored_against_side,
				ball_y_position,
				scored_at_game_time
			} = request.body;

			if (!game_id || !scorer_side || !scored_against_side || ball_y_position === undefined || scored_at_game_time === undefined)
			{
				return reply.status(400).send({
					success: false,
					error: 'Missing required fields'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`INSERT INTO goals_scored (
						game_id, scorer_side, scored_against_side, ball_y_position, scored_at_game_time
					) VALUES (?, ?, ?, ?, ?)`,
					[game_id, scorer_side, scored_against_side, ball_y_position, scored_at_game_time],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								id: this.lastID
							}));
						}
					}
				);
			});
		}
	);

	// READ - RÃ©cupÃ©rer tous les goals d'une partie
	fastify.get<{ Params: { gameId: string } }>(
		'/goals/game/:gameId',
		async (request, reply) => {
			const { gameId } = request.params;

			return new Promise((resolve) => {
				fastify.db.all(
					`SELECT * FROM goals_scored WHERE game_id = ? ORDER BY scored_at_game_time`,
					[gameId],
					(err, rows: Goal[]) => {
						if (err) {
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						} else {
							resolve(reply.send({
								success: true,
								goals: rows
							}));
						}
					}
				);
			});
		}
	);
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/routes/skills.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { FastifyInstance } from 'fastify';

interface SkillUsed {
	id?: number;
	game_id: string;
	player_id: string;
	skill_type: 'smash' | 'dash';
	activated_at_game_time: number;
	activated_at?: string;
	was_successful?: boolean;
}

export function registerSkillRoutes(fastify: FastifyInstance): void
{
	// CREATE - Enregistrer l'utilisation d'un skill
	fastify.post<{ Body: {
		game_id: string;
		player_id: string;
		skill_type: 'smash' | 'dash';
		activated_at_game_time: number;
		was_successful?: boolean;
	}}>(
		'/skills',
		async (request, reply) => {
			const { game_id, player_id, skill_type, activated_at_game_time, was_successful = true } = request.body;

			if (!game_id || !player_id || !skill_type || activated_at_game_time === undefined) {
				return reply.status(400).send({
					success: false,
					error: 'game_id, player_id, skill_type, and activated_at_game_time are required'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`INSERT INTO skills_used (
						game_id, player_id, skill_type, activated_at_game_time, was_successful
					) VALUES (?, ?, ?, ?, ?)`,
					[game_id, player_id, skill_type, activated_at_game_time, was_successful ? 1 : 0],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								skill_id: this.lastID
							}));
						}
					}
				);
			});
		}
	);

	// READ - Skills utilisÃ©s dans une partie
	fastify.get<{ Params: { gameId: string } }>(
		'/skills/game/:gameId',
		async (request, reply) => {
			const { gameId } = request.params;

			return new Promise((resolve) => {
				fastify.db.all(
					`SELECT s.*, u.username
					FROM skills_used s
					JOIN users u ON s.player_id = u.id
					WHERE s.game_id = ?
					ORDER BY s.activated_at_game_time ASC`,
					[gameId],
					(err, rows: SkillUsed[]) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								skills: rows
							}));
						}
					}
				);
			});
		}
	);

	// READ - Stats skills d'un joueur
	fastify.get<{ Params: { playerId: string } }>(
		'/skills/player/:playerId/stats',
		async (request, reply) => {
			const { playerId } = request.params;

			return new Promise((resolve) => {
				fastify.db.get(
					`SELECT 
						COUNT(CASE WHEN skill_type = 'smash' THEN 1 END) as total_smashes,
						SUM(CASE WHEN skill_type = 'smash' AND was_successful = 1 THEN 1 ELSE 0 END) as successful_smashes,
						ROUND(AVG(CASE WHEN skill_type = 'smash' AND was_successful = 1 THEN 1.0 ELSE 0.0 END) * 100, 2) as smash_success_rate,
						COUNT(CASE WHEN skill_type = 'dash' THEN 1 END) as total_dashes,
						SUM(CASE WHEN skill_type = 'dash' AND was_successful = 1 THEN 1 ELSE 0 END) as successful_dashes,
						ROUND(AVG(CASE WHEN skill_type = 'dash' AND was_successful = 1 THEN 1.0 ELSE 0.0 END) * 100, 2) as dash_success_rate
					FROM skills_used
					WHERE player_id = ?`,
					[playerId],
					(err, row) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								skill_stats: row
							}));
						}
					}
				);
			});
		}
	);
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/routes/users.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { FastifyInstance } from 'fastify';
import type { Database } from 'sqlite3';

interface User {
	id: string;
	username: string;
	created_at?: string;
	last_seen?: string;
	total_games?: number;
	total_wins?: number;
	total_losses?: number;
}

export function registerUserRoutes(fastify: FastifyInstance): void
{
	// CREATE - CrÃ©er un nouvel utilisateur
	fastify.post<{ Body: { id: string; username: string } }>(
		'/users',
		async (request, reply) => {
			const { id, username } = request.body;

			if (!id || !username)
			{
				return reply.status(400).send({
					success: false,
					error: 'id and username are required'
				});
			}

			return new Promise((resolve, reject) => {
				fastify.db.run(
					`INSERT INTO users (id, username) VALUES (?, ?)`,
					[id, username],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								user: { id, username }
							}));
						}
					}
				);
			});
		}
	);

	// READ - RÃ©cupÃ©rer un utilisateur par ID
	fastify.get<{ Params: { id: string } }>(
		'/users/:id',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve, reject) => {
				fastify.db.get(
					`SELECT * FROM users WHERE id = ?`,
					[id],
					(err, row: User) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (!row)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'User not found'
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								user: row
							}));
						}
					}
				);
			});
		}
	);

	// READ - RÃ©cupÃ©rer un utilisateur par username
	fastify.get<{ Querystring: { username: string } }>(
		'/users',
		async (request, reply) => {
			const { username } = request.query;

			if (!username)
			{
				return new Promise((resolve) => {
					fastify.db.all(
						`SELECT * FROM users ORDER BY created_at DESC LIMIT 100`,
						[],
						(err, rows: User[]) => {
							if (err)
							{
								resolve(reply.status(500).send({
									success: false,
									error: err.message
								}));
							}
							else
							{
								resolve(reply.send({
									success: true,
									users: rows
								}));
							}
						}
					);
				});
			}

			return new Promise((resolve) => {
				fastify.db.get(
					`SELECT * FROM users WHERE username = ?`,
					[username],
					(err, row: User) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (!row)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'User not found'
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								user: row
							}));
						}
					}
				);
			});
		}
	);

	// UPDATE - Mettre Ã  jour last_seen
	fastify.patch<{ Params: { id: string } }>(
		'/users/:id/last-seen',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve) => {
				fastify.db.run(
					`UPDATE users SET last_seen = CURRENT_TIMESTAMP WHERE id = ?`,
					[id],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'User not found'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

	// UPDATE - IncrÃ©menter les statistiques
	fastify.patch<{ 
		Params: { id: string };
		Body: { won: boolean }
	}>(
		'/users/:id/stats',
		async (request, reply) => {
			const { id } = request.params;
			const { won } = request.body;

			const winField = won ? 'total_wins = total_wins + 1,' : '';
			const lossField = !won ? 'total_losses = total_losses + 1,' : '';

			return new Promise((resolve) => {
				fastify.db.run(
					`UPDATE users SET 
						total_games = total_games + 1,
						${winField}
						${lossField}
						last_seen = CURRENT_TIMESTAMP
					WHERE id = ?`,
					[id],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'User not found'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

	// READ - Leaderboard
	fastify.get('/users/leaderboard', async (request, reply) => {
		return new Promise((resolve) => {
			fastify.db.all(
				`SELECT 
					id, username, total_games, total_wins, total_losses,
					ROUND(CAST(total_wins AS FLOAT) / NULLIF(total_games, 0) * 100, 2) as win_rate
				FROM users
				WHERE total_games > 0
				ORDER BY total_wins DESC, win_rate DESC
				LIMIT 50`,
				[],
				(err, rows: User[]) => {
					if (err)
					{
						resolve(reply.status(500).send({
							success: false,
							error: err.message
						}));
					}
					else
					{
						resolve(reply.send({
							success: true,
							leaderboard: rows
						}));
					}
				}
			);
		});
	});

	// DELETE - Supprimer un utilisateur (pour les tests uniquement)
	fastify.delete<{ Params: { id: string } }>(
		'/users/:id',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve) => {
				fastify.db.run(
					`DELETE FROM users WHERE id = ?`,
					[id],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'User not found'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/routes/tournaments.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { FastifyInstance } from 'fastify';

interface Tournament {
	id: string;
	name: string;
	max_players: number;
	status: 'registration' | 'in_progress' | 'finished';
	winner_id?: string;
	created_at?: string;
	started_at?: string;
	finished_at?: string;
	current_round?: number;
}

export function registerTournamentRoutes(fastify: FastifyInstance): void
{
	// CREATE - CrÃ©er un tournoi
	fastify.post<{ Body: {
		id: string;
		name: string;
		max_players: number;
	}}>(
		'/tournaments',
		async (request, reply) => {
			const { id, name, max_players } = request.body;

			if (!id || !name || !max_players)
			{
				return reply.status(400).send({
					success: false,
					error: 'id, name, and max_players are required'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`INSERT INTO tournaments (id, name, max_players, status)
					VALUES (?, ?, ?, 'registration')`,
					[id, name, max_players],
					function(err) {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								tournament: { id, name, max_players, status: 'registration' }
							}));
						}
					}
				);
			});
		}
	);

	// READ - RÃ©cupÃ©rer un tournoi
	fastify.get<{ Params: { id: string } }>(
		'/tournaments/:id',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve) => {
				fastify.db.get(
					`SELECT * FROM tournaments WHERE id = ?`,
					[id],
					(err, row: Tournament) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (!row)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'Tournament not found'
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								tournament: row
							}));
						}
					}
				);
			});
		}
	);

	// READ - Liste des tournois actifs
	fastify.get('/tournaments', async (request, reply) => {
		return new Promise((resolve) => {
			fastify.db.all(
				`SELECT * FROM tournaments 
				WHERE status IN ('registration', 'in_progress')
				ORDER BY created_at DESC`,
				[],
				(err, rows: Tournament[]) => {
					if (err)
					{
						resolve(reply.status(500).send({
							success: false,
							error: err.message
						}));
					}
					else
					{
						resolve(reply.send({
							success: true,
							tournaments: rows
						}));
					}
				}
			);
		});
	});

	// UPDATE - DÃ©marrer un tournoi
	fastify.patch<{ Params: { id: string } }>(
		'/tournaments/:id/start',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve) => {
				fastify.db.run(
					`UPDATE tournaments SET 
						status = 'in_progress',
						started_at = CURRENT_TIMESTAMP,
						current_round = 1
					WHERE id = ? AND status = 'registration'`,
					[id],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(400).send({
								success: false,
								error: 'Tournament not found or already started'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

	// UPDATE - Terminer un tournoi
	fastify.patch<{ 
		Params: { id: string };
		Body: { winner_id: string }
	}>(
		'/tournaments/:id/finish',
		async (request, reply) => {
			const { id } = request.params;
			const { winner_id } = request.body;

			if (!winner_id)
			{
				return reply.status(400).send({
					success: false,
					error: 'winner_id is required'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`UPDATE tournaments SET 
						status = 'finished',
						finished_at = CURRENT_TIMESTAMP,
						winner_id = ?
					WHERE id = ? AND status = 'in_progress'`,
					[winner_id, id],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(400).send({
								success: false,
								error: 'Tournament not found or not in progress'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

	// UPDATE - Avancer au round suivant
	fastify.patch<{ Params: { id: string } }>(
		'/tournaments/:id/next-round',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve) => {
				fastify.db.run(
					`UPDATE tournaments SET 
						current_round = current_round + 1
					WHERE id = ? AND status = 'in_progress'`,
					[id],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(400).send({
								success: false,
								error: 'Tournament not found or not in progress'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

	// DELETE - Supprimer un tournoi (pour les tests uniquement)
	fastify.delete<{ Params: { id: string } }>(
		'/tournaments/:id',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve) => {
				fastify.db.run(
					`DELETE FROM tournaments WHERE id = ?`,
					[id],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'Tournament not found'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/routes/game-stats.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { FastifyInstance } from 'fastify';

interface GameStat {
	id?: number;
	game_id: string;
	player_id: string;
	side: 'left' | 'right';
	paddle_hits?: number;
	max_ball_speed?: number;
	power_ups_collected?: number;
	skills_used?: number;
	time_disconnected_ms?: number;
}

export function registerGameStatsRoutes(fastify: FastifyInstance): void
{
	// CREATE - Enregistrer les stats d'une partie
	fastify.post<{ Body: GameStat }>(
		'/game-stats',
		async (request, reply) => {
			const {
				game_id,
				player_id,
				side,
				paddle_hits = 0,
				skills_used = 0,
				max_ball_speed = 0,
				power_ups_collected = 0,
				time_disconnected_ms = 0
			} = request.body;

			if (!game_id || !player_id || !side)
			{
				return reply.status(400).send({
					success: false,
					error: 'game_id, player_id, and side are required'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`INSERT INTO game_stats (
						game_id, player_id, side, paddle_hits, skills_used,
						max_ball_speed, power_ups_collected, time_disconnected_ms
					) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
					[
						game_id, player_id, side, paddle_hits, skills_used,
						max_ball_speed, power_ups_collected, time_disconnected_ms
					],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								stat_id: this.lastID
							}));
						}
					}
				);
			});
		}
	);

	// READ - Stats d'une partie
	fastify.get<{ Params: { gameId: string } }>(
		'/game-stats/game/:gameId',
		async (request, reply) => {
			const { gameId } = request.params;

			return new Promise((resolve) => {
				fastify.db.all(
					`SELECT gs.*, u.username
					FROM game_stats gs
					JOIN users u ON gs.player_id = u.id
					WHERE gs.game_id = ?`,
					[gameId],
					(err, rows: GameStat[]) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								stats: rows
							}));
						}
					}
				);
			});
		}
	);

	// READ - Stats d'un joueur (agrÃ©gÃ©es)
	fastify.get<{ Params: { playerId: string } }>(
		'/game-stats/player/:playerId/aggregate',
		async (request, reply) => {
			const { playerId } = request.params;

			return new Promise((resolve) => {
				fastify.db.get(
					`SELECT 
						COUNT(*) as total_games,
						SUM(paddle_hits) as total_paddle_hits,
						SUM(skills_used) as total_skills,
						MAX(max_ball_speed) as highest_ball_speed,
						SUM(power_ups_collected) as total_power_ups,
						AVG(paddle_hits) as avg_paddle_hits,
						AVG(skills_used) as avg_skills
					FROM game_stats
					WHERE player_id = ?`,
					[playerId],
					(err, row) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								aggregate_stats: row
							}));
						}
					}
				);
			});
		}
	);
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/routes/power-ups.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { FastifyInstance } from 'fastify';

interface PowerUpUsed {
	id?: number;
	game_id: string;
	player_id: string;
	power_up_type: 'split' | 'blackout' | 'blackhole';
	collected_at_game_time?: number;
	activated_at_game_time: number;
	activated_at?: string;
}

export function registerPowerUpRoutes(fastify: FastifyInstance): void
{
	// CREATE - Enregistrer l'utilisation d'un power-up
	fastify.post<{ Body: {
		game_id: string;
		player_id: string;
		power_up_type: 'split' | 'blackout' | 'blackhole';
		collected_at_game_time?: number;
		activated_at_game_time: number;
	}}>(
		'/power-ups',
		async (request, reply) => {
			const { game_id, player_id, power_up_type, collected_at_game_time, activated_at_game_time } = request.body;

			if (!game_id || !player_id || !power_up_type || activated_at_game_time === undefined) {
				return reply.status(400).send({
					success: false,
					error: 'All fields are required'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`INSERT INTO power_ups_used (
						game_id, player_id, power_up_type, collected_at_game_time, activated_at_game_time
					) VALUES (?, ?, ?, ?, ?)`,
					[game_id, player_id, power_up_type, collected_at_game_time || null, activated_at_game_time],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								powerup_id: this.lastID
							}));
						}
					}
				);
			});
		}
	);

	// READ - Power-ups d'une partie
	fastify.get<{ Params: { gameId: string } }>(
		'/power-ups/game/:gameId',
		async (request, reply) => {
			const { gameId } = request.params;

			return new Promise((resolve) => {
				fastify.db.all(
					`SELECT pu.*, u.username
					FROM power_ups_used pu
					JOIN users u ON pu.player_id = u.id
					WHERE pu.game_id = ?
					ORDER BY pu.activated_at_game_time ASC`,
					[gameId],
					(err, rows: PowerUpUsed[]) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								power_ups: rows
							}));
						}
					}
				);
			});
		}
	);

	// READ - Stats power-ups d'un joueur
	fastify.get<{ Params: { playerId: string } }>(
		'/power-ups/player/:playerId/stats',
		async (request, reply) => {
			const { playerId } = request.params;

			return new Promise((resolve) => {
				fastify.db.all(
					`SELECT 
						power_up_type,
						COUNT(*) as times_used
					FROM power_ups_used
					WHERE player_id = ?
					GROUP BY power_up_type`,
					[playerId],
					(err, rows) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								powerup_stats: rows
							}));
						}
					}
				);
			});
		}
	);
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/routes/tournament-registrations.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { FastifyInstance } from 'fastify';

interface Registration {
	id: number;
	tournament_id: string;
	player_id: string;
	registered_at?: string;
	is_eliminated?: boolean;
	final_position?: number;
}

export function registerTournamentRegistrationRoutes(fastify: FastifyInstance): void {
	// CREATE - Inscrire un joueur
	fastify.post<{ Body: {
		tournament_id: string;
		player_id: string;
	}}>(
		'/tournament-registrations',
		async (request, reply) => {
			const { tournament_id, player_id } = request.body;

			if (!tournament_id || !player_id)
			{
				return reply.status(400).send({
					success: false,
					error: 'tournament_id and player_id are required'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`INSERT INTO tournament_registrations (tournament_id, player_id)
					VALUES (?, ?)`,
					[tournament_id, player_id],
					function(err)
					{
						if (err)
						{
							if (err.message.includes('UNIQUE constraint failed'))
							{
								resolve(reply.status(409).send({
									success: false,
									error: 'Player already registered'
								}));
							}
							else
							{
								resolve(reply.status(500).send({
									success: false,
									error: err.message
								}));
							}
						}
						else
						{
							resolve(reply.send({
								success: true,
								registration_id: this.lastID
							}));
						}
					}
				);
			});
		}
	);

	// READ - Joueurs d'un tournoi
	fastify.get<{ Params: { tournamentId: string } }>(
		'/tournament-registrations/tournament/:tournamentId',
		async (request, reply) => {
			const { tournamentId } = request.params;

			return new Promise((resolve) => {
				fastify.db.all(
					`SELECT tr.*, u.username
					FROM tournament_registrations tr
					JOIN users u ON tr.player_id = u.id
					WHERE tr.tournament_id = ?
					ORDER BY tr.registered_at ASC`,
					[tournamentId],
					(err, rows: Registration[]) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								registrations: rows
							}));
						}
					}
				);
			});
		}
	);

	// UPDATE - Ã‰liminer un joueur
	fastify.patch<{ 
		Params: { tournamentId: string; playerId: string };
		Body: { final_position?: number }
	}>(
		'/tournament-registrations/tournament/:tournamentId/player/:playerId/eliminate',
		async (request, reply) => {
			const { tournamentId, playerId } = request.params;
			const { final_position } = request.body;

			return new Promise((resolve) => {
				fastify.db.run(
					`UPDATE tournament_registrations SET 
						is_eliminated = 1,
						final_position = ?
					WHERE tournament_id = ? AND player_id = ?`,
					[final_position || null, tournamentId, playerId],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'Registration not found'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

	// DELETE - DÃ©sinscrire un joueur (avant le dÃ©but)
	fastify.delete<{ Params: { tournamentId: string; playerId: string } }>(
		'/tournament-registrations/tournament/:tournamentId/player/:playerId',
		async (request, reply) => {
			const { tournamentId, playerId } = request.params;

			return new Promise((resolve) => {
				fastify.db.run(
					`DELETE FROM tournament_registrations
					WHERE tournament_id = ? AND player_id = ?
					AND tournament_id IN (
						SELECT id FROM tournaments WHERE status = 'registration'
					)`,
					[tournamentId, playerId],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(400).send({
								success: false,
								error: 'Cannot unregister: tournament started or not found'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/database/src/routes/games.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { FastifyInstance } from 'fastify';

interface Game {
	id: string;
	room_id: string;
	game_type: 'quickplay' | 'tournament';
	is_3d?: boolean;
	tournament_id?: string;
	tournament_round?: number;
	match_position?: number;
	player_left_id: string;
	player_right_id: string;
	score_left?: number;
	score_right?: number;
	winner_id?: string;
	status: 'waiting' | 'in_progress' | 'finished' | 'abandoned';
	end_reason?: 'score' | 'timeout' | 'forfeit';
	created_at?: string;
	started_at?: string;
	finished_at?: string;
	duration_seconds?: number;
}

export function registerGameRoutes(fastify: FastifyInstance): void
{
	// CREATE - CrÃ©er une partie
	fastify.post<{ Body: {
		id: string;
		room_id: string;
		game_type: 'quickplay' | 'tournament';
		is_3d?: boolean;
		player_left_id: string;
		player_right_id: string;
		tournament_id?: string;
		tournament_round?: number;
		match_position?: number;
	}}>(
		'/games',
		async (request, reply) => {
			const {
				id,
				room_id,
				game_type,
				is_3d,
				player_left_id,
				player_right_id,
				tournament_id,
				tournament_round,
				match_position
			} = request.body;

			if (!id || !room_id || !game_type || !player_left_id || !player_right_id)
			{
				return reply.status(400).send({
					success: false,
					error: 'Missing required fields'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`INSERT INTO games (
						id, room_id, game_type, is_3d, player_left_id, player_right_id,
						tournament_id, tournament_round, match_position, status
					) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'waiting')`,
					[
						id, room_id, game_type, is_3d ? 1 : 0, player_left_id, player_right_id,
						tournament_id || null, tournament_round || null, match_position || null
					],
					function(err)
					{
						if (err)
						{
							fastify.log.error({ 
								err, 
								game_data: { id, room_id, game_type, player_left_id, player_right_id }
							}, 'Failed to create game in database');
							
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else
						{
							resolve(reply.send({
								success: true,
								game: { id, room_id, status: 'waiting' }
							}));
						}
					}
				);
			});
		}
	);

	// READ - RÃ©cupÃ©rer une partie par room_id
	fastify.get<{ Params: { roomId: string } }>(
		'/games/room/:roomId',
		async (request, reply) => {
			const { roomId } = request.params;

			return new Promise((resolve) => {
				fastify.db.get(
					`SELECT g.*,
						u1.username as player_left_username,
						u2.username as player_right_username,
						u3.username as winner_username
					FROM games g
					LEFT JOIN users u1 ON g.player_left_id = u1.id
					LEFT JOIN users u2 ON g.player_right_id = u2.id
					LEFT JOIN users u3 ON g.winner_id = u3.id
					WHERE g.room_id = ?`,
					[roomId],
					(err, row: Game) => {
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (!row)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'Game not found'
							}));
						}
						else
						{
							// Log warning if usernames are missing (indicates missing users)
							if (!row.player_left_username || !row.player_right_username)
							{
								console.warn(`Game ${roomId}: Missing player usernames. Left: ${row.player_left_username}, Right: ${row.player_right_username}, Player IDs: ${(row as any).player_left_id}, ${(row as any).player_right_id}`);
							}
							
							resolve(reply.send({
								success: true,
								game: row
							}));
						}
					}
				);
			});
		}
	);

	// UPDATE - DÃ©marrer une partie
	fastify.patch<{ Params: { roomId: string } }>(
		'/games/room/:roomId/start',
		async (request, reply) => {
			const { roomId } = request.params;

			return new Promise((resolve) => {
				fastify.db.run(
					`UPDATE games SET 
						status = 'in_progress',
						started_at = CURRENT_TIMESTAMP
					WHERE room_id = ? AND status = 'waiting'`,
					[roomId],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(400).send({
								success: false,
								error: 'Game not found or already started'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

	// UPDATE - Terminer une partie
	fastify.patch<{ 
		Params: { roomId: string };
		Body: {
			score_left: number;
			score_right: number;
			winner_id: string;
			end_reason: 'score' | 'timeout' | 'forfeit';
		}
	}>(
		'/games/room/:roomId/finish',
		async (request, reply) => {
			const { roomId } = request.params;
			const { score_left, score_right, winner_id, end_reason } = request.body;

			if (score_left === undefined || score_right === undefined || !winner_id || !end_reason)
			{
				return reply.status(400).send({
					success: false,
					error: 'Missing required fields'
				});
			}

			return new Promise((resolve) => {
				fastify.db.run(
					`UPDATE games SET 
						status = 'finished',
						score_left = ?,
						score_right = ?,
						winner_id = ?,
						end_reason = ?,
						finished_at = CURRENT_TIMESTAMP,
						duration_seconds = (
							CAST((julianday(CURRENT_TIMESTAMP) - julianday(created_at)) * 86400 AS INTEGER)
						)
					WHERE room_id = ? AND (status = 'in_progress' OR status = 'waiting')`,
					[score_left, score_right, winner_id, end_reason, roomId],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(400).send({
								success: false,
								error: 'Game not found or not in progress'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

	// READ - Historique global de tous les joueurs
	fastify.get(
		'/games/history',
		async (request, reply) => {
			return new Promise((resolve) => {
				fastify.db.all(
					`SELECT g.*,
						u1.username as player_left_username,
						u2.username as player_right_username,
						u3.username as winner_username
					FROM games g
					JOIN users u1 ON g.player_left_id = u1.id
					JOIN users u2 ON g.player_right_id = u2.id
					LEFT JOIN users u3 ON g.winner_id = u3.id
					WHERE g.status = 'finished'
					ORDER BY g.created_at DESC
					LIMIT 100`,
					[],
					(err, rows: Game[]) => {
						if (err) {
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						} else {
							resolve(reply.send({
								success: true,
								games: rows
							}));
						}
					}
				);
			});
		}
	);

	// READ - Historique d'un joueur
	fastify.get<{ Params: { playerId: string } }>(
		'/games/player/:playerId/history',
		async (request, reply) => {
			const { playerId } = request.params;

			return new Promise((resolve) => {
				fastify.db.all(
					`SELECT g.*,
						u1.username as player_left_username,
						u2.username as player_right_username,
						CASE 
							WHEN g.winner_id = ? THEN 'won'
							WHEN g.winner_id IS NOT NULL THEN 'lost'
							ELSE 'ongoing'
						END as result
					FROM games g
					JOIN users u1 ON g.player_left_id = u1.id
					JOIN users u2 ON g.player_right_id = u2.id
					WHERE g.player_left_id = ? OR g.player_right_id = ?
					ORDER BY g.created_at DESC
					LIMIT 50`,
					[playerId, playerId, playerId],
					(err, rows: Game[]) => {
						if (err) {
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						} else {
							resolve(reply.send({
								success: true,
								games: rows
							}));
						}
					}
				);
			});
		}
	);

	// READ - RÃ©cupÃ©rer les dÃ©tails complets d'une partie par son ID
	fastify.get<{ Params: { id: string } }>(
		'/games/:id',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve) => {
				fastify.db.get(
					`SELECT g.*,
						u1.username as player_left_username,
						u2.username as player_right_username,
						u3.username as winner_username
					FROM games g
					JOIN users u1 ON g.player_left_id = u1.id
					JOIN users u2 ON g.player_right_id = u2.id
					LEFT JOIN users u3 ON g.winner_id = u3.id
					WHERE g.id = ?`,
					[id],
					(err, game: any) => {
						if (err) {
							return resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						if (!game) {
							return resolve(reply.status(404).send({
								success: false,
								error: 'Game not found'
							}));
						}

						fastify.db.all(
							`SELECT gs.*, u.username
							FROM game_stats gs
							JOIN users u ON gs.player_id = u.id
							WHERE gs.game_id = ?`,
							[id],
							(err, stats: any[]) => {
								if (err) {
									return resolve(reply.status(500).send({
										success: false,
										error: err.message
									}));
								}

								fastify.db.all(
									`SELECT su.*, u.username
									FROM skills_used su
									JOIN users u ON su.player_id = u.id
									WHERE su.game_id = ?
									ORDER BY su.activated_at_game_time`,
									[id],
									(err, skills: any[]) => {
										if (err) {
											return resolve(reply.status(500).send({
												success: false,
												error: err.message
											}));
										}

										fastify.db.all(
											`SELECT pu.*, u.username
											FROM power_ups_used pu
											JOIN users u ON pu.player_id = u.id
											WHERE pu.game_id = ?
											ORDER BY pu.activated_at_game_time`,
											[id],
											(err, powerUps: any[]) => {
												if (err) {
													return resolve(reply.status(500).send({
														success: false,
														error: err.message
													}));
												}

												fastify.db.all(
													`SELECT * FROM goals_scored
													WHERE game_id = ?
													ORDER BY scored_at_game_time`,
													[id],
													(err, goals: any[]) => {
														if (err) {
															return resolve(reply.status(500).send({
																success: false,
																error: err.message
															}));
														}

														resolve(reply.send({
															success: true,
															game: {
																...game,
																stats,
																skills,
																powerUps,
																goals
															}
														}));
													}
												);
											}
										);
									}
								);
							}
						);
					}
				);
			});
		}
	);

	// DELETE - Supprimer une partie (pour les tests uniquement)
	fastify.delete<{ Params: { id: string } }>(
		'/games/:id/delete',
		async (request, reply) => {
			const { id } = request.params;

			return new Promise((resolve) => {
				fastify.db.run(
					`DELETE FROM games WHERE id = ?`,
					[id],
					function(err)
					{
						if (err)
						{
							resolve(reply.status(500).send({
								success: false,
								error: err.message
							}));
						}
						else if (this.changes === 0)
						{
							resolve(reply.status(404).send({
								success: false,
								error: 'Game not found'
							}));
						}
						else
						{
							resolve(reply.send({ success: true }));
						}
					}
				);
			});
		}
	);

}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/vite.config.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
	server: {
		host: '0.0.0.0',
		port: 5173,
		allowedHosts: true
	},
	plugins: [
		tailwindcss(),
	],
})



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/simpleAuth/SimpleAuth.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { v4 as uuidv4 } from 'uuid'

class CookieManager {
    static setCookie(name: string, value: string | null, days: number = 7): void
	{
        const expires = new Date();
        expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Strict`;
    }

    static getCookie(name: string): string | null
	{
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++)
		{
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }

    static deleteCookie(name: string): void
	{
        document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
    }
}

export class SimpleAuth
{
    private static readonly COOKIE_NAME = 'player_session';
    private static readonly USERNAME_KEY = 'player_username';
    private playerId: string | null;
    private username: string = 'Anon';

    constructor()
	{
        this.playerId = this.getOrCreatePlayerId();
        this.username = localStorage.getItem(SimpleAuth.USERNAME_KEY) || 'Anon';
    }

    setUsername(username: string): void {
        this.username = username;
        localStorage.setItem(SimpleAuth.USERNAME_KEY, username);
    }

    private getOrCreatePlayerId(): string | null
	{
        let playerId = CookieManager.getCookie(SimpleAuth.COOKIE_NAME);
        
        if (!playerId)
		{
            playerId = uuidv4();
            CookieManager.setCookie(SimpleAuth.COOKIE_NAME, playerId, 30);
            console.log('New player ID created:', playerId);
        }
		else
		{
            console.log('Existing player ID found:', playerId);
        }
        
        return playerId;
    }

    getPlayerId(): string | null
	{
        return this.playerId;
    }

    getUsername(): string {
        return (this.username);
    }

    renewSession(): void
	{
        CookieManager.setCookie(SimpleAuth.COOKIE_NAME, this.playerId, 30);
    }

    logout(): void
	{
        CookieManager.deleteCookie(SimpleAuth.COOKIE_NAME);
        this.playerId = uuidv4();
        CookieManager.setCookie(SimpleAuth.COOKIE_NAME, this.playerId, 30);
    }
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/PongGame/PongGame.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Component } from "../types";
import { WSClient, type PublicState } from "../../net/wsClient";
import type { TimeoutStatus } from "./types";
import { PongRenderer } from "./PongRenderer";
import { PongInputHandler } from "./PongInput";
import { PongParticleSystem } from "./PongParticles";
import { PongAssets } from "./PongAssets";
import { WORLD_HEIGHT, WORLD_WIDTH } from "./constants";
import { DebugPanel, type DebugPanelCallbacks } from "../DebugPanel";
import { PongAI } from "./PongAI";
import { LocalTournamentManager } from "../../utils/localTournamentManager";

type LocalGameConfig = {
	roomId: string;
	left: { id: string; username: string; selectedSkill?: 'smash' | 'dash' };
	right: { id: string; username: string; selectedSkill?: 'smash' | 'dash' };
};

class GameStatsMonitor {
	private fpsFrames: number[] = [];
	private lastFrameTime: number = performance.now();
	private pingTimes: number[] = [];
	private currentFPS: number = 0;
	
	recordFrame(): void {
		const now = performance.now();
		const delta = now - this.lastFrameTime;
		this.lastFrameTime = now;
		
		if (delta > 0) {
			const fps = 1000 / delta;
			this.fpsFrames.push(fps);
			
			if (this.fpsFrames.length > 60) {
				this.fpsFrames.shift();
			}
			
			const avgFps = this.fpsFrames.reduce((a, b) => a + b, 0) / this.fpsFrames.length;
			this.currentFPS = Math.round(avgFps);
		}
	}
	
	getCurrentFPS(): number {
		return this.currentFPS;
	}
	
	addPing(ping: number): void {
		this.pingTimes.push(ping);
		if (this.pingTimes.length > 10) {
			this.pingTimes.shift();
		}
	}
	
	getAveragePing(): number {
		if (this.pingTimes.length === 0) return 0;
		const avg = this.pingTimes.reduce((a, b) => a + b, 0) / this.pingTimes.length;
		return Math.round(avg);
	}
}

export class PongGame implements Component {
	private el: HTMLElement;
	private canvas: HTMLCanvasElement;

	private net: WSClient;
	private secondaryNet?: WSClient;
	private renderer: PongRenderer;
	private input: PongInputHandler;
	private particles: PongParticleSystem;
	private assets: PongAssets;
	private debugPanel?: DebugPanel;
	private debugContainer?: HTMLDivElement;
	private isLocalMode = false;
	private localConfig?: LocalGameConfig;
	private leftController?: WSClient;
	private rightController?: WSClient;
	private aiNet?: WSClient;
	private statsMonitor: GameStatsMonitor;
	private lastPingTime: number = 0;
	private statsUpdateInterval: number | null = null;
    private aiControllers: { left?: PongAI; right?: PongAI } = {};

	private state: PublicState = {
		leftPaddle: {y: WORLD_HEIGHT / 2, speed: 0, intention: 0},
		rightPaddle: {y: WORLD_HEIGHT / 2, speed: 0, intention: 0},
		balls: [],
		score: {left: 0, right: 0},
		isPaused: true,
		isGameOver: false,
		winner: '',
		countdownValue: 0,
		powerUps: [],
		splitActive: false,
		clock: 0,
		blackoutLeft: false,
		blackoutRight: false,
		blackoutLeftIntensity: 0,
		blackoutRightIntensity: 0,
		blackholeActive: false,
		blackholeCenterX: 0,
		blackholeCenterY: 0,
		blackholeProgress: 0,
		selectedSkills: {
			left: 'smash',
			right: 'smash'
		},
		skillStates: {
			left: {cooldownRemaining: 0, lastActivationAt: -1e9},
			right: {cooldownRemaining: 0, lastActivationAt: -1e9}
		}
	};

	private timeoutStatus: TimeoutStatus = {
		leftActive: false,
		leftRemainingMs: 0,
		rightActive: false,
		rightRemainingMs: 0
	};

	private animationFrameId: number | null = null;
	private lastScore = { left: 0, right: 0 };
	private lastBallPositions: Array<{x: number; y: number; vx: number; vy: number}> = [];
	private isDebugMode: boolean = false;
	private gameOverHandled: boolean = false;

	constructor(element: HTMLElement) {
		this.el = element;

		const canvas = this.el.querySelector('#pong-canvas') as HTMLCanvasElement | null;
		if (!canvas)
		{
			throw new Error('PongGame: canvas not found in the component.');
		}
		this.canvas = canvas;

		this.net = new WSClient();
		this.localConfig = this.loadLocalConfig();
		if (this.localConfig) {
			this.secondaryNet = new WSClient();
			this.isLocalMode = true;
		}

		this.renderer = new PongRenderer(this.canvas, this.net);
		this.particles = new PongParticleSystem();
		this.assets = new PongAssets();
		this.input = new PongInputHandler(this.net, this.secondaryNet);
		this.statsMonitor = new GameStatsMonitor();

		this.setupNetworkHandlers();
		if (this.secondaryNet) {
			this.setupSecondaryNetworkHandlers();
		}
		this.setupEventHandlers();
		this.connectToServer();
		this.startAnimationLoop();
        this.startStatsMonitoring();

		this.setupAIHooks();
	}

	private startStatsMonitoring(): void {
		// Mettre Ã  jour l'affichage des stats toutes les 500ms
		this.statsUpdateInterval = setInterval(() => {
			this.updateStatsDisplay();
		}, 500) as unknown as number;
		
		// Envoyer des pings toutes les 2 secondes
		this.pingInterval = setInterval(() => {
			this.sendPing();
		}, 2000) as unknown as number;
	}
	
	private sendPing(): void {
		this.lastPingTime = performance.now();
		this.net.sendPing();
	}
	
	private updateStatsDisplay(): void {
		// FPS
		const fps = this.statsMonitor.getCurrentFPS();
		const fpsElement = document.getElementById('fps-value');
		if (fpsElement) {
			fpsElement.textContent = fps.toString();
			fpsElement.className = fps >= 55 ? 'stat-good' : fps >= 30 ? 'stat-medium' : 'stat-bad';
		}
		
		// Ping
		const ping = this.statsMonitor.getAveragePing();
		const pingElement = document.getElementById('ping-value');
		if (pingElement) {
			pingElement.textContent = ping > 0 ? `${ping}ms` : '--ms';
			pingElement.className = ping < 50 ? 'stat-good' : ping < 100 ? 'stat-medium' : 'stat-bad';
		}
		
		// Connection status
		const wsState = this.net['ws']?.readyState;
		const statusElement = document.getElementById('connection-status');
		const wsIndicator = document.getElementById('ws-indicator');
		const connectionIndicator = document.getElementById('connection-indicator');
		
		if (statusElement && wsIndicator && connectionIndicator) {
			if (wsState === WebSocket.OPEN) {
				statusElement.textContent = 'CONNECTION: STABLE';
				wsIndicator.className = 'w-2 h-2 bg-green-400 rounded-full animate-pulse';
				connectionIndicator.className = 'status-indicator w-3 h-3 bg-green-400 rounded-full';
			} else if (wsState === WebSocket.CONNECTING) {
				statusElement.textContent = 'CONNECTION: CONNECTING...';
				wsIndicator.className = 'w-2 h-2 bg-yellow-400 rounded-full animate-pulse';
				connectionIndicator.className = 'status-indicator w-3 h-3 bg-yellow-400 rounded-full';
			} else {
				statusElement.textContent = 'CONNECTION: DISCONNECTED';
				wsIndicator.className = 'w-2 h-2 bg-red-400 rounded-full animate-pulse';
				connectionIndicator.className = 'status-indicator w-3 h-3 bg-red-400 rounded-full';
			}
		}
	}

	private setupNetworkHandlers(): void {
		this.net.onState = (s: PublicState) => {
			const currentBallPositions = s.balls.map(b => ({
				x: b.x,
				y: b.y,
				vx: b.vx,
				vy: b.vy
			}))
			if (s.score.left > this.lastScore.left)
			{
				const lastBall = this.lastBallPositions.find(b => b.x > WORLD_WIDTH - 100);
				if (lastBall)
				{
					this.particles.createGoalExplosion(
						lastBall.x,
						lastBall.y,
						lastBall.vx,
						lastBall.vy
					);
				}
				this.triggerScreenShake();
			}
			if (s.score.right > this.lastScore.right)
			{
				const lastBall = this.lastBallPositions.find(b => b.x < 100);
				if (lastBall)
				{
					this.particles.createGoalExplosion(
						lastBall.x,
						lastBall.y,
						lastBall.vx,
						lastBall.vy
					);
				}
				this.triggerScreenShake();
			}
			this.lastBallPositions = currentBallPositions;
			this.lastScore = {left: s.score.left, right: s.score.right};

			for (const ball of s.balls) {
				this.particles.createTrail(ball.x, ball.y, ball.vx, ball.vy);
			}

			Object.assign(this.state, s);
			if (this.debugPanel && this.isDebugMode) 
			{
				this.debugPanel.updateStats(s, this.particles.getParticles().length);
			}
		};

		this.net.onPaused = () => {
			this.state.isPaused = true;
			this.timeoutStatus = {
				leftActive: false,
				leftRemainingMs: 0,
				rightActive: false,
				rightRemainingMs: 0
			};
		};

		this.net.onTimeoutStatus = (status) => {
			this.timeoutStatus = {
				leftActive: status.left.active,
				leftRemainingMs: status.left.remainingMs,
				rightActive: status.right.active,
				rightRemainingMs: status.right.remainingMs
			};
		};

		this.net.onCountdown = (v: number) => {
			this.state.countdownValue = v;
		};

		this.net.onGameOver = (winner, isTournament, tournamentId) => {
			if (this.gameOverHandled) {
				console.log('Game over already handled, skipping...');
				return;
			}
			this.gameOverHandled = true;
			
			console.log('Game Over!', {winner, isTournament, tournamentId});
			this.particles.createExplosion(
				this.canvas.width / 2,
				this.canvas.height / 2,
				30
			);
			
			const forfeitBtn = document.getElementById('forfeit-btn') as HTMLButtonElement;
			if (forfeitBtn) {
				forfeitBtn.disabled = true;
			}
			
			if (isTournament && tournamentId)
			{
				this.handleTournamentGameOver(winner, tournamentId);
			}
			else
			{
				this.handleQuickplayGameOver(winner);
			}
		};

		this.net.onPong = (serverTime: number) => {
			const roundTripTime = performance.now() - this.lastPingTime;
			this.statsMonitor.addPing(roundTripTime);
		};

		this.net.onWelcome = this.createWelcomeHandler(this.net);
	}

	private enableDebugMode(): void {
		this.isDebugMode = true;
		console.log('Debug Mode Enabled!');

		const container = document.createElement('div');
		container.id = 'debug-panel-container';
		container.style.marginTop = '16px';

		this.canvas.insertAdjacentElement('afterend', container);
		this.debugContainer = container;

		const callbacks: DebugPanelCallbacks = {
			onActivatePowerUp: (type) => this.debugActivatePowerUp(type),
			onClearPowerUps: () => this.debugClearPowerUps(),
			onScoreChange: (side, amount) => this.debugChangeScore(side, amount),
			onResetScore: () => this.debugResetScore(),
			onSetScore: (left, right) => this.debugSetScore(left, right),
			onBallControl: (action) => this.debugBallControl(action),
			onBallSpeedControl: (action) => this.debugBallSpeedControl(action),
			onTimeControl: (action) => this.debugTimeControl(action),
			onToggleOverlay: () => {},
			onChangeSkill: (side, skill) => this.debugChangeSkill(side, skill)
		};

		this.debugPanel = new DebugPanel(container, callbacks);
		this.debugPanel.open();
	}

	private debugActivatePowerUp(type: 'split' | 'blackout' | 'blackhole' | 'random'): void {
		const types = ['split', 'blackout', 'blackhole'] as const;
		const finalType = type === 'random' ? types[Math.floor(Math.random() * types.length)] : type;
		this.net.debugActivatePowerUp(finalType);
	}

	private debugClearPowerUps(): void {
		this.net.debugClearPowerUps();
	}

	private debugChangeScore(side: 'left' | 'right', amount: number): void {
		this.net.debugScoreChange(side, amount);
	}

	private debugResetScore(): void {
		this.net.debugResetScore();
	}

	private debugSetScore(left: number, right: number): void {
		this.net.debugSetScore(left, right);
	}

	private debugBallControl(action: 'add' | 'remove' | 'reset'): void {
		this.net.debugBallControl(action);
	}

	private debugBallSpeedControl(action: 'multiply' | 'divide' | 'freeze'): void {
		this.net.debugBallSpeed(action);
	}

	private debugTimeControl(action: 'slow' | 'fast' | 'normal'): void {
		const scale = action === 'slow' ? 0.5 : action === 'fast' ? 2 : 1;
		this.net.debugTimeScale(scale);
	}

	private debugChangeSkill(side: 'left' | 'right', skill: 'smash' | 'dash'): void {
		this.net.debugChangeSkill(side, skill);
	}

	private triggerScreenShake(): void 
	{
		const canvas = this.canvas;
		const originalTransform = canvas.style.transform;
		
		let shakeIntensity = 8;
		let shakeCount = 0;
		const maxShakes = 10;
		
		const shake = () => {
			if (shakeCount >= maxShakes) {
				canvas.style.transform = originalTransform;
				return;
			}
			
			const x = (Math.random() - 0.5) * shakeIntensity;
			const y = (Math.random() - 0.5) * shakeIntensity;
			canvas.style.transform = `translate(${x}px, ${y}px)`;
			
			shakeIntensity *= 0.85;
			shakeCount++;
			
			setTimeout(shake, 40);
		};
		
		shake();
	}

	private handleTournamentGameOver(winner: 'left' | 'right', tournamentId: string) {
		const amILeft = this.net.side === 'left';
		const didIWin = (amILeft && winner === 'left') || (!amILeft && winner === 'right');

		this.state.isGameOver = true;
		this.state.winner = winner;

		const message = didIWin
			? 'Victoire ! Redirection vers les brackets...'
			: 'DÃ©faite... Redirection vers les brackets...';

		console.log(message);

		setTimeout(() => {
			sessionStorage.removeItem('gameWsURL');
			window.router.navigate(`/tournament/${tournamentId}`);
		}, 3000);
	}

	private handleLocalTournamentGameOver(winner: 'left' | 'right') {
		this.state.isGameOver = true;
		this.state.winner = winner;

		// RÃ©cupÃ©rer l'ID du match et la config
		const matchId = sessionStorage.getItem('localTournamentMatch');
		const configStr = sessionStorage.getItem('localGameConfig');

		if (!matchId || !configStr) {
			console.error('Missing local tournament match data');
			return;
		}

		try {
			const config = JSON.parse(configStr);

			// DÃ©terminer l'ID du gagnant
			const winnerId = winner === 'left' ? config.left.id : config.right.id;

			// Enregistrer le rÃ©sultat
			const updatedTournament = LocalTournamentManager.recordMatchResult(matchId, winnerId);

			if (updatedTournament) {
				console.log('Match result recorded:', { matchId, winnerId });

				// Afficher un overlay de victoire
				const overlay = document.createElement('div');
				overlay.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
				overlay.innerHTML = `
					<div class="bg-[#0C154D]/90 border-2 border-blue-400 rounded-lg p-8 text-center max-w-md">
						<h2 class="text-4xl font-bold mb-4 text-blue-400">
							ğŸ† ${winner === 'left' ? config.left.username : config.right.username} WINS!
						</h2>
						<p class="text-white/80 text-xl mb-6">
							Score: ${this.state.score.left} - ${this.state.score.right}
						</p>
						<p class="text-blue-300 text-sm">
							Retour au bracket dans <span id="countdown-timer">3</span> secondes...
						</p>
					</div>
				`;

				document.body.appendChild(overlay);

				// DÃ©compte dynamique
				let countdown = 3;
				const countdownEl = document.getElementById('countdown-timer');
				const countdownInterval = setInterval(() => {
					countdown--;
					if (countdownEl) {
						countdownEl.textContent = countdown.toString();
					}
					if (countdown <= 0) {
						clearInterval(countdownInterval);
					}
				}, 1000);

				// Nettoyer et rediriger
				setTimeout(() => {
					clearInterval(countdownInterval);
					overlay.remove(); // Supprimer l'overlay du DOM
					sessionStorage.removeItem('gameWsURL');
					sessionStorage.removeItem('localGameConfig');
					sessionStorage.removeItem('localTournamentMatch');
					window.router.navigate('/local-tournament-bracket');
				}, 3000);
			}
		} catch (error) {
			console.error('Error handling local tournament game over:', error);
		}
	}

	private handleQuickplayGameOver(winner: 'left' | 'right') {
		// VÃ©rifier si c'est un match de tournoi local
		const isLocalTournament = sessionStorage.getItem('localTournamentMatch');
		if (isLocalTournament) {
			this.handleLocalTournamentGameOver(winner);
			return;
		}

		const amILeft = this.net.side === 'left';
		const didIWin = (amILeft && winner === 'left') || (!amILeft && winner === 'right');

		this.state.isGameOver = true;
		this.state.winner = winner;

		const overlay = document.createElement('div');
		overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="bg-[#0C154D]/90 border-2 border-white/20 rounded-lg p-8 text-center max-w-md">
				<h2 class="text-4xl font-bold mb-4 ${didIWin ? 'text-green-400' : 'text-red-400'}">
					${didIWin ? 'ğŸ† VICTOIRE !' : 'ğŸ’€ DÃ‰FAITE'}
				</h2>
				<p class="text-white/80 text-xl mb-6">
					Score: ${this.state.score.left} - ${this.state.score.right}
				</p>
				<button 
					id="return-to-lobby"
					class="px-6 py-3 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg text-white font-semibold transition-all cursor-pointer"
				>
					Retour au lobby
				</button>
			</div>
		`;
		
		document.body.appendChild(overlay);

		overlay.addEventListener('click', (e) => {
			const target = e.target as HTMLElement;
			if (target.id === 'return-to-lobby' || target.closest('#return-to-lobby')) {
				console.log('Return to lobby clicked');
				e.stopPropagation();
				sessionStorage.removeItem('gameWsURL');
				document.body.removeChild(overlay);
				window.router?.navigateTo('/play');
			}
		});
	}

	private setupEventHandlers(): void {
		window.addEventListener('resize', this.handleResize);
		window.addEventListener('pong:togglePause', this.handleTogglePause);

		if (!this.isLocalMode) {
			const forfeitBtn = document.getElementById('forfeit-btn');
			if (forfeitBtn) {
				forfeitBtn.addEventListener('click', this.handleForfeit);
			}
		} else {
			// Cacher le bouton forfeit en mode local
			const forfeitBtn = document.getElementById('forfeit-btn');
			if (forfeitBtn) {
				forfeitBtn.style.display = 'none';
			}
		}

		this.input.attach();
	}

	private connectToServer(): void {
		const storedUrl = sessionStorage.getItem('gameWsURL');
		let urlToUse = storedUrl ?? undefined;
		if (!urlToUse) {
			const host = import.meta.env.VITE_HOST;
			const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
			const roomId = window.location.pathname.split('/').pop();
			if (host && endpoint && roomId) {
				urlToUse = `wss://${host}${endpoint}/${roomId}`;
			}
		}

		const leftId = this.isLocalMode ? this.localConfig?.left.id : undefined;
		this.net.connect(urlToUse, leftId ? { playerId: leftId } : undefined);

		if (this.isLocalMode && this.secondaryNet) {
			const rightId = this.localConfig?.right.id;
			if (urlToUse && rightId) {
				this.secondaryNet.connect(urlToUse, { playerId: rightId });
			} else {
				console.warn('PongGame: missing URL or right player ID for local secondary controller');
			}
		}

		// If an AI opponent was requested (QuickPlay vs AI), connect AI WebSocket directly and start AI
		try {
			const aiPlayerId = sessionStorage.getItem('aiPlayerId');
			const aiSide = (sessionStorage.getItem('aiSide') as 'left' | 'right' | null) || null;
			if (urlToUse && aiPlayerId && aiSide) {
				this.aiNet = new WSClient();
				this.aiNet.onWelcome = this.createWelcomeHandler(this.aiNet);
				this.aiNet.connect(urlToUse, { playerId: aiPlayerId });
				this.enableAI(aiSide, this.aiNet, 1);
				// Clear once consumed
				sessionStorage.removeItem('aiPlayerId');
				sessionStorage.removeItem('aiSide');
			}
		} catch (e) {
			console.warn('PongGame: failed to setup AI opponent', e);
		}
	}

	private setupSecondaryNetworkHandlers(): void {
		if (!this.secondaryNet) {
			return;
		}
    this.secondaryNet.onWelcome = this.createWelcomeHandler(this.secondaryNet);
	}

	private createWelcomeHandler(client: WSClient) {
		return (side: 'left' | 'right' | 'spectator', playerNames?: {left?: string; right?: string}) => {
			console.log('Welcome received:', { side, playerNames });

			const resolvedLeftName = playerNames?.left ?? this.localConfig?.left.username;
			const resolvedRightName = playerNames?.right ?? this.localConfig?.right.username;

			const updateNames = () => {
				const leftNameEl = document.getElementById('player-left-name');
				const rightNameEl = document.getElementById('player-right-name');

				if (leftNameEl && resolvedLeftName) {
					leftNameEl.textContent = resolvedLeftName;
				}
				if (rightNameEl && resolvedRightName) {
					rightNameEl.textContent = resolvedRightName;
				}

				if ((!leftNameEl || !rightNameEl) && (resolvedLeftName || resolvedRightName)) {
					setTimeout(updateNames, 100);
				}
			};

			updateNames();

			if (this.isLocalMode) {
				if (side === 'left') {
					this.leftController = client;
				} else if (side === 'right') {
					this.rightController = client;
				}

				if (this.leftController && this.rightController) {
					this.input.setControllers(this.leftController, this.rightController);
				}
			}

			if (!this.isDebugMode) {
				const username = window.simpleAuth?.getUsername?.();
				if (username === 'admindebug') {
					this.enableDebugMode();
				}
			}


		};
	}

	private handleResize = (): void => {
		this.renderer.setupCanvas();
	};

	private handleTogglePause = (): void => {
		if (this.state.isPaused) 
		{
			this.net.resume();
		} 
		else 
		{
			this.net.pause();
		}
	};

	private handleForfeit = (): void => {
		if (this.state.isGameOver) {
			return;
		}
		
		const confirmed = confirm('Are you sure you want to forfeit this game?');
		if (confirmed) {
			this.net.forfeit();
		}
	};

	private enableAI(side: 'left' | 'right', ws: WSClient, hz?: number): void {
		if (this.aiControllers[side]) {
			this.aiControllers[side]?.stop();
		}
		const ai = new PongAI(() => this.state, side, ws, { hz: hz ?? 1, deadZone: 24, hysteresis: 10, minHoldTicks: 0 });
		ai.start();
		this.aiControllers[side] = ai;
		console.log(`Pong AI enabled for ${side} at ${hz ?? 1} Hz`);
	}

	private disableAI(side?: 'left' | 'right'): void {
		if (side) {
			this.aiControllers[side]?.stop();
			this.aiControllers[side] = undefined;
			console.log(`Pong AI disabled for ${side}`);
			return;
		}
		// disable both
		this.aiControllers.left?.stop();
		this.aiControllers.right?.stop();
		this.aiControllers = {};
		console.log('Pong AI disabled for both sides');
	}

	private setupAIHooks(): void {
		try {
			// Support toggling via custom events (for debugging/tools)
			window.addEventListener('pong:enableAI', ((ev: Event) => {
				const detail = (ev as CustomEvent<{ side: 'left' | 'right' | 'both'; hz?: number }>).detail;
				if (!detail) return;
				const hz = detail.hz ?? 1;
				const ws = this.aiNet ?? this.net;
				if (detail.side === 'both') {
					this.enableAI('left', ws, hz);
					this.enableAI('right', ws, hz);
				} else {
					this.enableAI(detail.side, ws, hz);
				}
			}) as EventListener);
			window.addEventListener('pong:disableAI', ((ev: Event) => {
				const detail = (ev as CustomEvent<{ side?: 'left' | 'right' }>).detail;
				this.disableAI(detail?.side);
			}) as EventListener);
		} catch {}
	}

	private smashOffsetX = (side: 'left' | 'right'): number => {
		const skillType = side === 'left' ? this.state.selectedSkills.left : this.state.selectedSkills.right;
		if (skillType !== 'smash') 
		{
			return 0;
		}

		const skillState = side === 'left' ? this.state.skillStates.left : this.state.skillStates.right;
		const dur = 0.12;
		const dt = Math.max(0, this.state.clock - skillState.lastActivationAt);

		if (dt <= 0 || dt > dur) 
		{
			return 0;
		}

		const t = dt / dur;
		const amp = 24;
		const dir = side === 'left' ? 1 : -1;

		return (dir * amp * Math.sin(Math.PI * t));
	};

	private startAnimationLoop(): void {
		const animate = (): void => {
			this.statsMonitor.recordFrame();
			this.particles.update();
			this.renderer.render(
				this.state,
				this.timeoutStatus,
				this.particles,
				this.net.side,
				this.smashOffsetX,
				this.isLocalMode ? { showLeftSkill: true, showRightSkill: true } : undefined
			);
			this.animationFrameId = requestAnimationFrame(animate);
		};
		animate();
	}

	private loadLocalConfig(): LocalGameConfig | undefined {
		const raw = sessionStorage.getItem('localGameConfig');
		if (!raw) {
			return undefined;
		}
		try {
			return JSON.parse(raw) as LocalGameConfig;
		} catch (err) {
			console.warn('PongGame: failed to parse local game config', err);
			return undefined;
		}
	}

	cleanup(): void {
		console.log('PongGame: cleaning up...');
		if (this.animationFrameId !== null) {
			cancelAnimationFrame(this.animationFrameId);
			this.animationFrameId = null;
		}
		if (this.statsUpdateInterval !== null) {
			clearInterval(this.statsUpdateInterval);
			this.statsUpdateInterval = null;
		}
		if (this.pingInterval !== null) {
			clearInterval(this.pingInterval);
			this.pingInterval = null;
		}
		window.removeEventListener('resize', this.handleResize);
		window.removeEventListener('pong:togglePause', this.handleTogglePause);
		
		if (!this.isLocalMode) {
			const forfeitBtn = document.getElementById('forfeit-btn');
			if (forfeitBtn) {
				forfeitBtn.removeEventListener('click', this.handleForfeit);
			}
		}
		this.input.detach();
		this.particles.clear();
		this.disableAI();
		this.net.cleanup();
		if (this.debugPanel) {
			this.debugPanel.cleanup();
			this.debugPanel = undefined;
		}
		if (this.secondaryNet) {
			this.secondaryNet.cleanup();
			this.secondaryNet = undefined;
		}
		if (this.aiNet) {
			this.aiNet.cleanup();
			this.aiNet = undefined;
		}
		if (this.isLocalMode) {
			sessionStorage.removeItem('localGameConfig');
		}
		if (this.debugContainer && this.debugContainer.parentNode) {
			this.debugContainer.parentNode.removeChild(this.debugContainer);
			this.debugContainer = undefined;
		}
	}
}

export function Pong(): string {
	return '';
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/PongGame/PongParticles.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Particle } from "./types";
import { TRAIL_THRESHOLD, BALL_MAX_SPEED } from "./constants";

export class PongParticleSystem {
	private particles: Particle[] = [];

	addParticle(particle: Particle): void {
		this.particles.push(particle);
	}

	createExplosion(x: number, y: number, count: number = 10): void {
		for (let i = 0; i < count; i++)
		{
			const angle = (Math.PI * 2 * i) / count;
			const speed = 2 + Math.random() * 3;
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * speed,
				vy: Math.sin(angle) * speed,
				life: 1,
				size: 3 + Math.random() * 3,
				color: '#FFFFFF'
			});
		}
	}

	createGoalExplosion(x: number, y: number, ballVx: number, ballVy: number): void {
		const speed = Math.hypot(ballVx, ballVy);
		const dirX = speed > 0 ? ballVx / speed : 1;
		const dirY = speed > 0 ? ballVy / speed : 0;

		const mainAngle = Math.atan2(dirY, dirX);
		
		for (let i = 0; i < 80; i++) 
		{
			const angleVariation = (Math.random() - 0.5) * Math.PI * 0.15;
			const angle = mainAngle + angleVariation;
			
			const particleSpeed = 12 + Math.random() * 15;
			const size = 4 + Math.random() * 6;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 1.0,
				size: size,
				color: '#FFFFFF'
			});
		}

		for (let i = 0; i < 60; i++) 
		{
			const angleVariation = (Math.random() - 0.5) * Math.PI * 0.25;
			const angle = mainAngle + angleVariation;
			const particleSpeed = 8 + Math.random() * 12;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 1.0,
				size: 3 + Math.random() * 5,
				color: '#FFFFFF'
			});
		}

		for (let i = 0; i < 40; i++) 
		{
			const angleVariation = (Math.random() - 0.5) * Math.PI * 0.4;
			const angle = mainAngle + angleVariation;
			const particleSpeed = 5 + Math.random() * 8;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 0.9,
				size: 2 + Math.random() * 4,
				color: '#FFFFFF'
			});
		}

		for (let i = 0; i < 15; i++) 
		{
			const angleVariation = (Math.random() - 0.5) * Math.PI * 0.2;
			const angle = mainAngle + angleVariation;
			const particleSpeed = 10 + Math.random() * 12;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 1.0,
				size: 8 + Math.random() * 10,
				color: '#FFFFFF'
			});
		}

		const starCount = 12;
		for (let i = 0; i < starCount; i++) 
		{
			const angle = (Math.PI * 2 * i) / starCount;
			const particleSpeed = 8 + Math.random() * 6;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 0.6,
				size: 5 + Math.random() * 5,
				color: '#FFFFFF'
			});
		}

		for (let i = 0; i < 30; i++) 
		{
			const angle = Math.random() * Math.PI * 2;
			const particleSpeed = Math.random() * 3;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 1.2,
				size: 1 + Math.random() * 3,
				color: '#FFFFFF'
			});
		}
	}

	createTrail(x: number, y: number, vx: number, vy: number): void {
		const speed = Math.hypot(vx, vy);
		if (speed < TRAIL_THRESHOLD)
		{
			return;
		}
		const nx = -vx / speed;
		const ny = -vy / speed;

		this.particles.push({
			x: x + nx * 10,
			y: y + ny * 10,
			vx: 0,
			vy: 0,
			life: 0.5,
			size: 8 + (speed / 1500) * 7,
			color: `rgba(255, 255, 255, ${0.3 + (speed / BALL_MAX_SPEED) * 0.4})`
		});
	}

	update(dt: number = 0.016): void {
		for (let i = this.particles.length - 1; i >= 0; i--)
		{
			const p = this.particles[i];
			p.x += p.vx;
			p.y += p.vy;
			p.life -= dt * 2;

			if (p.life <= 0)
			{
				this.particles.splice(i, 1);
			}
		}
	}

	render(ctx: CanvasRenderingContext2D): void {
		for (const p of this.particles)
		{
			ctx.globalAlpha = p.life;
			ctx.fillStyle = p.color;
			ctx.beginPath();
			ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
			ctx.fill();
		}
		ctx.globalAlpha = 1;
	}

	clear(): void {
		this.particles = [];
	}

	getParticles(): Particle[] {
		return (this.particles);
	}
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/PongGame/PongInput.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { WSClient } from "../../net/wsClient";

export class PongInputHandler {
	private keys = {w: false, s: false, up: false, down: false};
	private net: WSClient;
	private secondaryNet?: WSClient;
	private leftController: WSClient;
	private rightController?: WSClient;

	constructor(net: WSClient, secondaryNet?: WSClient) {
		this.net = net;
		this.secondaryNet = secondaryNet;
		this.leftController = net;
		this.rightController = secondaryNet;
	}

	private onKeyDown = (e: KeyboardEvent): void => {
		switch (e.key) {
			case 'w':
			case 'W':
				this.keys.w = true;
				break;
			case 's':
			case 'S':
				this.keys.s = true;
				break;
			case 'ArrowUp':
				this.keys.up = true;
				e.preventDefault();
				break;
			case 'ArrowDown':
				this.keys.down = true;
				e.preventDefault();
				break;
			case ' ':
				this.leftController.useSkill();
				e.preventDefault();
				return;
			case 'Enter':
				(this.rightController ?? this.leftController).useSkill();
				e.preventDefault();
				return;
			case 'p':
			case 'P':
			case 'Escape':
				this.handlePause();
				e.preventDefault();
				return;
		}
		this.sendIntent();
	};

	private onKeyUp = (e: KeyboardEvent): void => {
		switch (e.key) {
			case 'w':
			case 'W':
				this.keys.w = false;
				break;
			case 's':
			case 'S':
				this.keys.s = false;
				break;
			case 'ArrowUp':
				this.keys.up = false;
				break;
			case 'ArrowDown':
				this.keys.down = false;
				break;
		}
		this.sendIntent();
	};

	private sendIntent(): void {
		if (this.rightController && this.rightController !== this.leftController) {
			this.leftController.sendInput(!!this.keys.w, !!this.keys.s);
			this.rightController.sendInput(!!this.keys.up, !!this.keys.down);
		} else {
			const up = this.keys.w || this.keys.up;
			const down = this.keys.s || this.keys.down;
			this.net.sendInput(!!up, !!down);
		}
	}

	private handlePause(): void {
		window.dispatchEvent(new CustomEvent('pong:togglePause'));
	}

	attach(): void {
		window.addEventListener('keydown', this.onKeyDown);
		window.addEventListener('keyup', this.onKeyUp);
	}

	detach(): void {
		window.removeEventListener('keydown', this.onKeyDown);
		window.removeEventListener('keyup', this.onKeyUp);
	}

	setControllers(left: WSClient, right?: WSClient): void {
		this.leftController = left;
		this.rightController = right;
	}

	getKeys() {
		return ({ ...this.keys});
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/PongGame/types.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { PublicState } from "../../net/wsClient";

export interface PongGameState extends PublicState {
	// si jamais
}

export interface Particle {
	x: number;
	y: number;
	vx: number;
	vy: number;
	life: number;
	size: number;
	color: string;
}

export interface Ball {
	x: number;
	y: number;
	vx: number;
	vy: number;
	radius: number;
}

export interface TimeoutStatus {
	leftActive: boolean;
	leftRemainingMs: number;
	rightActive: boolean;
	rightRemainingMs: number;
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/PongGame/PongAssets.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export class PongAssets {
	private images: Map<string, HTMLImageElement> = new Map();
	private loaded = false;

	async loadAll(): Promise<void> {
		this.loaded = true;
	}

	getImage(key: string): HTMLImageElement | undefined {
		return (this.images.get(key));
	}

	isLoaded(): boolean {
		return (this.loaded);
	}
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/PongGame/constants.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export const WORLD_WIDTH = 1920;
export const WORLD_HEIGHT = 1080;
export const PADDLE_WIDTH = 15;
export const PADDLE_HEIGHT = 100;
export const PADDLE_MARGIN = 30;
export const BALL_INITIAL_SPEED = 600;

export const COLORS = {
	background: '#000000',
	paddle: '#FFFFFF',
	ball: '#FFFFFF',
	ballTrail: 'rgba(255, 255, 255, 0.5)',
	powerUpSplit: '#FFD700',
	powerUpBlackout: '#9B59B6',
	powerUpBlackhole: '#20054bff',
	net: '#FFFFFF',
	text: '#FFFFFF'
};

export const BALL_MAX_SPEED = 1500;
export const TRAIL_THRESHOLD = 800;


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/PongGame/PongAI.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { PublicState } from "../../net/wsClient";
import type { WSClient } from "../../net/wsClient";
import { WORLD_HEIGHT, WORLD_WIDTH, PADDLE_MARGIN, PADDLE_WIDTH, PADDLE_HEIGHT } from "./constants";

type Side = 'left' | 'right';

export class PongAI {
  private getState: () => PublicState;
  private side: Side;
  private intervalMs: number;
  private timer: number | null = null;
  private ws: WSClient;
  private prev = { up: false, down: false };
  private deadZone: number; // pixels
  private hysteresis: number; // pixels beyond deadZone to reverse
  private minHoldTicks: number; // min ticks to hold direction
  private lastCmd: 'up' | 'down' | 'none' = 'none';
  private holdTicks = 0;
  private releaseTimer: number | null = null;
  private decisionSeq = 0;

  constructor(getState: () => PublicState, side: Side, ws: WSClient, options?: { hz?: number; deadZone?: number; hysteresis?: number; minHoldTicks?: number }) {
    this.getState = getState;
    this.side = side;
    this.ws = ws;
    const hz = Math.max(1, Math.min(60, Math.floor(options?.hz ?? 1)));
    this.intervalMs = Math.floor(1000 / hz);
    this.deadZone = Math.max(4, Math.floor(options?.deadZone ?? 16));
    this.hysteresis = Math.max(6, Math.floor(options?.hysteresis ?? 20));
    this.minHoldTicks = Math.max(0, Math.floor(options?.minHoldTicks ?? 1));
  }

  start(): void {
    if (this.timer !== null) return;
    this.timer = setInterval(() => this.step(), this.intervalMs) as unknown as number;
  }

  stop(): void {
    if (this.timer !== null) {
      clearInterval(this.timer);
      this.timer = null;
    }
    this.send(false, false);
  }

  private step(): void {
    const state = this.getState();
    const paddleY = this.side === 'left' ? state.leftPaddle.y : state.rightPaddle.y;
    const paddleSpeed = this.side === 'left' ? state.leftPaddle.speed : state.rightPaddle.speed;

    // Choose the ball to react to: prefer one moving towards us with minimal time to intercept
    const balls = state.balls;
    if (balls.length === 0) {
      this.applyDecision('none', 0, 0);
      return;
    }

    const targetX = this.side === 'left'
      ? PADDLE_MARGIN + PADDLE_WIDTH
      : WORLD_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;

    const candidates = balls
      .map(b => {
        const dx = targetX - b.x;
        const t = b.vx !== 0 ? dx / b.vx : Number.POSITIVE_INFINITY; // time to reach our paddle x
        return { b, t };
      })
      .filter(({ b, t }) => {
        // Keep only balls moving towards our side (positive time)
        return t > 0;
      });

    const chosen = (candidates.length > 0)
      ? candidates.reduce((best, cur) => (cur.t < best.t ? cur : best))
      : null;

    // If no ball is moving towards us, drift to center
    const targetY = chosen ? this.predictYAtTime(chosen.b.y, chosen.b.vy, chosen.b.radius, chosen.t)
                           : WORLD_HEIGHT / 2;

    const diff = targetY - paddleY;
    const absDiff = Math.abs(diff);

    // Dynamic margin: wait more when intercept is far in time, avoid chasing too early.
    const t = chosen?.t ?? 0;
    const reaction = this.intervalMs / 1000; // seconds
    const guard = Math.max(this.deadZone, 0.25 * PADDLE_HEIGHT);
    const timeBand = Math.max(0, Math.min(0.4, t * 0.3));
    const distWeCanCorrectNextTick = paddleSpeed * reaction * 0.35;
    const dynamicMargin = Math.max(guard, Math.min(distWeCanCorrectNextTick, paddleSpeed * timeBand));

    const desired: 'up' | 'down' | 'none' = absDiff <= dynamicMargin
      ? 'none'
      : (diff < 0 ? 'up' : 'down');

    this.applyDecision(desired, absDiff, paddleSpeed, t);
  }

  // Predict Y coordinate after time t with wall reflections (top/bottom), given current y, vy, and radius
  private predictYAtTime(y: number, vy: number, radius: number, t: number): number {
    const top = radius;
    const bottom = WORLD_HEIGHT - radius;
    const span = bottom - top;
    if (span <= 0) return y; // degenerate

    const yRaw = y + vy * t;
    const period = 2 * span;
    let m = (yRaw - top) % period;
    if (m < 0) m += period;
    const reflected = (m <= span) ? (top + m) : (top + (period - m));
    return reflected;
  }

  private send(up: boolean, down: boolean): void {
    if (up === this.prev.up && down === this.prev.down) return;
    this.prev = { up, down };
    this.ws.sendInput(up, down);
  }

  private applyDecision(desired: 'up' | 'down' | 'none', absDiff: number, paddleSpeed: number, timeToIntercept: number = 0): void {
    let cmd: 'up' | 'down' | 'none' = desired;

    if (desired === 'none') {
      cmd = 'none';
    } else if (this.lastCmd === 'none') {
      cmd = desired;
    } else if (desired !== this.lastCmd) {
      if (absDiff < this.deadZone + this.hysteresis || this.holdTicks < this.minHoldTicks) {
        cmd = this.lastCmd; // avoid rapid reversals
      }
    } else {
      cmd = this.lastCmd;
    }

    if (cmd !== this.lastCmd) {
      this.holdTicks = 0;
      this.lastCmd = cmd;
    } else {
      this.holdTicks++;
    }

    // Cancel previous scheduled release
    if (this.releaseTimer !== null) {
      clearTimeout(this.releaseTimer);
      this.releaseTimer = null;
    }

    // Emit command and schedule a timed release to avoid full-sweep overshoot at 1 Hz
    if (cmd === 'none') {
      this.send(false, false);
      return;
    }

    const seq = ++this.decisionSeq;
    if (cmd === 'up') {
      this.send(true, false);
    } else {
      this.send(false, true);
    }

    // Estimate hold time proportional to distance to cover, capped within the tick interval
    const estMs = paddleSpeed > 1 ? Math.round((absDiff / paddleSpeed) * 1000) : this.intervalMs;
    const holdMs = Math.max(120, Math.min(this.intervalMs - 40, Math.floor(estMs * 0.9)));
    this.releaseTimer = window.setTimeout(() => {
      if (seq === this.decisionSeq) {
        this.send(false, false);
      }
    }, holdMs) as unknown as number;
  }
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/PongGame/PongRenderer.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { PongGameState, TimeoutStatus } from "./types";
import type { PongParticleSystem } from "./PongParticles";
import { WORLD_WIDTH, WORLD_HEIGHT, PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_MARGIN,
COLORS, BALL_MAX_SPEED, TRAIL_THRESHOLD } from "./constants";
import type { WSClient } from "../../net/wsClient";

export class PongRenderer {
	private ctx: CanvasRenderingContext2D;
	private canvas: HTMLCanvasElement;
	private net

	constructor(canvas: HTMLCanvasElement, net: WSClient) {
		this.net = net;
		this.canvas = canvas;
		const ctx = canvas.getContext('2d');
		if (!ctx) {
			throw new Error('PongRenderer: 2D context not found');
		}
		this.ctx = ctx;
		this.setupCanvas();
	}

	setupCanvas(): void {
		const container = this.canvas.parentElement;
		if (!container)
		{
			return;
		}

		const W = WORLD_WIDTH;
		const H = WORLD_HEIGHT;
		const containerWidth = container.clientWidth * 0.9;
		const containerHeight = window.innerHeight * 0.8;
		const scaleX = containerWidth / W;
		const scaleY = containerHeight / H;
		const scale = Math.min(scaleX, scaleY);
		const displayWidth = Math.floor(W * scale);
		const displayHeight = Math.floor(H * scale);
		const dpr = window.devicePixelRatio || 1;

		this.canvas.width = W * dpr;
		this.canvas.height = H * dpr;
		this.ctx.resetTransform();
		this.ctx.scale(dpr, dpr);

		this.canvas.style.width = displayWidth + 'px';
		this.canvas.style.height = displayHeight + 'px';
		this.canvas.style.display = 'block';
		this.canvas.style.margin = '20px auto';
		this.canvas.style.border = '2px solid #333';
		this.canvas.style.boxShadow = '0 4px 20px rgba(0, 0, 0, 0.5)';

		this.ctx.imageSmoothingEnabled = true;
	}

	render(
		state: PongGameState,
		timeoutStatus: TimeoutStatus,
		particles: PongParticleSystem,
		side: 'left' | 'right' | 'spectator',
		smashOffsetX: (side: 'left' | 'right') => number,
		options?: { showLeftSkill?: boolean; showRightSkill?: boolean }
	): void {
		const ctx = this.ctx;
		const W = WORLD_WIDTH;
		const H = WORLD_HEIGHT;
		const shouldBlackout = (side === 'left' && state.blackoutLeft) || (side === 'right' && state.blackoutRight);
		const blackoutIntensity = side === 'left' ? state.blackoutLeftIntensity : side === 'right' ? state.blackoutRightIntensity : 0;

		ctx.fillStyle = COLORS.background;
		ctx.fillRect(0, 0, W, H);

		if (state.blackholeActive)
		{
			this.drawBlackHoleVortex(ctx, state);
		}
		ctx.strokeStyle = shouldBlackout ? `rgba(255, 255, 255, ${0.1 * (1 - blackoutIntensity)})` : COLORS.net;
		ctx.setLineDash([10, 10]);
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(W / 2, 0);
		ctx.lineTo(W / 2, H);
		ctx.stroke();
		ctx.setLineDash([]);

		const leftX = PADDLE_MARGIN + smashOffsetX('left');
		const rightX = W - PADDLE_MARGIN - PADDLE_WIDTH + smashOffsetX('right');

		if (!shouldBlackout || side === 'left')
		{
			ctx.fillStyle = COLORS.paddle;
			ctx.fillRect(
				leftX,
				state.leftPaddle.y - PADDLE_HEIGHT / 2,
				PADDLE_WIDTH,
				PADDLE_HEIGHT
			);
		}
		if (!shouldBlackout || side === 'right')
		{
			ctx.fillStyle = COLORS.paddle;
			ctx.fillRect(
				rightX,
				state.rightPaddle.y - PADDLE_HEIGHT / 2,
				PADDLE_WIDTH,
				PADDLE_HEIGHT
			);
		}

		if (!shouldBlackout)
		{
			for (const powerUp of state.powerUps) 
			{
				this.drawPowerUp(ctx, powerUp.x, powerUp.y, powerUp.radius, state.clock, powerUp.type);
			}
		}

		particles.render(ctx);

		for (const b of state.balls) 
		{
			const speed = Math.hypot(b.vx, b.vy);
			
			if (speed >= TRAIL_THRESHOLD) 
			{
				this.drawBallTrail(ctx, b, speed);
			}

			ctx.fillStyle = COLORS.ball;
			ctx.beginPath();
			ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
			ctx.fill();

			if (speed >= BALL_MAX_SPEED * 0.9) 
			{
				ctx.shadowBlur = 20;
				ctx.shadowColor = COLORS.ball;
				ctx.beginPath();
				ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
				ctx.fill();
				ctx.shadowBlur = 0;
			}
		}

		ctx.fillStyle = shouldBlackout ? `rgba(255, 255, 255, ${0.3 * (1 - blackoutIntensity)})` : COLORS.text;
		ctx.font = '48px monospace';
		ctx.textAlign = 'center';
		ctx.fillText(String(state.score.left), W / 2 - 100, 60);
		ctx.fillText(String(state.score.right), W / 2 + 100, 60);

		const showLeftHud = (options?.showLeftSkill ?? false) || side === 'left';
		const showRightHud = (options?.showRightSkill ?? false) || side === 'right';

		const drawSkillHud = (playerSide: 'left' | 'right', centerX: number) => {
			const isBlackout = playerSide === 'left' ? state.blackoutLeft : state.blackoutRight;
			if (isBlackout) {
				return;
			}

			const skillState = playerSide === 'left' ? state.skillStates.left : state.skillStates.right;
			const skillType = playerSide === 'left' ? state.selectedSkills.left : state.selectedSkills.right;
			const cooldown = skillType === 'smash' ? 3 : 5;
			const progress =
				skillState.cooldownRemaining > 0
					? Math.max(0, Math.min(1, 1 - skillState.cooldownRemaining / cooldown))
					: 1;

			this.drawCooldownDonut(ctx, centerX, 60, 28, 10, progress);

			if (skillState.cooldownRemaining > 0) {
				ctx.fillStyle = COLORS.text;
				ctx.font = '16px monospace';
				ctx.textAlign = playerSide === 'left' ? 'left' : 'right';
				const textX = playerSide === 'left' ? centerX + 35 : centerX - 35;
				ctx.fillText(skillState.cooldownRemaining.toFixed(1) + 's', textX, 66);
			}
		};

		if (showLeftHud) {
			drawSkillHud('left', 60);
		}
		if (showRightHud) {
			drawSkillHud('right', W - 60);
		}
		ctx.textAlign = 'center';

		if (shouldBlackout && blackoutIntensity > 0)
		{
			ctx.fillStyle = `rgba(0, 0, 0, ${blackoutIntensity * 0.95})`;
			ctx.fillRect(0, 0, W, H);
			this.drawNeonUnderBlackout(ctx, state, side, smashOffsetX);
		}

		this.renderOverlays(ctx, state, timeoutStatus, side, W, H);
	}

	private drawBallTrail(ctx: CanvasRenderingContext2D, ball: { x: number; y: number; vx: number; vy: number; radius: number }, speed: number): void {
		const trailLength = Math.min(8, Math.floor((speed / BALL_MAX_SPEED) * 10));
		const direction = Math.atan2(ball.vy, ball.vx);

		for (let i = 1; i <= trailLength; i++) 
		{
			const distance = i * 12;
			const trailX = ball.x - Math.cos(direction) * distance;
			const trailY = ball.y - Math.sin(direction) * distance;
			const alpha = 1 - i / trailLength;
			const size = ball.radius * (1 - i / trailLength * 0.5);

			ctx.globalAlpha = alpha * 0.6;
			ctx.fillStyle = COLORS.ballTrail;
			ctx.beginPath();
			ctx.arc(trailX, trailY, size, 0, Math.PI * 2);
			ctx.fill();
		}
		ctx.globalAlpha = 1;
	}

	private drawPowerUp(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, time: number, type: string): void {
		const pulse = Math.sin(time * 4) * 2;

		if (type === 'blackhole')
		{
			const color = COLORS.powerUpBlackhole;
			ctx.beginPath();
			ctx.beginPath();
			ctx.fillStyle = color;
			ctx.arc(x, y, radius + pulse, 0, Math.PI * 2);
			ctx.fill();
			ctx.strokeStyle = '#0b2230';
			ctx.lineWidth = 3;
			ctx.stroke();

			const grad = ctx.createRadialGradient(x, y, 1, x, y, radius * 0.8);
			grad.addColorStop(0, 'rgba(0,0,0,1)');
			grad.addColorStop(1, 'rgba(14,165,233,0.2)');
			ctx.fillStyle = grad;
			ctx.beginPath();
			ctx.arc(x, y, radius * 0.7 + pulse * 0.3, 0, Math.PI * 2);
			ctx.fill();
			return;
		}

		const color = type === 'blackout' ? COLORS.powerUpBlackout : COLORS.powerUpSplit;
		ctx.beginPath();
		ctx.fillStyle = color;
		ctx.arc(x, y, radius + pulse, 0, Math.PI * 2);
		ctx.fill();
		ctx.strokeStyle = '#333';
		ctx.lineWidth = 3;
		ctx.stroke();

		if (type === 'split')
		{
			const oscillation = Math.sin(time * 3) * 3;
			const iconRadius = radius * 0.25;
			const baseOffset = radius * 0.3;
	
			ctx.beginPath();
			ctx.fillStyle = '#FFF';
			ctx.arc(x - baseOffset - oscillation, y, iconRadius, 0, Math.PI * 2);
			ctx.fill();
			ctx.strokeStyle = '#333';
			ctx.lineWidth = 2;
			ctx.stroke();
	
			ctx.beginPath();
			ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
			ctx.arc(x + baseOffset + oscillation, y, iconRadius, 0, Math.PI * 2);
			ctx.fill();
			ctx.strokeStyle = 'rgba(51, 51, 51, 0.8)';
			ctx.lineWidth = 2;
			ctx.stroke();
		}
		else if (type === 'blackout') 
		{
			ctx.fillStyle = '#000';
			ctx.beginPath();
			ctx.arc(x, y, radius * 0.5, 0, Math.PI * 2);
			ctx.fill();
			
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(x + radius * 0.15, y, radius * 0.4, 0, Math.PI * 2);
			ctx.fill();
		}
	}

	private drawCooldownDonut(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, thickness: number, progress: number): void {
		const start = -Math.PI / 2;
		const end = start + progress * Math.PI * 2;

		ctx.strokeStyle = '#444';
		ctx.lineWidth = thickness;
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2);
		ctx.stroke();

		if (progress > 0) 
		{
			ctx.strokeStyle = progress >= 1 ? '#00e676' : '#ffcc00';
			ctx.lineWidth = thickness;
			ctx.beginPath();
			ctx.arc(x, y, r, start, end);
			ctx.stroke();
		}
	}

	private drawNeonUnderBlackout(ctx: CanvasRenderingContext2D, state: PongGameState, side: 'left' | 'right' | 'spectator', smashOffsetX: (side: 'left' | 'right') => number): void {
		const W = WORLD_WIDTH;
		const leftX = PADDLE_MARGIN + smashOffsetX('left');
		const rightX = W - PADDLE_MARGIN - PADDLE_WIDTH + smashOffsetX('right');

		ctx.save();
		ctx.globalCompositeOperation = 'lighter';
		ctx.shadowColor = '#ffffff';
		ctx.shadowBlur = 28;
		ctx.fillStyle = '#ffffff';

		if (side === 'left') {
			ctx.fillRect(
				leftX,
				state.leftPaddle.y - PADDLE_HEIGHT / 2,
				PADDLE_WIDTH,
				PADDLE_HEIGHT
			);
		} else if (side === 'right') {
			ctx.fillRect(
				rightX,
				state.rightPaddle.y - PADDLE_HEIGHT / 2,
				PADDLE_WIDTH,
				PADDLE_HEIGHT
			);
		}

		for (const b of state.balls) {
			ctx.beginPath();
			ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
			ctx.fill();

			ctx.shadowBlur = 40;
			ctx.beginPath();
			ctx.arc(b.x, b.y, Math.max(2, b.radius * 0.85), 0, Math.PI * 2);
			ctx.fill();
		}

		ctx.restore();
	}

	private drawBlackHoleVortex(ctx: CanvasRenderingContext2D, state: PongGameState): void
	{
		const cx = state.blackholeCenterX;
		const cy = state.blackholeCenterY;
		const p = Math.max(0, Math.min(1, state.blackholeProgress));
		const baseR = 260;
		const r = baseR * (0.8 + 0.6 * p);

		const pulse = Math.sin(state.clock * 3) * 0.15 + 1;
		const effectiveRadius = r * pulse;

		const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, effectiveRadius);
		g.addColorStop(0.0, 'rgba(0,0,0,1)');
		g.addColorStop(0.3, 'rgba(10,5,30,0.95)');
		g.addColorStop(0.6, 'rgba(20,10,50,0.7)');
		g.addColorStop(1.0, 'rgba(0,0,0,0.1)');
		ctx.fillStyle = g;
		ctx.beginPath();
		ctx.arc(cx, cy, effectiveRadius, 0, Math.PI * 2);
		ctx.fill();

		ctx.save();
		ctx.globalCompositeOperation = 'lighter';

		const ringCount = 8;
		for (let i = 0; i < ringCount; i++) 
		{
			const ringProgress = i / ringCount;
			const ringRadius = effectiveRadius * (0.3 + ringProgress * 0.7);
			const ringPulse = Math.sin(state.clock * 4 - ringProgress * Math.PI * 2) * 0.1 + 1;
			const actualRadius = ringRadius * ringPulse;
			
			const hue = 220 + ringProgress * 60;
			const alpha = (0.4 - ringProgress * 0.3) * (1 - p * 0.5);
			
			ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
			ctx.lineWidth = 3 - ringProgress * 2;
			
			ctx.beginPath();
			const segments = 60;
			for (let s = 0; s <= segments; s++) 
			{
				const angle = (s / segments) * Math.PI * 2;
				const distortion = Math.sin(angle * 3 + state.clock * 2 + ringProgress * Math.PI) * (5 + ringProgress * 10);
				const x = cx + Math.cos(angle) * (actualRadius + distortion);
				const y = cy + Math.sin(angle) * (actualRadius + distortion);
				
				if (s === 0) ctx.moveTo(x, y);
				else ctx.lineTo(x, y);
			}
			ctx.closePath();
			ctx.stroke();
		}

		const spiralCount = 5;
		for (let i = 0; i < spiralCount; i++) 
		{
			const spiralOffset = (i / spiralCount) * Math.PI * 2;
			const spiralProgress = (state.clock * 2 + spiralOffset) % (Math.PI * 2);
			
			ctx.strokeStyle = `rgba(100, 150, 255, ${0.6 * (1 - p * 0.3)})`;
			ctx.lineWidth = 2;
			ctx.beginPath();
			
			const spiralSegments = 40;
			for (let s = 0; s < spiralSegments; s++) 
			{
				const t = s / spiralSegments;
				const angle = spiralProgress + t * Math.PI * 4;
				const radius = effectiveRadius * (0.2 + t * 0.8);
				const x = cx + Math.cos(angle) * radius;
				const y = cy + Math.sin(angle) * radius;
				
				if (s === 0) ctx.moveTo(x, y);
				else ctx.lineTo(x, y);
			}
			ctx.stroke();
		}

		const particleCount = 30;
		for (let i = 0; i < particleCount; i++) 
		{
			const particleAngle = (i / particleCount) * Math.PI * 2 + state.clock * 1.5;
			const orbitRadius = effectiveRadius * (0.5 + (i % 3) * 0.2);
			const wobble = Math.sin(state.clock * 3 + i) * 10;
			
			const px = cx + Math.cos(particleAngle) * (orbitRadius + wobble);
			const py = cy + Math.sin(particleAngle) * (orbitRadius + wobble);
			
			const particleSize = 2 + Math.sin(state.clock * 4 + i) * 1.5;
			const particleAlpha = 0.6 + Math.sin(state.clock * 5 + i) * 0.4;
			
			ctx.fillStyle = `rgba(150, 200, 255, ${particleAlpha})`;
			ctx.beginPath();
			ctx.arc(px, py, particleSize, 0, Math.PI * 2);
			ctx.fill();
			
			ctx.strokeStyle = `rgba(150, 200, 255, ${particleAlpha * 0.3})`;
			ctx.lineWidth = 1;
			ctx.beginPath();
			const trailLength = 15;
			const trailX = px - Math.cos(particleAngle) * trailLength;
			const trailY = py - Math.sin(particleAngle) * trailLength;
			ctx.moveTo(px, py);
			ctx.lineTo(trailX, trailY);
			ctx.stroke();
		}

		const coreSize = 20 * pulse;
		const coreGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreSize);
		coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
		coreGradient.addColorStop(0.3, 'rgba(150, 200, 255, 0.8)');
		coreGradient.addColorStop(0.7, 'rgba(50, 100, 200, 0.4)');
		coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
		
		ctx.fillStyle = coreGradient;
		ctx.beginPath();
		ctx.arc(cx, cy, coreSize, 0, Math.PI * 2);
		ctx.fill();

		ctx.strokeStyle = `rgba(100, 150, 255, ${0.3 * pulse})`;
		ctx.lineWidth = 3;
		ctx.beginPath();
		ctx.arc(cx, cy, effectiveRadius * 0.95, 0, Math.PI * 2);
		ctx.stroke();

		ctx.restore();

		const shockwaveInterval = 2;
		const timeSinceLastShock = state.clock % shockwaveInterval;
		if (timeSinceLastShock < 0.5) 
		{
			const shockProgress = timeSinceLastShock / 0.5;
			const shockRadius = effectiveRadius * shockProgress;
			const shockAlpha = (1 - shockProgress) * 0.6;
			
			ctx.strokeStyle = `rgba(200, 220, 255, ${shockAlpha})`;
			ctx.lineWidth = 4 * (1 - shockProgress);
			ctx.beginPath();
			ctx.arc(cx, cy, shockRadius, 0, Math.PI * 2);
			ctx.stroke();
		}
	}

	private renderOverlays(ctx: CanvasRenderingContext2D, state: PongGameState, timeoutStatus: TimeoutStatus, side: 'left' | 'right' | 'spectator', W: number, H: number): void {
		if (state.countdownValue > 0) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			ctx.fillStyle = '#fff';
			ctx.font = '120px monospace';
			ctx.textAlign = 'center';
			ctx.fillText(String(state.countdownValue), W / 2, H / 2);
		} 
		else if (state.isGameOver) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			if (this.net.isTournament) 
			{
				const amILeft = this.net.side === 'left';
				const didIWin = (amILeft && state.winner === 'left') || 
							(!amILeft && state.winner === 'right');
				
				ctx.fillStyle = didIWin ? '#00ff00' : '#ff0000';
				ctx.font = '72px monospace';
				ctx.fillText(didIWin ? 'VICTOIRE !' : 'DÃ‰FAITE', W / 2, H / 2 - 40);
				
				ctx.fillStyle = '#fff';
				ctx.font = '36px monospace';
				ctx.fillText(`${state.winner} wins`, W / 2, H / 2 + 10);
				
				ctx.font = '24px monospace';
				ctx.fillText('Redirection vers les brackets...', W / 2, H / 2 + 60);
			} 
			else 
			{
				ctx.fillStyle = '#fff';
				ctx.font = '72px monospace';
				ctx.fillText('GAME OVER', W / 2, H / 2 - 40);
				ctx.font = '36px monospace';
				ctx.fillText(`${state.winner} wins`, W / 2, H / 2 + 10);
			}
		} 
		else if (state.isPaused) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);

			const iAmLeft = side === 'left';
			const opponentDisconnected = iAmLeft
				? timeoutStatus.rightActive
				: timeoutStatus.leftActive;
			const opponentRemainingMs = iAmLeft
				? timeoutStatus.rightRemainingMs
				: timeoutStatus.leftRemainingMs;

			if (opponentDisconnected && opponentRemainingMs > 0) 
			{
				const secondsRemaining = Math.ceil(opponentRemainingMs / 1000);
				ctx.font = '36px monospace';
				ctx.fillStyle = '#ff6b6b';
				ctx.textAlign = 'center';
				ctx.fillText('âš ï¸ Adversaire dÃ©connectÃ©', W / 2, H / 2 + 20);

				ctx.font = '48px monospace';
				ctx.fillStyle = '#fff';
				ctx.fillText(`Forfeit dans: ${secondsRemaining}s`, W / 2, H / 2 + 80);

				const barWidth = 400;
				const barHeight = 10;
				const barX = (W - barWidth) / 2;
				const barY = H / 2 + 120;
				const progress = opponentRemainingMs / 30000;

				ctx.fillStyle = 'rgba(255,255,255,0.2)';
				ctx.fillRect(barX, barY, barWidth, barHeight);

				ctx.fillStyle = progress > 0.3 ? '#4CAF50' : '#ff6b6b';
				ctx.fillRect(barX, barY, barWidth * progress, barHeight);
			} 
			else 
			{
				ctx.fillStyle = '#fff';
				ctx.font = '72px monospace';
				ctx.textAlign = 'center';
				ctx.fillText('PAUSED', W / 2, H / 2);
				ctx.font = '24px monospace';
				ctx.fillText('Press P, SPACE or ESC to resume', W / 2, H / 2 + 60);
			}
		}
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/DebugPanel.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Component } from "./types";
import type { PublicState } from "../net/wsClient";

export interface DebugPanelCallbacks {
    onActivatePowerUp: (type: 'split' | 'blackout' | 'blackhole' | 'random') => void;
    onClearPowerUps: () => void;
    onScoreChange: (side: 'left' | 'right', amount: number) => void;
    onResetScore: () => void;
    onSetScore: (left: number, right: number) => void;
    onBallControl: (action: 'add' | 'remove' | 'reset') => void;
    onBallSpeedControl: (action: 'multiply' | 'divide' | 'freeze') => void;
    onTimeControl: (action: 'slow' | 'fast' | 'normal') => void;
    onToggleOverlay: () => void;
    onChangeSkill: (side: 'left' | 'right', skill: 'smash' | 'dash') => void;
}

export class DebugPanel implements Component {
    private element: HTMLElement;
    private isOpen: boolean = false;
    private callbacks: DebugPanelCallbacks;
    private overlayVisible: boolean = false;
    private isFrozen: boolean = false;
    private timeScale: number = 1;

    private fps: number = 0;
    private particleCount: number = 0;
    private ballsData: Array<{ x: number; y: number; vx: number; vy: number }> = [];
    private activePowerUps: string[] = [];
    private skillCooldowns: { 
        left: number;
        right: number;
    } = { 
        left: 0,
        right: 0
    };
    private selectedSkills: {
        left: 'smash' | 'dash';
        right: 'smash' | 'dash';
    } = {
        left: 'smash',
        right: 'smash'
    };

    private listeners: Array<{ el: Element; handler: EventListener }> = [];
    private closeBtn?: Element;
    private closeHandler?: EventListener;
    private boundKeydown?: (e: KeyboardEvent) => void;
    private destroyed = false;

    private isDragging = false;
    private dragOffsetX = 0;
    private dragOffsetY = 0;
    private posX = 20;
    private posY = 20;

    constructor(element: HTMLElement, callbacks: DebugPanelCallbacks) {
        this.element = element;
        this.callbacks = callbacks;
        this.init();
    }

    private init(): void {
        this.render();
        this.attachEventListeners();
        this.startFPSCounter();
        this.setupDragging();

        this.boundKeydown = (e: KeyboardEvent) => {
            if (e.key === 'm' || e.key === 'M') {
                e.preventDefault();
                this.toggle();
            }
        };
        window.addEventListener('keydown', this.boundKeydown);
    }

    private toggle(): void {
        this.isOpen = !this.isOpen;
        const panel = this.element.querySelector('.debug-panel') as HTMLElement;
        if (panel) {
            if (this.isOpen) {
                panel.classList.add('open');
            } else {
                panel.classList.remove('open');
            }
        }
    }

    public open(): void {
        this.isOpen = true;
        const panel = this.element.querySelector('.debug-panel') as HTMLElement;
        if (panel) {
            panel.classList.add('open');
        }
    }

    public close(): void {
        this.isOpen = false;
        const panel = this.element.querySelector('.debug-panel') as HTMLElement;
        if (panel) {
            panel.classList.remove('open');
        }
    }

    private startFPSCounter(): void {
        let lastTime = performance.now();
        let frames = 0;

        const updateFPS = () => {
            if (this.destroyed) return;
            frames++;
            const now = performance.now();

            if (now >= lastTime + 1000) {
                this.fps = Math.round((frames * 1000) / (now - lastTime));
                frames = 0;
                lastTime = now;
                this.updateOverlay();
            }
            requestAnimationFrame(updateFPS);
        };

        requestAnimationFrame(updateFPS);
    }

    public updateStats(state: PublicState, particleCount: number): void {
        this.particleCount = particleCount;
        this.ballsData = state.balls.map(b => ({
            x: Math.round(b.x),
            y: Math.round(b.y),
            vx: Math.round(b.vx),
            vy: Math.round(b.vy)
        }));

        this.activePowerUps = [];
        if (state.splitActive) this.activePowerUps.push('Split');
        if (state.blackoutLeft) this.activePowerUps.push('Blackout Left');
        if (state.blackoutRight) this.activePowerUps.push('Blackout Right');
        if (state.blackholeActive) this.activePowerUps.push('Blackhole');

        this.selectedSkills = {
            left: state.selectedSkills.left,
            right: state.selectedSkills.right
        };
        this.skillCooldowns = {
            left: state.skillStates.left.cooldownRemaining,
            right: state.skillStates.right.cooldownRemaining
        };

        this.updateOverlay();
    }

    private updateOverlay(): void {
        if (!this.overlayVisible) return;

        const overlay = this.element.querySelector('.debug-overlay') as HTMLElement;
        if (!overlay) return;

        const estimatedDrawCalls = this.ballsData.length * 3 +
            this.particleCount +
            this.activePowerUps.length * 10 +
            50; // Base UI elements

        overlay.innerHTML = `
            <div class="stat-line">FPS: <span class="stat-value">${this.fps}</span></div>
            <div class="stat-line">Particles: <span class="stat-value">${this.particleCount}</span></div>
            <div class="stat-line">Draw Calls: <span class="stat-value">~${estimatedDrawCalls}</span></div>
            <div class="stat-line">Time Scale: <span class="stat-value">${this.timeScale}x</span></div>
            
            <div class="stat-section">Balls (${this.ballsData.length}):</div>
            ${this.ballsData.map((b, i) => `
                <div class="stat-line small">
                    #${i + 1}: pos(${b.x}, ${b.y}) vel(${b.vx}, ${b.vy})
                </div>
            `).join('')}
            
            <div class="stat-section">Active Power-Ups:</div>
            ${this.activePowerUps.length > 0
                ? this.activePowerUps.map(p => `<div class="stat-line small">â€¢ ${p}</div>`).join('')
                : '<div class="stat-line small">None</div>'
            }
            
            <div class="stat-section">Skill Cooldowns:</div>
            <div class="stat-line small">Left (${this.selectedSkills.left}): ${this.skillCooldowns.left.toFixed(1)}s</div>
            <div class="stat-line small">Right (${this.selectedSkills.right}): ${this.skillCooldowns.right.toFixed(1)}s</div>
        `;
    }

    private render(): void {
        this.element.innerHTML = `
        <style>
            .debug-panel {
                position: fixed;
                top: 20px;
                left: 20px;
                width: 400px;
                max-height: 80vh;
                overflow-y: auto;
                background: rgba(10, 10, 30, 0.95);
                backdrop-filter: blur(10px);
                border: 2px solid rgba(100, 150, 255, 0.3);
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                color: #fff;
                font-family: 'Courier New', monospace;
                font-size: 13px;
                z-index: 9999;
                display: none;
            }
            .debug-panel.open {
                display: block;
            }
            .debug-header {
                background: rgba(100, 150, 255, 0.2);
                padding: 12px 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                display: flex;
                justify-content: space-between;
                align-items: center;
                cursor: move;
                user-select: none;
            }
            .debug-title { font-size: 16px; font-weight: bold; color: #64B5F6; }
            .debug-close {
                background: rgba(255, 100, 100, 0.3);
                border: 1px solid rgba(255, 100, 100, 0.5);
                color: #fff;
                padding: 4px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                transition: all 0.2s;
            }
            .debug-section { padding: 16px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
            .debug-section:last-child { border-bottom: none; }
            .section-title { font-size: 14px; font-weight: bold; color: #90CAF9; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
            .debug-btn {
                background: rgba(100, 150, 255, 0.2);
                border: 1px solid rgba(100, 150, 255, 0.4);
                color: #fff;
                padding: 8px 14px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 12px;
                font-family: 'Courier New', monospace;
                transition: all 0.2s;
                margin: 4px;
                display: inline-block;
            }
            .debug-btn:hover { background: rgba(100, 150, 255, 0.4); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(100, 150, 255, 0.4); }
            .debug-btn:active { transform: translateY(0); }
            .debug-btn.danger { background: rgba(255, 100, 100, 0.2); border-color: rgba(255, 100, 100, 0.4); }
            .debug-btn.danger:hover { background: rgba(255, 100, 100, 0.4); box-shadow: 0 4px 12px rgba(255, 100, 100, 0.4); }
            .debug-btn.success { background: rgba(100, 255, 100, 0.2); border-color: rgba(100, 255, 100, 0.4); }
            .debug-btn.success:hover { background: rgba(100, 255, 100, 0.4); box-shadow: 0 4px 12px rgba(100, 255, 100, 0.4); }
            .debug-btn.small { padding: 6px 10px; font-size: 11px; }
            .debug-btn.active { background: rgba(100, 200, 255, 0.5); border-color: rgba(100, 200, 255, 0.8); box-shadow: 0 0 8px rgba(100, 200, 255, 0.6); }
            .btn-row { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px; }
            .score-control { display: flex; align-items: center; gap: 8px; margin: 8px 0; }
            .score-label { min-width: 50px; color: #90CAF9; }
            .skill-control { display: flex; align-items: center; gap: 8px; margin: 8px 0; }
            .skill-label { min-width: 80px; color: #90CAF9; font-weight: bold; }
            .debug-overlay {
                position: fixed;
                top: 20px;
                left: 20px;
                background: rgba(10, 10, 30, 0.9);
                backdrop-filter: blur(8px);
                border: 1px solid rgba(100, 150, 255, 0.3);
                border-radius: 8px;
                padding: 12px 16px;
                color: #fff;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                z-index: 9998;
                display: none;
            }
            .stat-line { margin: 4px 0; color: #B0BEC5; }
            .stat-line.small { font-size: 11px; margin-left: 12px; color: #78909C; }
            .stat-value { color: #64B5F6; font-weight: bold; }
            .stat-section { margin-top: 12px; margin-bottom: 4px; color: #90CAF9; font-weight: bold; border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 8px; }
            .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
            .status-indicator.active { background: #4CAF50; box-shadow: 0 0 8px #4CAF50; }
            .status-indicator.inactive { background: #666; }
        </style>

        <div class="debug-panel">
            <div class="debug-header">
                <div class="debug-title">DEBUG PANEL</div>
                <button class="debug-close" data-action="close">Close [M]</button>
            </div>

            <div class="debug-section">
                <div class="section-title">Power-Ups</div>
                <div class="btn-row">
                    <button class="debug-btn" data-action="activate-split">Activate Split</button>
                    <button class="debug-btn" data-action="activate-blackout">Activate Blackout</button>
                    <button class="debug-btn" data-action="activate-blackhole">Activate Blackhole</button>
                    <button class="debug-btn" data-action="activate-random">Activate Random</button>
                    <button class="debug-btn danger" data-action="clear-powerups">Clear All</button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Score Control</div>
                <div class="score-control">
                    <span class="score-label">Left:</span>
                    <button class="debug-btn small" data-action="score-left-plus">+1</button>
                    <button class="debug-btn small" data-action="score-left-minus">-1</button>
                </div>
                <div class="score-control">
                    <span class="score-label">Right:</span>
                    <button class="debug-btn small" data-action="score-right-plus">+1</button>
                    <button class="debug-btn small" data-action="score-right-minus">-1</button>
                </div>
                <div class="btn-row">
                    <button class="debug-btn" data-action="reset-score">Reset (0-0)</button>
                    <button class="debug-btn" data-action="set-score-10">Set 10-10</button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Ball Control</div>
                <div class="btn-row">
                    <button class="debug-btn success" data-action="ball-add">Add Ball</button>
                    <button class="debug-btn danger" data-action="ball-remove">Remove Ball</button>
                    <button class="debug-btn" data-action="ball-reset">Reset to 1</button>
                </div>
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="debug-btn" data-action="ball-speed-multiply">Speed x2</button>
                    <button class="debug-btn" data-action="ball-speed-divide">Speed /2</button>
                    <button class="debug-btn" data-action="ball-freeze">
                        <span class="status-indicator inactive" data-freeze-indicator></span>
                        Freeze
                    </button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Time Control</div>
                <div class="btn-row">
                    <button class="debug-btn" data-action="time-slow">Slow (0.5x)</button>
                    <button class="debug-btn" data-action="time-fast">Fast (2x)</button>
                    <button class="debug-btn success" data-action="time-normal">Normal (1x)</button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Skills</div>
                <div class="skill-control">
                    <span class="skill-label">Left Player:</span>
                    <button class="debug-btn small" data-action="skill-left-smash" data-skill-left-smash>Smash</button>
                    <button class="debug-btn small" data-action="skill-left-dash" data-skill-left-dash>Dash</button>
                </div>
                <div class="skill-control">
                    <span class="skill-label">Right Player:</span>
                    <button class="debug-btn small" data-action="skill-right-smash" data-skill-right-smash>Smash</button>
                    <button class="debug-btn small" data-action="skill-right-dash" data-skill-right-dash>Dash</button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Debug Overlay</div>
                <button class="debug-btn" data-action="toggle-overlay">
                    <span class="status-indicator inactive" data-overlay-indicator></span>
                    Toggle Stats HUD
                </button>
            </div>
        </div>

        <div class="debug-overlay"></div>
        `;
    }


    private attachEventListeners(): void {
        // Fermeture du panel
        const closeBtn = this.element.querySelector('[data-action="close"]');
        closeBtn?.addEventListener('click', () => this.toggle());

        // Power-Ups
        this.addListener('activate-split', () => this.callbacks.onActivatePowerUp('split'));
        this.addListener('activate-blackout', () => this.callbacks.onActivatePowerUp('blackout'));
        this.addListener('activate-blackhole', () => this.callbacks.onActivatePowerUp('blackhole'));
        this.addListener('activate-random', () => this.callbacks.onActivatePowerUp('random'));
        this.addListener('clear-powerups', () => this.callbacks.onClearPowerUps());

        // Score
        this.addListener('score-left-plus', () => this.callbacks.onScoreChange('left', 1));
        this.addListener('score-left-minus', () => this.callbacks.onScoreChange('left', -1));
        this.addListener('score-right-plus', () => this.callbacks.onScoreChange('right', 1));
        this.addListener('score-right-minus', () => this.callbacks.onScoreChange('right', -1));
        this.addListener('reset-score', () => this.callbacks.onResetScore());
        this.addListener('set-score-10', () => this.callbacks.onSetScore(10, 10));

        // Balls
        this.addListener('ball-add', () => this.callbacks.onBallControl('add'));
        this.addListener('ball-remove', () => this.callbacks.onBallControl('remove'));
        this.addListener('ball-reset', () => this.callbacks.onBallControl('reset'));
        this.addListener('ball-speed-multiply', () => this.callbacks.onBallSpeedControl('multiply'));
        this.addListener('ball-speed-divide', () => this.callbacks.onBallSpeedControl('divide'));
        this.addListener('ball-freeze', () => {
            this.callbacks.onBallSpeedControl('freeze');
            this.isFrozen = !this.isFrozen;
            this.updateFreezeIndicator();
        });

        // Time
        this.addListener('time-slow', () => {
            this.callbacks.onTimeControl('slow');
            this.timeScale = 0.5;
        });
        this.addListener('time-fast', () => {
            this.callbacks.onTimeControl('fast');
            this.timeScale = 2;
        });
        this.addListener('time-normal', () => {
            this.callbacks.onTimeControl('normal');
            this.timeScale = 1;
        });

        // Overlay
        this.addListener('toggle-overlay', () => {
            this.callbacks.onToggleOverlay();
            this.overlayVisible = !this.overlayVisible;
            this.updateOverlayIndicator();

            const overlay = this.element.querySelector('.debug-overlay') as HTMLElement;
            if (overlay) {
                overlay.style.display = this.overlayVisible ? 'block' : 'none';
            }
        });

        // Skills
        this.addListener('skill-left-smash', () => {
            this.callbacks.onChangeSkill('left', 'smash');
            this.updateSkillButtons();
        });
        this.addListener('skill-left-dash', () => {
            this.callbacks.onChangeSkill('left', 'dash');
            this.updateSkillButtons();
        });
        this.addListener('skill-right-smash', () => {
            this.callbacks.onChangeSkill('right', 'smash');
            this.updateSkillButtons();
        });
        this.addListener('skill-right-dash', () => {
            this.callbacks.onChangeSkill('right', 'dash');
            this.updateSkillButtons();
        });

        this.updateSkillButtons();
    }

    private addListener(action: string, callback: () => void): void {
        const el = this.element.querySelector(`[data-action="${action}"]`);
        if (!el) return;

        const handler = (() => callback()) as EventListener;
        el.addEventListener('click', handler);
        this.listeners.push({ el, handler });
    }

    private updateFreezeIndicator(): void {
        const indicator = this.element.querySelector('[data-freeze-indicator]');
        if (indicator) {
            indicator.className = `status-indicator ${this.isFrozen ? 'active' : 'inactive'}`;
        }
    }

    private updateOverlayIndicator(): void {
        const indicator = this.element.querySelector('[data-overlay-indicator]');
        if (indicator) {
            indicator.className = `status-indicator ${this.overlayVisible ? 'active' : 'inactive'}`;
        }
    }

    private updateSkillButtons(): void {
        const leftSmash = this.element.querySelector('[data-skill-left-smash]');
        const leftDash = this.element.querySelector('[data-skill-left-dash]');
        const rightSmash = this.element.querySelector('[data-skill-right-smash]');
        const rightDash = this.element.querySelector('[data-skill-right-dash]');

        if (leftSmash && leftDash) {
            leftSmash.classList.toggle('active', this.selectedSkills.left === 'smash');
            leftDash.classList.toggle('active', this.selectedSkills.left === 'dash');
        }

        if (rightSmash && rightDash) {
            rightSmash.classList.toggle('active', this.selectedSkills.right === 'smash');
            rightDash.classList.toggle('active', this.selectedSkills.right === 'dash');
        }
    }

    private setupDragging(): void {
        const header = this.element.querySelector('.debug-header') as HTMLElement;
        const panel = this.element.querySelector('.debug-panel') as HTMLElement;
        if (!header || !panel) return;

        const onMouseDown = (e: MouseEvent) => {
            if ((e.target as HTMLElement).classList.contains('debug-close')) return;
            
            this.isDragging = true;
            const rect = panel.getBoundingClientRect();
            this.dragOffsetX = e.clientX - rect.left;
            this.dragOffsetY = e.clientY - rect.top;
            
            header.style.cursor = 'grabbing';
        };

        const onMouseMove = (e: MouseEvent) => {
            if (!this.isDragging) return;

            this.posX = e.clientX - this.dragOffsetX;
            this.posY = e.clientY - this.dragOffsetY;

            this.posX = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, this.posX));
            this.posY = Math.max(0, Math.min(window.innerHeight - 100, this.posY));

            panel.style.left = `${this.posX}px`;
            panel.style.top = `${this.posY}px`;
        };

        const onMouseUp = () => {
            this.isDragging = false;
            header.style.cursor = 'move';
        };

        header.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        this.listeners.push(
            { el: header, handler: onMouseDown as EventListener },
            { el: window as any, handler: onMouseMove as EventListener },
            { el: window as any, handler: onMouseUp as EventListener }
        );
    }

    cleanup(): void {
        this.destroyed = true;

        for (const { el, handler } of this.listeners) {
            el.removeEventListener('click', handler);
        }
        this.listeners = [];

        if (this.closeBtn && this.closeHandler) {
            this.closeBtn.removeEventListener('click', this.closeHandler);
            this.closeBtn = undefined;
            this.closeHandler = undefined;
        }

        if (this.boundKeydown) {
            window.removeEventListener('keydown', this.boundKeydown);
            this.boundKeydown = undefined;
        }

        this.element.innerHTML = '';
    }
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/LoadingView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Layout } from "./Layout";

/**
 * Vue de chargement affichÃ©e pendant le lazy loading des chunks
 */
export const LoadingView = (): string => {
	const content = `
		<style>
			@keyframes spin {
				0% { transform: rotate(0deg); }
				100% { transform: rotate(360deg); }
			}

			@keyframes pulse-slow {
				0%, 100% { opacity: 0.4; }
				50% { opacity: 1; }
			}

			.loading-spinner {
				width: 80px;
				height: 80px;
				border: 4px solid rgba(59, 130, 246, 0.1);
				border-top: 4px solid rgba(59, 130, 246, 1);
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}

			.loading-dots span {
				animation: pulse-slow 1.4s ease-in-out infinite;
			}

			.loading-dots span:nth-child(2) {
				animation-delay: 0.2s;
			}

			.loading-dots span:nth-child(3) {
				animation-delay: 0.4s;
			}
		</style>

		<div class="flex-1 flex flex-col items-center justify-center px-4 py-12">
			<div class="text-center">
				<!-- Spinner -->
				<div class="loading-spinner mx-auto mb-8"></div>

				<!-- Texte de chargement -->
				<div class="pixel-font text-2xl text-blue-400 mb-4 loading-dots">
					LOADING<span>.</span><span>.</span><span>.</span>
				</div>

				<!-- Message optionnel -->
				<p class="pixel-font text-sm text-blue-300 opacity-60">
					Preparing your experience
				</p>
			</div>
		</div>
	`;

	return Layout.render(content, {
		showBackButton: false,
		showFooter: false
	});
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/index.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { PongGame } from './PongGame/PongGame';
import { ComponentRegistry } from './ComponantManager';
import { JoinTournamentComponent } from './JoinTournament';

export function registerComponents(): void
{
    ComponentRegistry.register('pong-game', PongGame)
    ComponentRegistry.register('joinTournament', JoinTournamentComponent)
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Header.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ComponentProps } from './types';
import { Button } from './Button';

interface HeaderProps extends ComponentProps {
    isLogged?: boolean
}

export function Header({ 
	className = '',
	isLogged = false
}: HeaderProps): string {

	const baseClass = `
		container flex justify-between
		gap-4 py-4 px-8 mt-4 ml-auto mr-auto
		rounded-xl
		bg-orange-600
		${className}
	`.replace(/\s+/g, ' ').trim();
	
	return `
		<header class="${baseClass}">
			<h1 class="text-2xl text-white">Pongers!</h1>
			${isLogged ? 
				Button({
					children: "Profile",
					id: "profileBtn",
					variant: "secondary",
					size: "md",
					href: ""
				})
					:
				Button({
					children: "Login",
					id: "loginBtn",
					variant: "secondary",
					size: "md",
					href: "/login"
				})
			}
		</header>
	`;
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Button.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ComponentProps } from './types';
import { renderChildren } from './types';

// ============= BUTTON DE BASE =============
interface ButtonProps extends ComponentProps {
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
    size?: 'sm' | 'md' | 'lg';
    href?: string;
}

export function Button({ 
    children, 
    variant = 'primary', 
    size = 'md',
    href,
    className = '',
    id
}: ButtonProps): string {
    const variants = {
        primary: 'bg-blue-500 hover:bg-blue-600 text-white',
        secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-800',
        danger: 'bg-red-500 hover:bg-red-600 text-white',
        default: ''
    };
    
    const sizes = {
        sm: 'px-3 py-1 text-sm',
        md: 'px-4 py-2',
        lg: 'px-6 py-3 text-lg'
    };
    
    const baseClass = `
        ${variants[variant]}
        ${sizes[size]}
        rounded-lg font-medium transition-colors cursor-pointer
        relative block w-fit
        ${className}
    `.replace(/\s+/g, ' ').trim();
    
    const content = renderChildren(children);
    
    if (href) {
        return `<a href="${href}" id=${id} class="${baseClass}">${content}</a>`;
    }
    
    return `<button id=${id} class="${baseClass}">${content}</button>`;
}

// ============= SETTINGS BUTTON =============
interface SettingsButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
}

export function SettingsButton({ 
    className = '', 
    size = 'md' 
}: SettingsButtonProps = {}): string {
    return Button({
        children: "âš™ï¸",
        variant: "default",
        size: size,
        href: "/settings",
        className: className,
        id: "settings-button"
    });
}

// ============= SKIN BUTTON =============
interface SkinButtonProps extends ButtonProps {
    showLabel?: boolean;
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
}

export function SkinButton({ 
    className = '', 
    size = 'md',
    showLabel = true,
    variant = 'default'
}: SkinButtonProps = {}): string {
    const buttonContent = showLabel ? "ğŸ¨" : "ğŸ¨";
    
    return Button({
        children: buttonContent,
        variant: variant,
        size: size,
        href: "/customization",
        className: className,
        id: "skin-button"
    });
}

// ============= COFFEE BUTTON =============
interface CoffeeButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
    showIcon?: boolean;
}

export function CoffeeButton({ 
    className = '', 
    size = 'md',
    showIcon = true
}: CoffeeButtonProps = {}): string {
    const content = showIcon ? "â˜• Buy me a Coffee" : "Buy me a Coffee";
    
    return Button({
        children: content,
        variant: "default",
        size: size,
        href: "/cafe",
        className: `bg-yellow-500 hover:bg-yellow-600 ${className}`,
        id: "coffee-button"
    });
}

// ============= BACK BUTTON =============
interface BackButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
    text?: string;
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
}

export function BackButton({ 
    className = '', 
    size,
    text = "â†",
    variant = 'default'
}: BackButtonProps = {}): string {
    return `
        <button 
            id="back-button"
            class="
                ${variant === 'primary' ? 'bg-blue-500 hover:bg-blue-600 text-white' : ''}
                ${variant === 'secondary' ? 'bg-gray-200 hover:bg-gray-300 text-gray-800' : ''}
                ${variant === 'danger' ? 'bg-red-500 hover:bg-red-600 text-white' : ''}
                ${size === 'sm' ? 'px-3 py-1 text-sm' : ''}
                ${size === 'md' ? 'px-4 py-2' : ''}
                ${size === 'lg' ? 'px-6 py-3 text-lg' : ''}
                rounded-lg font-medium transition-colors cursor-pointer
                relative block w-fit
                ${className}
            "
        >
            ${text}
        </button>
    `;
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/core/renderer3D.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Paddle } from "../entities/Paddle";
import { Ball } from "../entities/Ball";
import { Scoreboard } from "../entities/Scoreboard";
import { CelebrationSphere } from "../entities/CelebrationSphere";
import { PowerUpEffects } from "../entities/PowerUpEffects";
import type { Scene } from "@babylonjs/core";
import type { Game3DState, PowerUpsState } from "../types";
import { PowerUp } from "../entities/powerUp";
import { NetworkManager } from "../network/NetworkManager";
export class Renderer3D {
	private scene: Scene;
	
	// Entities
	private paddleLeft!: Paddle;
	private paddleRight!: Paddle;
	private balls: Map<string, Ball> = new Map();
	private scoreboard!: Scoreboard;
	private celebrationSphere!: CelebrationSphere;
	private powerUpMeshes: Map<string, PowerUp> = new Map(); //todo add !
	
	
	private currentState!: Game3DState;
	private powerUpEffects!: PowerUpEffects;
	private networkManager: NetworkManager;
	
	private lastScore = { left: 0, right: 0 };
	
	private lastBlackholeActive = false;
	private lastBlackoutLeft = false;
	private lastBlackoutRight = false;

	constructor(scene: Scene, networkManager: NetworkManager) {
		this.scene = scene;
		this.networkManager = networkManager;
		this.createInitialEntities();
	}

	private createInitialEntities(): void {
		this.paddleLeft = new Paddle(this.scene, 'left');
		this.paddleRight = new Paddle(this.scene, 'right');
		this.scoreboard = new Scoreboard(this.scene);
		this.celebrationSphere = new CelebrationSphere(this.scene);
		this.powerUpEffects = new PowerUpEffects(this.scene);
	}


	public updateFromState(state: Game3DState): void {
		this.currentState = state;
		if (this.paddleLeft) {
			this.paddleLeft.updateFromState(state.paddleLeft, this.smashOffsetX?.('left'));
		}
		if (this.paddleRight) {
			this.paddleRight.updateFromState(state.paddleRight, this.smashOffsetX?.('right'));
		}
		this.updateBalls(state.balls);
		this.updatePowerUps(state.powerUpState);
		// update scoreboard
		if (this.scoreboard && state.score) {
			if (state.score.left !== this.lastScore.left || state.score.right !== this.lastScore.right) {
				if (state.score.left > this.lastScore.left) {
					this.celebrationSphere.update();
				} else if (state.score.right > this.lastScore.right) {
					this.celebrationSphere.update();
				}
				
				this.scoreboard.updateScore(state.score.left, state.score.right);
				this.lastScore.left = state.score.left;
				this.lastScore.right = state.score.right;
			}
		}
	}

	private smashOffsetX = (side: 'left' | 'right'): number => {
		const skillType = side === 'left' ? this.currentState.selectedSkills.left : this.currentState.selectedSkills.right;
		if (skillType !== 'smash') 
		{
			return 0;
		}

		const skillState = side === 'left' ? this.currentState.skillStates.left : this.currentState.skillStates.right;
		const dur = 0.12;
		const dt = Math.max(0, this.currentState.clock - skillState.lastActivationAt);

		if (dt <= 0 || dt > dur) 
		{
			return 0;
		}
		const t = dt / dur;
		const amp = 0.5;
		const dir = side === 'left' ? 1 : -1;
		return dir * amp * Math.sin(Math.PI * t);
	};

	private updateBalls(ballStates: any[]): void {
		const currentBallIds = new Set(ballStates.map(b => b.id) || 'main');
		const existingBallIds = new Set(this.balls.keys());

		for (const id of existingBallIds) {
			if (!currentBallIds.has(id)) {
				const ball = this.balls.get(id);
				ball?.dispose();
				this.balls.delete(id);
			}
		}

		ballStates.forEach((ballState, index) => {
			const id = ballState.id || `main-${index}`;
			let ball = this.balls.get(id);
			if (!ball) {
				ball = new Ball(this.scene, id);
				this.balls.set(id, ball);
			}
			ball.updateFromState(ballState);
		});
	}

	private updatePowerUps(state: PowerUpsState): void {
		const currentPowerUpIds = new Set<string>();

		for (let i = 0; i < state.allPowerUps.length; i++) {
			const powerUp = state.allPowerUps[i];
			const id = `powerup-${powerUp.type}-${Math.round(powerUp.x * 100)}-${Math.round(powerUp.y * 100)}`;;
			currentPowerUpIds.add(id);

			let mesh = this.powerUpMeshes.get(id);

			if (!mesh) {
				mesh = new PowerUp(this.scene, id, powerUp);
				this.powerUpMeshes.set(id, mesh);
			}
			mesh.updateState(powerUp);
			mesh.update();
		}

		for (const [id, mesh] of this.powerUpMeshes.entries()) {
			if (!currentPowerUpIds.has(id)) {
				mesh.dispose();
				this.powerUpMeshes.delete(id);
			}
		}

		// Blackhole activation
		if (state.blackholeActive && !this.lastBlackholeActive) {
			this.powerUpEffects.triggerBlackholeEffect();
		}

		// Blackhole deactivation
		if (!state.blackholeActive && this.lastBlackholeActive) {
			this.powerUpEffects.resetBlackholeEffect();
		}
		
		this.lastBlackholeActive = state.blackholeActive;
		
		// Blackout activation
		if (state.blackoutLeft && this.networkManager.getSide() === 'left' && !this.lastBlackoutLeft) {
			this.powerUpEffects.activateBlackoutEffect('left');
		}
		if (state.blackoutRight && this.networkManager.getSide() === 'right' && !this.lastBlackoutRight) {
			this.powerUpEffects.activateBlackoutEffect('right');
		}
		this.lastBlackoutLeft = state.blackoutLeft;
		this.lastBlackoutRight = state.blackoutRight;

		// Blackout deactivation
		if (!state.blackoutLeft && this.networkManager.getSide() === 'left') {
			this.powerUpEffects.restoreVisibilityAfterBlackout();
		}
		if (!state.blackoutRight && this.networkManager.getSide() === 'right') {
			this.powerUpEffects.restoreVisibilityAfterBlackout();
		}

		// Per frame update (only helix now)
		this.powerUpEffects.update();
	}

	public render(): void {
		this.scene.render();
	}

	public getCurrentState(): Game3DState {
		return this.currentState;
	}

	public dispose(): void {
		this.paddleLeft?.dispose();
		this.paddleRight?.dispose();
		this.scoreboard?.dispose();
		this.celebrationSphere?.dispose();
		this.balls.forEach(ball => ball.dispose());
		this.balls.clear();
		this.powerUpMeshes.forEach(p => p.dispose());
		this.powerUpMeshes.clear();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/core/sceneManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// todo: add shadows
// todo: optimize imports
// todo: add gates material
// todo: add camera intro animation
// todo: add stadium loading error handling
// todo: maybe add more types for environment

import '@babylonjs/loaders';
import { Animation, ArcRotateCamera, AxesViewer, Color3, CubicEase, DirectionalLight, EasingFunction, Engine, GlowLayer, HemisphericLight, Mesh, MeshBuilder, Scene, SceneLoader, StandardMaterial, Texture, Vector3 } from '@babylonjs/core';
import { CAMERA, MATERIALS } from '../constants';

export class SceneManager {
	private scene: Scene;
	private camera: ArcRotateCamera;
	private cameraViewMode: 'overhead' | 'fps' = 'overhead';
	private environment: {
		skybox: Mesh;
		stadium: {
			ground: Mesh | null;
			group_border: Mesh | null;
			gates: {
				cables: Mesh[] | null;
				poleCylinders: Mesh[] | null;
				poleTops: Mesh[] | null;
				poleMids: Mesh[] | null;
				poleBots: Mesh[] | null;
			} | null;
			groundTexture: Mesh[] | null;
		} | null;
	};
	private lights: {
		ambient: HemisphericLight;
		main: DirectionalLight;
	};
	private engine: Engine;
	private canvas: HTMLCanvasElement;
	// private axisHelper: AxesViewer; // dev

	constructor(engine: Engine, canvas: HTMLCanvasElement) {
		this.engine = engine;
		this.canvas = canvas;
		this.scene = this.createScene();
		this.camera = this.setupCamera();
		this.lights = this.setupLights();
		this.environment = this.setupEnvironment();
		// this.axisHelper = this.setupAxisHelper(); // dev
	}
	
	private createScene(): Scene {
		const scene = new Scene(this.engine);
		// OPTI
		scene.autoClear = true;
		scene.autoClearDepthAndStencil = true;
		scene.skipPointerMovePicking = true;
		return scene;
	}

	private setupCamera(): ArcRotateCamera {
		const camera = new ArcRotateCamera(
			'mainCamera',
			CAMERA.INITIAL_ALPHA,
			CAMERA.INITIAL_BETA,
			CAMERA.INITIAL_RADIUS,
			new Vector3(CAMERA.TARGET.x, CAMERA.TARGET.y, CAMERA.TARGET.z),
			this.scene
		);
		// camera.attachControl(this.canvas, true); //dev to move camera with drag
		// camera.lowerRadiusLimit = 10;// dev
		// camera.upperRadiusLimit = 400;// dev
		
		return camera;
	}

	private setupLights(): typeof this.lights {
		const ambientLight = new HemisphericLight('ambientLight', new Vector3(0, 1, 0), this.scene);
		const mainLight = new DirectionalLight('mainLight', new Vector3(-1, -2, -1), this.scene);
		mainLight.position = new Vector3(20, 40, 20);
		mainLight.intensity = 0.7;
		// todo shadows
		return {
			ambient: ambientLight,
			main: mainLight
		};
	}

	private setupEnvironment(): typeof this.environment {
		const skybox = this.createSkybox();
		const environment = {
			skybox: skybox,
			stadium: null as {
				ground: Mesh | null;
				group_border: Mesh | null;
				gates: {
					cables: Mesh[] | null;
					poleCylinders: Mesh[] | null;
					poleTops: Mesh[] | null;
					poleMids: Mesh[] | null;
					poleBots: Mesh[] | null;
				} | null,
				groundTexture: Mesh[] | null;
			} | null
		};

		this.createStadium().then((stadium) => {
			environment.stadium = stadium || null;
		});
		return environment;
	}

	private createSkybox(): Mesh {
		const skybox = MeshBuilder.CreateSphere('skybox', { diameter: 150, sideOrientation: Mesh.BACKSIDE }, this.scene);
		// Material
		const skyboxMaterial = new StandardMaterial('skyboxMat', this.scene);
		const skyboxTexture = new Texture('/assets/textures/skysphere_bg.png', this.scene);

		// Texture
		skyboxTexture.uScale = 8;
		skyboxTexture.vScale = 5;
		skyboxTexture.wAng = Math.PI;
		
		// Properties
		skyboxMaterial.diffuseTexture = skyboxTexture;
		skyboxMaterial.emissiveTexture = skyboxTexture;
		skyboxMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);
		skyboxMaterial.backFaceCulling = false;
		skyboxMaterial.specularColor = new Color3(0, 0, 0);
		skyboxMaterial.disableLighting = true;
		skybox.material = skyboxMaterial;

		return skybox;
	}

	private async createStadium(): Promise<{ ground: Mesh | null; group_border: Mesh | null; gates: { cables: Mesh[] | null; poleCylinders: Mesh[] | null; poleTops: Mesh[] | null; poleMids: Mesh[] | null; poleBots: Mesh[] | null; } | null; groundTexture: Mesh[] | null }> {
		await SceneLoader.ImportMeshAsync('', '/assets/models/', 'stadium.gltf', this.scene);

		const ground = this.scene.getMeshByName('ground') as Mesh | null;
		const group_border = this.scene.getMeshByName('group_border') as Mesh | null;
		const blackholeHelix = this.scene.getMeshByName('blacholeHelix') as Mesh | null;

		// Ground material
		if (ground) {
			const groundMaterial = new StandardMaterial('groundMat', this.scene);
			groundMaterial.diffuseColor = Color3.FromHexString('#0A6219');
			groundMaterial.alpha = 0.7;
			groundMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
			ground.material = groundMaterial;
			ground.receiveShadows = true;
		}

		// Border material
		if (group_border) {
			const borderGroundMaterial = new StandardMaterial('borderMat', this.scene);
			borderGroundMaterial.diffuseColor = Color3.FromHexString("#353535");
			borderGroundMaterial.specularColor = Color3.FromHexString(MATERIALS.BORDER);
			group_border.material = borderGroundMaterial;
		}

		// Gates structure
		const gates = {
			cables: this.getMeshesByPrefix('cable'),
			poleCylinders: this.getMeshesByPrefix('poleCylinder'),
			poleTops: this.getMeshesByPrefix('poleTop'),
			poleMids: this.getMeshesByPrefix('poleMid'),
			poleBots: this.getMeshesByPrefix('poleBot'),
		};
		
		this.colorCables(gates.cables);
		this.colorPoleCylinders(gates.poleCylinders);
		this.colorPoleTops(gates.poleTops);
		this.colorPoleMids(gates.poleMids);
		this.colorPoleBots(gates.poleBots);

		const groundTexture = this.createGroundTexture();

		if (blackholeHelix) {
			const helixMaterial = new StandardMaterial('blackholeHelixMat', this.scene);
			helixMaterial.diffuseColor = Color3.FromHexString('#000000');
			helixMaterial.emissiveColor = Color3.FromHexString('#000000').scale(0.8);
			helixMaterial.specularColor = Color3.FromHexString('#000000');
			helixMaterial.alpha = 0;
			blackholeHelix.material = helixMaterial;
		}
		return { ground, group_border, gates, groundTexture };
	}

	private getMeshesByPrefix(prefix: string): Mesh[] | null {
		const meshes = this.scene.meshes.filter((mesh: any) => typeof mesh.name === 'string' && mesh.name.startsWith(prefix)) as Mesh[];
		return meshes.length > 0 ? meshes : null;
	}

	private createGroundTexture(): Mesh[] {
		const textures: Mesh[] = [];
		const textureElements = ['centerCircle', 'centerCircleInner', 'lineMid', 'lineBorderLeft', 'lineBorderRight', 'lineBorderTop', 'lineBorderBot'];
		const whiteTexture = new StandardMaterial('whiteLineMat', this.scene);
		whiteTexture.diffuseColor = Color3.FromHexString('#FFFFFF');
		const centerInnerColorBlack = new StandardMaterial('centerInnerBlackMat', this.scene);
		centerInnerColorBlack.diffuseColor = Color3.Black();
		centerInnerColorBlack.specularColor = Color3.Black();
		centerInnerColorBlack.emissiveColor = Color3.Black();
		centerInnerColorBlack.disableLighting = true;
		centerInnerColorBlack.alpha = 0;

		for (const element of textureElements) {
			const texture = this.scene.getMeshByName(element) as Mesh | null;
			if (texture) {
				texture.material = texture.name === 'centerCircleInner' ? centerInnerColorBlack : whiteTexture;
				textures.push(texture);
			}
		}
		return textures;
	}
	
	private colorCables(cables: Mesh[] | null): void {
		if (!cables) return;
		const cableMaterial = new StandardMaterial('cableMat', this.scene);
		cableMaterial.diffuseColor = Color3.FromHexString(MATERIALS.CABLE);
		cableMaterial.alpha = 0.4;
		cableMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
		cables.forEach(cable => {
			cable.material = cableMaterial;
		});
	}
	
	private colorPoleCylinders(poleCylinders: Mesh[] | null): void {
		if (!poleCylinders) return;
		const poleCylinderMaterial = new StandardMaterial('poleCylinderMat', this.scene);
		poleCylinderMaterial.diffuseColor = Color3.FromHexString(MATERIALS.poleCylinder);
		poleCylinders.forEach(poleCylinder => {
			poleCylinder.material = poleCylinderMaterial;
		});
	}
	
	private colorPoleTops(poleTops: Mesh[] | null): void {
		if (!poleTops) return;
		const poleTopMaterial = new StandardMaterial('poleTopMat', this.scene);
		poleTopMaterial.diffuseColor = Color3.FromHexString(MATERIALS.poleTop).scale(1.5);
		poleTopMaterial.specularColor = Color3.White();
		poleTopMaterial.specularPower = 128;
		poleTopMaterial.emissiveColor = Color3.FromHexString(MATERIALS.poleTop).scale(0.3);
		poleTops.forEach(poleTop => {
			poleTop.material = poleTopMaterial;
		});
	}
	
	private colorPoleMids(poleMids: Mesh[] | null): void {
		if (!poleMids) return;
		const poleMidMaterial = new StandardMaterial('poleMidMat', this.scene);
		poleMidMaterial.diffuseColor = Color3.FromHexString(MATERIALS.poleMid);
		poleMids.forEach(poleMid => {
			poleMid.material = poleMidMaterial;
		});
	}
	
	private colorPoleBots(poleBots: Mesh[] | null): void {
		if (!poleBots) return;
		const poleBotMaterial = new StandardMaterial('poleBotMat', this.scene);
		poleBotMaterial.diffuseColor = Color3.FromHexString(MATERIALS.poleBot);
		poleBots.forEach(poleBot => {
			poleBot.material = poleBotMaterial;
		});
	}
	// private setupAxisHelper(): AxesViewer { //dev
	// 	const axisHelper = new AxesViewer(this.scene, 1);
	// 	return axisHelper;
	// }

	public playCameraIntro(): void {
		const startHorizontalRotation = CAMERA.ANIMATION.START_ALPHA;
		const startVerticalAngle = CAMERA.ANIMATION.START_BETA;
		const startDistance = CAMERA.ANIMATION.START_RADIUS;

		const finalHorizontalRotation = CAMERA.ANIMATION.END_ALPHA;
		const finalVerticalAngle = CAMERA.ANIMATION.END_BETA;
		const finalDistance = CAMERA.ANIMATION.END_RADIUS;

		this.camera.alpha = startHorizontalRotation;
		this.camera.beta = startVerticalAngle;
		this.camera.radius = startDistance;

		// CREATE ANIMATIONS
		const horizontalRotationAnimation = new Animation(
			'cameraHorizontalRotation',
			'alpha',
			60,//fps
			Animation.ANIMATIONTYPE_FLOAT,
			Animation.ANIMATIONLOOPMODE_CONSTANT
		);
		const verticalAngleAnimation = new Animation(
			'cameraVerticalAngle',
			'beta',
			60,
			Animation.ANIMATIONTYPE_FLOAT,
			Animation.ANIMATIONLOOPMODE_CONSTANT
		);
		const distanceAnimation = new Animation(
			'cameraDistance',
			'radius',
			60,
			Animation.ANIMATIONTYPE_FLOAT,
			Animation.ANIMATIONLOOPMODE_CONSTANT
		);
		
		// KEYFRAMES
		const horizontalRotationKeys = [
			{ frame: 0, value: startHorizontalRotation },
			{ frame: CAMERA.ANIMATION.DURATION_FRAMES, value: finalHorizontalRotation }
		];
		const verticalAngleKeys = [
			{ frame: 0, value: startVerticalAngle },
			{ frame: CAMERA.ANIMATION.DURATION_FRAMES, value: finalVerticalAngle }
		];
		const distanceKeys = [
			{ frame: 0, value: startDistance },
			{ frame: CAMERA.ANIMATION.DURATION_FRAMES, value: finalDistance }
		];
		
		horizontalRotationAnimation.setKeys(horizontalRotationKeys);
		verticalAngleAnimation.setKeys(verticalAngleKeys);
		distanceAnimation.setKeys(distanceKeys);
		
		// EASING
		const easingFunction = new CubicEase();
		easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEOUT);
		horizontalRotationAnimation.setEasingFunction(easingFunction);
		verticalAngleAnimation.setEasingFunction(easingFunction);
		distanceAnimation.setEasingFunction(easingFunction);
		
		// START ANIMATION
		this.camera.animations = [horizontalRotationAnimation, verticalAngleAnimation, distanceAnimation];
		this.scene.beginAnimation(this.camera, 0, CAMERA.ANIMATION.DURATION_FRAMES, false);
	}

	public toggleCameraView(playerSide: 'left' | 'right' | 'spectator'): void {
		if (this.cameraViewMode === 'overhead') {
			this.cameraViewMode = 'fps';
			this.camera.alpha = playerSide === 'left' ? CAMERA.FPS_ALPHA + Math.PI : CAMERA.FPS_ALPHA;
			this.camera.beta = CAMERA.FPS_BETA;
			this.camera.radius = CAMERA.FPS_RADIUS;
		} else {
			this.cameraViewMode = 'overhead';
			this.camera.alpha = CAMERA.INITIAL_ALPHA;
			this.camera.beta = CAMERA.INITIAL_BETA;
			this.camera.radius = CAMERA.INITIAL_RADIUS;
		}
	}

	public getCamera(): ArcRotateCamera {
		return this.camera;
	}

	public getEnvironment(): typeof this.environment {
		return this.environment;
	}

	public getScene(): Scene {
		return this.scene;
	}

	public dispose(): void {
		this.environment.stadium?.ground?.dispose();
		this.environment.stadium?.group_border?.dispose();
		this.environment.stadium?.gates?.cables?.forEach(mesh => mesh.dispose());
		this.environment.stadium?.gates?.poleCylinders?.forEach(mesh => mesh.dispose());
		this.environment.stadium?.gates?.poleTops?.forEach(mesh => mesh.dispose());
		this.environment.stadium?.gates?.poleMids?.forEach(mesh => mesh.dispose());
		this.environment.stadium?.gates?.poleBots?.forEach(mesh => mesh.dispose());
		this.environment.skybox.dispose();
		// this.axisHelper.dispose(); // dev
		this.lights.main.dispose();
		this.lights.ambient.dispose();
		this.camera.dispose();
		this.scene.dispose();
		this.engine.dispose();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/core/game3DEngine.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Engine } from '@babylonjs/core';
import { SceneManager } from './sceneManager';
import { Renderer3D } from './renderer3D';
import { InputSystem } from '../systems/InputSystem';
import { NetworkManager } from '../network/NetworkManager';
import { UIManager } from '../ui/UIManager';
import { StateAdapter } from '../utils/StateAdapter';
import type { TimeoutStatus, GameStatusInfo } from '../types';

export class Game3DEngine {
	private engine: Engine;
	private sceneManager: SceneManager;
	private renderer!: Renderer3D;
	private canvas: HTMLCanvasElement;
	private roomId: string;
	private isRunning: boolean = false;

	public gameStatusInfo: GameStatusInfo = {
		isPaused: false,
		isGameOver: false,
		winner: '',
		countdownValue: 0,
		score: { left: 0, right: 0 }
	};

	private timeoutStatus: TimeoutStatus = {
		leftActive: false,
		leftRemainingMs: 0,
		rightActive: false,
		rightRemainingMs: 0
	};

	private gameOverHandled: boolean = false;

	// systems
	private inputSystem!: InputSystem;
	private networkManager!: NetworkManager;
	private uiManager!: UIManager;

	constructor(canvas: HTMLCanvasElement) {
		this.canvas = canvas;
		this.roomId = this.getRoomIdFromURL();
		
		this.engine = new Engine(canvas, true, {
			preserveDrawingBuffer: false,
			stencil: false,
			antialias: true,
			powerPreference: 'high-performance'
		});
		
		this.sceneManager = new SceneManager(this.engine, canvas);
		this.initializeSystems();
	}

	private getRoomIdFromURL(): string { // todo needs better secu
		return (window.location.pathname.split('/').pop() || '');
	}

	private initializeSystems(): void {
		this.inputSystem = new InputSystem(this.canvas);
		this.networkManager = new NetworkManager(this.roomId);
		this.uiManager = new UIManager();
		this.inputSystem.initialize();
		this.setupNetworkCallbacks();
		this.renderer = new Renderer3D(this.sceneManager.getScene(), this.networkManager);
	}

	private setupNetworkCallbacks(): void {
		this.networkManager.onStateUpdate = (serverState) => {
			this.gameStatusInfo = StateAdapter.getStatusInfo(serverState);
			const game3DState = StateAdapter.toGame3DState(serverState);
			this.renderer.updateFromState(game3DState);
		};

		this.networkManager.onPaused = () => {
			this.gameStatusInfo.isPaused = true;
			this.timeoutStatus = {
				leftActive: false,
				leftRemainingMs: 0,
				rightActive: false,
				rightRemainingMs: 0
			};
		};

		this.networkManager.onResumed = () => {
			this.gameStatusInfo.isPaused = false;
		};

		this.networkManager.onTimeoutStatus = (status) => {
			this.timeoutStatus = {
				leftActive: status.left.active,
				leftRemainingMs: status.left.remainingMs,
				rightActive: status.right.active,
				rightRemainingMs: status.right.remainingMs
			};
		};

		this.networkManager.onCountdown = (v) => {
			this.gameStatusInfo.countdownValue = v;
		};

		this.networkManager.onWelcome = (side, playerNames) => {
			this.uiManager.updatePlayerNames(side, playerNames);
			this.timeoutStatus = {
				leftActive: false,
				leftRemainingMs: 0,
				rightActive: false,
				rightRemainingMs: 0
			};
		};

		this.networkManager.onGameOver = (winner, isTournament, tournamentId) => {
			if (this.gameOverHandled) return;
			this.gameOverHandled = true;
			// Make sure internal status reflects game over so UIManager.render won't show pause overlays
			this.gameStatusInfo.isGameOver = true;
			this.gameStatusInfo.isPaused = false;
			this.gameStatusInfo.countdownValue = 0;
			
			const forfeitBtn = document.getElementById('forfeit-btn') as HTMLButtonElement;
			if (forfeitBtn) {
				forfeitBtn.disabled = true;
			}
			
			const amILeft = this.networkManager.getSide() === 'left';
			const didIWin = (winner === 'left' && amILeft) || (winner === 'right' && !amILeft);

			if (isTournament && tournamentId) {
				// ensure any generic pause/countdown overlay is removed so tournament overlay is visible
				this.uiManager.clearOverlayById('generic-overlay');
				const overlay = this.uiManager.handleTournamentGameOver(didIWin, this.gameStatusInfo.score!);
				document.body.appendChild(overlay);
				setTimeout(() => {
					sessionStorage.removeItem('gameWsURL');
					window.router.navigate(`/tournament/${tournamentId}`); // wip redirection to 3D tournament
					document.body.removeChild(overlay);
				}, 3000);
				return;
			}
			// ensure any generic pause/countdown overlay is removed so game-over overlay is visible
			this.uiManager.clearOverlayById('generic-overlay');
			const overlay = this.uiManager.showGameOver(didIWin, this.gameStatusInfo.score!);
			document.body.appendChild(overlay);
			overlay.addEventListener('click', (e) => {
				const target = e.target as HTMLElement;
				if (target.id === 'return-to-lobby' || target.closest('#return-to-lobby')) {
					e.stopPropagation();
					sessionStorage.removeItem('gameWsURL');
					document.body.removeChild(overlay);
					window.router?.navigateTo('/play');
				}
			});
		};
	}

	// start
	public start(): void {
		if (this.isRunning) return;
		this.isRunning = true;

		this.engine.runRenderLoop(() => {
			if (!this.isRunning) return;
			this.update();
			this.render();
		});
		this.sceneManager.playCameraIntro();
		this.networkManager.connect();
		this.setupForfeitButton();

		window.addEventListener('resize', this.handleResize);
	}
	
	private setupForfeitButton(): void {
		const forfeitBtn = document.getElementById('forfeit-btn');
		if (forfeitBtn) {
			forfeitBtn.addEventListener('click', this.handleForfeit);
		}
	}

	private update(): void {
		const input = this.inputSystem.getInput();
		
		this.networkManager.sendInput(input);

		// SPACE KEY
		if (this.inputSystem.isSkillKeyPressed()) {
			this.networkManager.useSkill();
		}

		// V KEY
		if (this.inputSystem.isCameraToggleKeyPressed()) {
			this.sceneManager.toggleCameraView(this.networkManager.getSide());
		}
	}

	private handleResize = (): void => {
		this.engine.resize();
	}

	private handleForfeit = (): void => {
		const confirmed = confirm('Are you sure you want to forfeit the game?');
		if (confirmed)
			this.networkManager.forfeit();
	}

	private render(): void {
		this.uiManager.render(
			this.gameStatusInfo,
			this.timeoutStatus,
			this.networkManager.getSide(),
			this.renderer.getCurrentState()
		);
		this.renderer.render();
	}

	public pause(): void {
		this.isRunning = false;
	}

	public resume(): void {
		if (this.isRunning) return;
		this.isRunning = true;
	}

	public dispose(): void {
		this.isRunning = false;
		this.engine.stopRenderLoop();
		this.uiManager.dispose();
		
		const forfeitBtn = document.getElementById('forfeit-btn');
		if (forfeitBtn) {
			forfeitBtn.removeEventListener('click', this.handleForfeit);
		}
		
		this.inputSystem.dispose();
		this.networkManager.disconnect();
		
		this.renderer.dispose();
		this.sceneManager.dispose();
		this.engine.dispose();
		
		window.removeEventListener('resize', this.handleResize);
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/utils/mathHelper.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { BALL_3D } from "../constants";

export function ballConverter2DXto3DX(x2d: number): number {
	return (x2d - 1920 / 2) * BALL_3D.SCALE_3D;
}

export function ballConverter2DYto3DZ (y2d: number): number {
	return -(y2d - 1080 / 2) * BALL_3D.SCALE_3D;
}

// could change later
export function powerUpConverter2DXto3DX(x2d: number): number {
	return (x2d - 1920 / 2) * BALL_3D.SCALE_3D;
}

export function powerUpConverter2DYto3DZ (y2d: number): number {
	return -(y2d - 1080 / 2) * BALL_3D.SCALE_3D;
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/utils/StateAdapter.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { PublicState } from '../../../net/wsClient';
import type { Game3DState, BallState, PaddleState, GameStatusInfo } from '../types';

export class StateAdapter {
	public static toGame3DState(serverState: PublicState): Game3DState {
		return {
			paddleLeft: this.convertPaddle(serverState.leftPaddle),
			paddleRight: this.convertPaddle(serverState.rightPaddle),
			balls: this.convertBalls(serverState.balls),
			score: serverState.score,
			selectedSkills: serverState.selectedSkills,
			skillStates: serverState.skillStates,
			clock: serverState.clock,
			powerUpState: this.convertPowerUps(serverState)
		};
	}

	private static convertPaddle(paddle: { y: number; speed: number; intention: number }): PaddleState {
		return {
			y: paddle.y,
			speed: paddle.speed,
			intention: paddle.intention
		};
	}

	private static convertBalls(balls: { x: number; y: number; vx: number; vy: number; radius: number }[]): BallState[] {
		return balls.map((ball, index) => ({
			id: `ball-${index}`,
			x: ball.x,
			y: ball.y,
			z: 0,
			vx: ball.vx,
			vy: ball.vy,
			vz: 0,
			speed: Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy),
		}));
	}

	private static convertPowerUps(serverState: PublicState) {
		return {
			allPowerUps: serverState.powerUps,
			splitActive: serverState.splitActive,
			clock: serverState.clock,
			blackoutLeft: serverState.blackoutLeft,
			blackoutRight: serverState.blackoutRight,
			blackoutLeftIntensity: serverState.blackoutLeftIntensity,
			blackoutRightIntensity: serverState.blackoutRightIntensity,
			blackholeActive: serverState.blackholeActive,
			blackholeProgress: serverState.blackholeProgress,
			blackholeCenterX: serverState.blackholeCenterX,
			blackholeCenterY: serverState.blackholeCenterY
		}
	}

	public static getStatusInfo(serverState: PublicState): GameStatusInfo {
		return {
			isPaused: serverState.isPaused,
			isGameOver: serverState.isGameOver,
			winner: serverState.winner,
			countdownValue: serverState.countdownValue,
			score: serverState.score
		}
	}

	public static getExtendedInfo(serverState: PublicState) {
		return {
			isPaused: serverState.isPaused,
			isGameOver: serverState.isGameOver,
			winner: serverState.winner,
			countdownValue: serverState.countdownValue,
			powerUps: serverState.powerUps,
			splitActive: serverState.splitActive,
			blackoutLeft: serverState.blackoutLeft,
			blackoutRight: serverState.blackoutRight,
			blackoutLeftIntensity: serverState.blackoutLeftIntensity,
			blackoutRightIntensity: serverState.blackoutRightIntensity,
			blackholeActive: serverState.blackholeActive,
			blackholeProgress: serverState.blackholeProgress,
			blackholeCenterX: serverState.blackholeCenterX,
			blackholeCenterY: serverState.blackholeCenterY,
			selectedSkills: serverState.selectedSkills,
			skillStates: serverState.skillStates,
			clock: serverState.clock
		};
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/ui/UIManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { GameStatusInfo, TimeoutStatus, Game3DState} from "../types";

export class UIManager {
	private previousCount: number = 0;

	constructor() {
	}

	public updatePlayerNames(side: 'left' | 'right' | 'spectator', playerNames?: { left?: string; right?: string }): void {
		const leftNameEl = document.getElementById('player-left-name');
		const rightNameEl = document.getElementById('player-right-name');
		
		if (leftNameEl && playerNames?.left) {
			leftNameEl.textContent = side === 'left' 
				? `${playerNames.left} ğŸ‘ˆ (You)` 
				: playerNames.left;
		}
		
		if (rightNameEl && playerNames?.right) {
			rightNameEl.textContent = side === 'right' 
				? `${playerNames.right} ğŸ‘ˆ (You)` 
				: playerNames.right;
		}
	}

	public showGameOver(didIWin: boolean, score: { left: number; right: number }): HTMLElement {

		const overlay = document.createElement('div');
		overlay.id = 'game-over-overlay';
		overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="bg-[#0C154D]/90 border-2 border-white/20 rounded-lg p-8 text-center max-w-md">
				<h2 class="text-4xl font-bold mb-4 ${didIWin ? 'text-green-400' : 'text-red-400'}">
					${didIWin ? 'ğŸ† VICTOIRE !' : 'ğŸ’€ DÃ‰FAITE'}
				</h2>
				<p class="text-white/80 text-xl mb-6">
					Score: ${score.left} - ${score.right}
				</p>
				<button 
					id="return-to-lobby"
					class="px-6 py-3 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg text-white font-semibold transition-all cursor-pointer"
				>
					Retour au lobby
				</button>
			</div>
		`;
		return overlay;
	}

	public handleTournamentGameOver(didIWin: boolean, score: { left: number; right: number }): HTMLElement {
		// Handle tournament-specific game over logic here
		const overlay = document.createElement('div');
		overlay.id = 'tournament-game-over-overlay';
		overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="bg-[#0C154D]/90 border-2 border-white/20 rounded-lg p-8 text-center max-w-md">
				<h2 class="text-4xl font-bold mb-4 ${didIWin ? 'text-green-400' : 'text-red-400'}">
					${didIWin ? 'ğŸ† VICTOIRE TOURNAMENT!' : 'ğŸ’€ DÃ‰FAITE TOURNAMENT!'}
				</h2>
				<p class="text-white/80 text-xl mb-6">
					Score: ${score.left} - ${score.right}
				</p>
				<button 
					id="return-to-lobby"
					class="px-6 py-3 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg text-white font-semibold transition-all cursor-pointer"
				>
					Retour au lobby
				</button>
			</div>
		`;
		return overlay;
	}

	private updateSkillOverlay(side: 'left' | 'right' | 'spectator', state: Game3DState | null): void {
		console.log('Updating skill overlay for side:', side);
		if (!state) return;
		console.log('Received game state');
		const isBlackout = side === 'left' ? state.powerUpState.blackoutLeft : state.powerUpState.blackoutRight;
		if (isBlackout) return;
		const skillState = side === 'left' ? state.skillStates.left : state.skillStates.right;
		const skillType = side === 'left' ? state.selectedSkills.left : state.skillStates.right;
		const cooldown = skillType === 'smash' ? 3 : 5;
		const progress = skillState.cooldownRemaining > 0
			? Math.max(0, Math.min(1, 1 - skillState.cooldownRemaining / cooldown))
			: 1;
		const currentLoader = document.querySelector('.skillLoader') as HTMLElement;
		if (currentLoader) {
			const step = Math.floor(progress * 6);
			console.log('Skill loader step:', step);
			let backgroundSize: string = '';
			const color = step == 6 ? '#00e676': '#ffcc00'
			switch (step) {
				case 0:
					backgroundSize = '0% 0%';
					break;
				case 1:
					backgroundSize = '0% 0%';
					break;
				case 2:
					backgroundSize = '20% 20%';
					break;
				case 3:
					backgroundSize = '40% 40%';
					break;
				case 4:
					backgroundSize = '60% 60%';
					break;
				case 5:
					backgroundSize = '80% 80%';
					break;
				case 6:
					backgroundSize = '100% 100%';
					break;
				default:
					backgroundSize = '100% 100%';
			}
			currentLoader.style.setProperty('--skill-gradient-color', color);
			currentLoader.style.backgroundSize = backgroundSize;
		}
	}
	
	public render(gameStatusInfo: GameStatusInfo, timeoutStatus: TimeoutStatus, side: 'left' | 'right' | 'spectator', state: Game3DState): void {
		if (gameStatusInfo.isGameOver) {
			this.clearOverlayById('generic-overlay');
			return;
		}

		this.updateSkillOverlay(side, state);

		let overlay: HTMLElement;
		let text: string = '';
		if ((gameStatusInfo.countdownValue ?? 0) > 0) {
			if (this.previousCount === gameStatusInfo.countdownValue) return;
			this.previousCount = gameStatusInfo.countdownValue ?? 0;
			text = `${gameStatusInfo.countdownValue}`;
		} else if (gameStatusInfo.isPaused) {
			const iAmLeft = side === 'left';
			const opponentDisconnected = iAmLeft ? timeoutStatus.rightActive : timeoutStatus.leftActive;
			const opponentRemainingMs = iAmLeft ? timeoutStatus.rightRemainingMs : timeoutStatus.leftRemainingMs;
			if (opponentDisconnected && opponentRemainingMs > 0) {
				const secondsRemaining = Math.ceil(opponentRemainingMs / 1000);
				text = `âš ï¸ <span style="color:#ff4d4f">Opponent disconnected.</span> <br> Forfeit in ${secondsRemaining}s`;
			} else {
				text = 'Game Paused';
			}
		}
		if (text.length > 0) {
			overlay = this.generateOverlay(text);
			if (!document.body.contains(overlay)) {
				document.body.appendChild(overlay);
			}
		} else {
			this.clearOverlayById('generic-overlay');
			this.previousCount = 0;
		}
	}

	private generateOverlay(text: string): HTMLElement {
		const existing = document.getElementById('generic-overlay');
		if (existing) {
			const genericText = existing.querySelector('.generic-text');
			if (genericText) {
				genericText.innerHTML = text;
			}
			return existing;
		}
		
		const overlay = document.createElement('div');
		overlay.id = 'generic-overlay';
		overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="p-8 text-center max-w-md">
				<h2 class="text-2xl font-bold text-white mb-4 generic-text">
					${text}
				</h2>
			</div>
		`;
		return overlay;
	}
	
	public clearOverlayById(overlayId: string): void {
		const existing = document.getElementById(overlayId);
		if (existing && existing.parentElement) {
			existing.parentElement.removeChild(existing);
		}
	}

	public clearAllOverlays(): void {
		this.clearOverlayById('generic-overlay');
		this.clearOverlayById('game-over-overlay');
		this.clearOverlayById('tournament-game-over-overlay');
	}

	public dispose(): void {
		this.clearAllOverlays();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/Game3d.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Game3DEngine } from './core/game3DEngine';

interface Game3DConfig {
	wsURL?: string;
	roomId?: string;
}

export class Game3D {
	private canvas: HTMLCanvasElement;
	private gameEngine?: Game3DEngine;
	private config: Game3DConfig;

	constructor(element: HTMLElement) {
		console.log('[game3d] initializing...');

		//CANVAS
		const canvasElem = element.querySelector('#game3d-canvas') as HTMLCanvasElement;
		if (!canvasElem) throw new Error('[game3d] error: canvas not found');
		this.canvas = canvasElem;
		this.config = this.getConfiguration();
		this.initalizeEngine();
	}

	private initalizeEngine(): void {
		try {
			this.gameEngine = new Game3DEngine(this.canvas);
			this.gameEngine.start();
		} catch (error) {
			this.showError('Failed to initialize 3D game. Please refresh the page.');
		}

	}

	private getConfiguration(): Game3DConfig {
		const storedUrl = sessionStorage.getItem('gameWsURL');
		let findRoomId = null;
		if (!storedUrl) {
			const host = import.meta.env.VITE_HOST;
			const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
			findRoomId = window.location.pathname.split('/').pop();
			const fallbackUrl = host && endpoint && findRoomId ? `wss://${host}${endpoint}/${findRoomId}` : undefined;
			return {
				wsURL: fallbackUrl || undefined,
				roomId: findRoomId || undefined
			};
		}
		return {
			wsURL: storedUrl ? storedUrl : undefined,
			roomId: findRoomId || undefined
		};
	}
	
	//todo verify if its ok to use the innerHtml
	private showError(message: string): void {
		const overlay = document.createElement('div');
		overlay.className = 'fixed inset-0 bg-black/80 flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="bg-red-900/50 border-2 border-red-500 rounded-lg p-8 text-center max-w-md">
				<h2 class="text-2xl font-bold text-red-400 mb-4">Error</h2>
				<p class="text-white mb-6">${message}</p>
				<button 
					onclick="window.location.reload()" 
					class="px-6 py-3 bg-red-600 hover:bg-red-700 rounded-lg text-white font-semibold"
				>
					Reload Page
				</button>
			</div>
		`;
		document.body.appendChild(overlay);
	}

	public cleanup(): void {
		console.log('[game3d] disposing...');
		if (this.gameEngine) {
			this.gameEngine.dispose();
			this.gameEngine = null as any;
		}
		sessionStorage.removeItem('gameWsURL');
	}
}


export function Game3dComponent(): string {
	
	return `
		<style>
			@keyframes gridMove {
				0% { transform: translateY(0); }
				100% { transform: translateY(50px); }
			}
			
			@keyframes neonPulse {
				0%, 100% { 
					text-shadow: 
						0 0 10px rgba(59, 130, 246, 0.8),
						0 0 20px rgba(59, 130, 246, 0.6),
						0 0 30px rgba(59, 130, 246, 0.4);
				}
				50% { 
					text-shadow: 
						0 0 20px rgba(59, 130, 246, 1),
						0 0 30px rgba(59, 130, 246, 0.8),
						0 0 40px rgba(59, 130, 246, 0.6);
				}
			}
			
			@keyframes scanline {
				0% { transform: translateY(-100%); }
				100% { transform: translateY(100vh); }
			}

			@keyframes glitch {
				0%, 100% { transform: translate(0); }
				20% { transform: translate(-2px, 2px); }
				40% { transform: translate(-2px, -2px); }
				60% { transform: translate(2px, 2px); }
				80% { transform: translate(2px, -2px); }
			}
			
			.pixel-font {
				font-family: 'Courier New', monospace;
				font-weight: bold;
				letter-spacing: 0.1em;
			}
			
			.neon-border {
				box-shadow: 
					0 0 10px rgba(59, 130, 246, 0.5),
					inset 0 0 10px rgba(59, 130, 246, 0.2);
				border: 3px solid rgba(59, 130, 246, 0.8);
			}

			.neon-border-green {
				box-shadow: 
					0 0 10px rgba(34, 197, 94, 0.5),
					inset 0 0 10px rgba(34, 197, 94, 0.2);
				border: 3px solid rgba(34, 197, 94, 0.8);
			}

			.neon-border-red {
				box-shadow: 
					0 0 10px rgba(239, 68, 68, 0.5),
					inset 0 0 10px rgba(239, 68, 68, 0.2);
				border: 3px solid rgba(239, 68, 68, 0.8);
			}

			.game-hud {
				background: rgba(4, 7, 26, 0.85);
				backdrop-filter: blur(10px);
			}

			.player-info {
				transition: all 0.3s ease;
			}

			.player-info:hover {
				transform: translateY(-2px);
			}

			#pong-canvas {
				box-shadow: 
					0 0 30px rgba(59, 130, 246, 0.4),
					0 0 60px rgba(59, 130, 246, 0.2),
					inset 0 0 30px rgba(59, 130, 246, 0.1);
				border: 3px solid rgba(59, 130, 246, 0.6);
			}

			.action-button {
				transition: all 0.2s ease;
				position: relative;
				overflow: hidden;
			}

			.action-button::before {
				content: '';
				position: absolute;
				top: 50%;
				left: 50%;
				width: 0;
				height: 0;
				border-radius: 50%;
				background: rgba(255, 255, 255, 0.1);
				transform: translate(-50%, -50%);
				transition: width 0.6s, height 0.6s;
			}

			.action-button:hover::before {
				width: 300px;
				height: 300px;
			}

			.action-button:active {
				transform: scale(0.95);
			}

			.forfeit-button:hover {
				box-shadow: 
					0 0 20px rgba(239, 68, 68, 0.6),
					inset 0 0 20px rgba(239, 68, 68, 0.3);
			}

			.status-indicator {
				animation: neonPulse 2s ease-in-out infinite;
			}

			.game-container {
				animation: fadeIn 0.8s ease-out;
			}

			@keyframes fadeIn {
				from { opacity: 0; transform: scale(0.95); }
				to { opacity: 1; transform: scale(1); }
			}

			.corner-decoration {
				position: absolute;
				width: 20px;
				height: 20px;
			}

			.corner-decoration-blue {
				border: 2px solid rgba(59, 130, 246, 0.5);
			}

			.corner-decoration-green {
				border: 2px solid rgba(34, 197, 94, 0.5);
			}

			.corner-decoration-red {
				border: 2px solid rgba(239, 68, 68, 0.5);
			}

			.corner-tl { top: -2px; left: -2px; border-right: none; border-bottom: none; }
			.corner-tr { top: -2px; right: -2px; border-left: none; border-bottom: none; }
			.corner-bl { bottom: -2px; left: -2px; border-right: none; border-top: none; }
			.corner-br { bottom: -2px; right: -2px; border-left: none; border-top: none; }

			.stat-good { color: #4ade80; }
			.stat-medium { color: #fbbf24; }
			.stat-bad { color: #ef4444; }
		</style>
		<div class="fixed inset-0 w-full h-full" data-component="game3d">

			<!-- Header HUD -->
			<div class="game-hud border-b border-white/10">
				<div class="container mx-auto px-4 py-4">
					<div class="flex items-center justify-between gap-4">
						<!-- Left: Back button -->
						<button 
							onclick="window.router.goBack()" 
							class="action-button pixel-font px-4 py-2 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all text-sm"
							id="back-button"
						>
							<span class="relative z-10">â† EXIT</span>
						</button>

							<!-- Player 1 Name -->
						<div id="player-left-name" class="text-xl font-bold text-white drop-shadow-lg mx-4">Player 1</div>

						<!-- Center: Status indicator -->
						<div class="flex items-center gap-3">
							<div id="connection-indicator" class="status-indicator w-3 h-3 bg-green-400 rounded-full"></div>
							<span class="pixel-font text-sm text-blue-300">
								LIVE MATCH
							</span>
						</div>

							<!-- Player 2 Name -->
						<div id="player-right-name" class="text-xl font-bold text-white drop-shadow-lg mx-4">Player 2</div>

						<!-- Right: Forfeit button (si pas mode local) -->
						<button 
							id="forfeit-btn"
							class="action-button forfeit-button pixel-font px-4 py-2 neon-border-red bg-red-500/10 text-red-400 hover:bg-red-500/20 transition-all text-sm relative z-10"
						>
							<span class="relative z-10">ğŸ³ï¸ SURRENDER</span>
						</button>
					</div>
				</div>
			</div>

			<canvas id="game3d-canvas" class="w-full h-full block"></canvas>
			
				<!-- skill indicator -->
			<div id="game3d-ui-skill">
				<div id="game3d-skill-container" class="fixed left-1/2 bottom-6 transform -translate-x-1/2 z-50 pointer-events-none">
					<div class="flex flex-col items-center">
						<div id="skill-wrapper" class="skillLoader" aria-hidden="true"></div>
						<div id="skill-cooldown" class="mt-2 text-white/90 text-sm select-none">Skill cooldown</div>
					</div>
				</div>
			</div>
			<style id="game3d-ui-styles">
				:root {
					--skill-gradient-color: #00e676;
				}

				.skillLoader {
					width: 120px;
					height: 60px;
					border-radius: 200px 200px 0 0;
					-webkit-mask: repeating-radial-gradient(farthest-side at bottom ,#0000 0,#000 1px 12%,#0000 calc(12% + 1px) 20%);
					background: radial-gradient(farthest-side at bottom, var(--skill-gradient-color) 0 95%,#0000 0) bottom/0% 0% no-repeat #ddd;
					background-size: 100% 100%;
				}
			</style>

			<!-- Camera View Indicator -->
			<div class="absolute bottom-4 right-4 px-3 py-2 bg-black/50 text-white text-sm rounded pointer-events-none">
				Press <span class="font-bold text-cyan-400">V</span> to toggle camera view
			</div>
			<!-- Global Css -->
			<style>
				@keyframes fadeIn {
				from {
					opacity: 0;
					transform: scale(0.9);
				}
				to {
					opacity: 1;
					transform: scale(1);
				}
				}
				.animate-fade-in {
					animation: fadeIn 0.3s ease-out;
				}
			</style>
		</div>
	`;
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/rendering/materialManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Scene, StandardMaterial } from "@babylonjs/core";

export class MaterialManager {
	private scene: Scene;
	private materials: Map<string, StandardMaterial> = new Map();

	constructor(scene: Scene) {
		this.scene = scene;
	}

	public dispose(): void {
		this.materials.forEach((material) => {
			material.dispose();
		});
		this.materials.clear();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/types.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Mesh, Vector3 } from '@babylonjs/core';

export interface Game3DState {
	paddleLeft: PaddleState;
	paddleRight: PaddleState;
	balls: BallState[];
	score: {
		left: number;
		right: number;
	};
	selectedSkills: {
		left: 'smash' | 'dash';
		right: 'smash' | 'dash';
	};
	skillStates: {
		left: {cooldownRemaining: number; lastActivationAt: number};
		right: {cooldownRemaining: number; lastActivationAt: number};
	};
	clock: number;
	powerUpState: PowerUpsState;
}

export interface IEntity {
	id: string;
	mesh?: Mesh;
	position: Vector3;
	update(deltaTime: number): void;
	dispose(): void;
}

export interface IRenderable {
	render(): void;
	setVisibility(visible: boolean): void;
}

export interface PaddleState {
	y: number;
	z?: number;
	speed?: number;
	velocity?: number;
	intention?: number;
}

export interface BallState {
	id: string;
	x: number;
	y: number;
	z: number;
	vx: number;
	vy: number;
	vz: number;
	speed: number;
}

export interface PowerUpsState {
	allPowerUps: {x: number, y: number, radius: number, type: string}[];
	splitActive: boolean;
	clock: number;
	blackoutLeft: boolean;
	blackoutRight: boolean;
	blackoutLeftIntensity: number;
	blackoutRightIntensity: number;
	blackholeActive: boolean;
	blackholeProgress: number;
	blackholeCenterX: number;
	blackholeCenterY: number;
}

export interface ISystem {
	initialize(): void;
	update(): void;
	dispose(): void;
}

export interface InputState {
	up: boolean;
	down: boolean;
	left: boolean;
	right: boolean;
}

export interface GameStatusInfo {
	isPaused?: boolean;
	countdownValue?: number;
	isGameOver?: boolean;
	winner?: '' | 'left' | 'right';
	score?: {left: number; right: number};
}


export interface TimeoutStatus {
	leftActive: boolean;
	leftRemainingMs: number;
	rightActive: boolean;
	rightRemainingMs: number;
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/entities/Ball.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Scene } from "@babylonjs/core/scene";
import { Entity } from "./Entity";
import { Color3, MeshBuilder, StandardMaterial } from "@babylonjs/core";
import type { BallState } from "../types";
import { BALL_3D } from "../constants";
import { ballConverter2DXto3DX, ballConverter2DYto3DZ } from "../utils/mathHelper";

export class Ball extends Entity {
	constructor(scene: Scene, id: string) {
		super(scene, id);
		this.createMesh();
	}

	private createMesh(): void {
		this.mesh = MeshBuilder.CreateSphere(this.id, { diameter: BALL_3D.DIAMETER * BALL_3D.SCALE_3D }, this.scene);
		const material = new StandardMaterial(`ball-mat-${this.id}`, this.scene);
		material.diffuseColor = Color3.FromHexString('#FFFFFF');
		this.mesh.material = material;
	}

	public updateFromState(state: BallState): void {
		if (!this.mesh) return;
		const x3d = ballConverter2DXto3DX(state.x);
		const z3d = ballConverter2DYto3DZ(state.y);

		this.mesh.position.x = x3d;
		this.mesh.position.y = (BALL_3D.START_POSY * 2) * BALL_3D.SCALE_3D;
		this.mesh.position.z = z3d;
	}

	public update(): void {
		if (!this.mesh) return;
	}

	public dispose(): void {
		super.dispose();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/entities/Entity.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Scene, Mesh, Vector3 } from '@babylonjs/core';
import type { IEntity, IRenderable } from '../types';

// base class for 3D entities
export abstract class Entity implements IEntity, IRenderable {
	public id: string;
	public mesh?: Mesh
	public position: Vector3;
	protected scene: Scene;
	protected isDisposed: boolean = false;
	
	constructor(scene: Scene, id: string) {
		this.scene = scene;
		this.id = id;
		this.position = new Vector3(0, 0, 0);
	}

	abstract update(): void;

	public setPosition(x: number, y: number, z: number): void {
		this.position.set(x, y, z);
		if (this.mesh) {
			this.mesh.position.copyFrom(this.position);
			// or this.mesh.position = this.position; //wip
		}
	}

	public setVisibility(visible: boolean): void {
		if (this.mesh) {
			this.mesh.isVisible = visible;
		}
	}

	public render(): void {}

	public isEntityDisposed(): boolean {
		return this.isDisposed;
	}

	public dispose(): void {
		if (this.isDisposed) return;
		this.isDisposed = true;
		if (this.mesh) {
			if (this.mesh.material) {
				this.mesh.material.dispose();
			}
			this.mesh.dispose();
			this.mesh = undefined;
		}
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/entities/PowerUpEffects.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Scene, Mesh, MeshBuilder, StandardMaterial, Color3, ParticleSystem, Quaternion, Vector3, Color4, Animation} from "@babylonjs/core";

export class PowerUpEffects {
	private scene: Scene;

	constructor(scene: Scene) {
		this.scene = scene;
	}

	public activateBlackoutEffect(side: 'left' | 'right'): void {
		this.scene.meshes.forEach(mesh => {
			if (mesh.name.startsWith('ball')) return;
			if (side === 'right' && mesh.name === 'paddle-right') return;
			if (side === 'left' && mesh.name === 'paddle-left') return;
			if (mesh.name === 'centerCircle') return;
			if (mesh.name.startsWith('line')) return;
			if (!mesh.isDisposed()) {
				mesh.isVisible = false;
			}
		});
	}

	public restoreVisibilityAfterBlackout(): void {
		this.scene.meshes.forEach(mesh => {
			if (!mesh.isDisposed()) {
				mesh.isVisible = true;
			}
		});
	}

	public triggerBlackholeEffect(): void {
		const inner = this.scene.getMeshByName('centerCircleInner') as Mesh;
		const border = this.scene.getMeshByName('centerCircle') as Mesh;
		const helix = this.scene.getMeshByName('blacholeHelix') as Mesh;

		if (inner.material && inner.material instanceof StandardMaterial) {
			const alphaAnim = new Animation("blackhole-inner-alpha-in", "alpha", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
			alphaAnim.setKeys([
				{ frame: 0, value: inner.material.alpha },
				{ frame: 30, value: 1 }
			]);
			inner.material.animations = [alphaAnim];
			this.scene.beginAnimation(inner.material, 0, 30, false);
		}

		if (helix.material && helix.material instanceof StandardMaterial) {
			const alphaAnim = new Animation("blackhole-helix-alpha-in", "alpha", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
			alphaAnim.setKeys([
				{ frame: 0, value: helix.material.alpha },
				{ frame: 30, value: 0.5 }
			]);
			helix.material.animations = [alphaAnim];
			this.scene.beginAnimation(helix.material, 0, 30, false);
		}

		if (border.material && border.material instanceof StandardMaterial) {
			const colorAnim = new Animation("blackhole-core-to-black", "diffuseColor", 30, Animation.ANIMATIONTYPE_COLOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
			colorAnim.setKeys([
				{ frame: 0, value: (border.material as StandardMaterial).diffuseColor },
				{ frame: 30, value: Color3.Black() }
			]);
			border.material.animations = [colorAnim];
			this.scene.beginAnimation(border.material, 0, 30, false);
		}

		const scaleAnim = new Animation("blackhole-scale-up", "scaling", 30, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
		scaleAnim.setKeys([
			{ frame: 0, value: new Vector3(1, 1, 1) },
			{ frame: 30, value: new Vector3(5, 5, 5) }
		]);
		border.animations = [scaleAnim];
		this.scene.beginAnimation(border, 0, 30, false);
		inner.animations = [scaleAnim.clone()];
		this.scene.beginAnimation(inner, 0, 30, false);
	}

	public resetBlackholeEffect(): void {

		const inner = this.scene.getMeshByName('centerCircleInner') as Mesh;
		const border = this.scene.getMeshByName('centerCircle') as Mesh;
		const helix = this.scene.getMeshByName('blacholeHelix') as Mesh;

		const scaleAnim = new Animation("blackhole-scale-down", "scaling", 30, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
		scaleAnim.setKeys([
			{ frame: 0, value: border.scaling.clone() },
			{ frame: 30, value: new Vector3(1, 1, 1) }
		]);
		border.animations = [scaleAnim];
		this.scene.beginAnimation(border, 0, 30, false);
		inner.animations = [scaleAnim.clone()];
		this.scene.beginAnimation(inner, 0, 30, false);

		if (inner.material && inner.material instanceof StandardMaterial) {
			const alphaAnim = new Animation("blackhole-inner-alpha-out", "alpha", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
			alphaAnim.setKeys([
				{ frame: 0, value: inner.material.alpha },
				{ frame: 30, value: 0 }
			]);
			inner.material.animations = [alphaAnim];
			this.scene.beginAnimation(inner.material, 0, 30, false);
		}

		if (helix.material && helix.material instanceof StandardMaterial) {
			const alphaAnim = new Animation("blackhole-helix-alpha-out", "alpha", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
			alphaAnim.setKeys([
				{ frame: 0, value: helix.material.alpha },
				{ frame: 30, value: 0 }
			]);
			helix.material.animations = [alphaAnim];
			this.scene.beginAnimation(helix.material, 0, 30, false);
		}

		if (border.material && border.material instanceof StandardMaterial) {
			const colorAnim = new Animation("blackhole-border-to-white", "diffuseColor", 30, Animation.ANIMATIONTYPE_COLOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
			colorAnim.setKeys([
				{ frame: 0, value: (border.material as StandardMaterial).diffuseColor },
				{ frame: 30, value: Color3.FromHexString('#FFFFFF') }
			]);
			border.material.animations = [colorAnim];
			this.scene.beginAnimation(border.material, 0, 30, false);
		}
	}

	private updateBlackholeEffect(): void {
		const helix = this.scene.getMeshByName('blacholeHelix') as Mesh | null;
		if (helix) helix.rotate(Vector3.Up(), 0.1);
	}

	public update(): void {
		this.updateBlackholeEffect();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/entities/Scoreboard.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Entity } from "./Entity";
import type { Scene } from "@babylonjs/core/scene";
import { Color3, DynamicTexture, Mesh, MeshBuilder, StandardMaterial, Vector3 } from "@babylonjs/core";

export class Scoreboard extends Entity {
	private panelTextures: DynamicTexture[] = [];
	private panels: Mesh[] = [];
	private parentMesh!: Mesh;

	constructor(scene: Scene, id: string = 'scoreboard') {
		super(scene, id);
		this.createMesh();
	}

	private createMesh(): void {
		const centerPoint = new Vector3(0, 7, 0);
		this.parentMesh = MeshBuilder.CreateBox('scoreBoardParent', { size: 0.1 }, this.scene);
		this.parentMesh.position = centerPoint;
		this.parentMesh.isVisible = false;
		this.mesh = this.parentMesh;

		this.createPanels();
		this.createCylinder();
	}

	private createPanels(): void {
		const panelWidth = 4;
		const panelHeight = panelWidth * (9 / 16);
		const panelDepth = 0.03;
		const distanceFromCenter = 3;
		const panelInclinement = -0.3;

		const panelConfigs = [
			{ name: 'scorePanel1', position: new Vector3(0, 0, distanceFromCenter), rotation: 0 },
			{ name: 'scorePanel2', position: new Vector3(distanceFromCenter, 0, 0), rotation: Math.PI / 2 },
			{ name: 'scorePanel3', position: new Vector3(0, 0, -distanceFromCenter), rotation: Math.PI },
			{ name: 'scorePanel4', position: new Vector3(-distanceFromCenter, 0, 0), rotation: -Math.PI / 2 }
		];

		for (const config of panelConfigs) {
			const panel = this.createPanel(config, panelWidth, panelHeight, panelDepth, panelInclinement);
			this.panels.push(panel);
		}
	}

	private createPanel(
		config: { name: string; position: Vector3; rotation: number },
		width: number,
		height: number,
		depth: number,
		inclinement: number
	): Mesh {
		const panel = MeshBuilder.CreateBox(config.name, { width, height, depth }, this.scene);

		const holographicMaterial = new StandardMaterial(`${config.name}_holographicMat`, this.scene);
		const panelTexture = this.panelTextures.length === 0 
			? this.createScoreTexture(0, 0) 
			: this.panelTextures[0];

		// TEXTURE PROPERTIES
		panelTexture.vScale = 1;
		panelTexture.uScale = 1;

		// MAT
		holographicMaterial.diffuseTexture = panelTexture;
		holographicMaterial.diffuseColor = Color3.FromHexString('#0fb3ff');
		holographicMaterial.emissiveColor = Color3.FromHexString('#00d4ff');
		holographicMaterial.specularColor = Color3.White();
		holographicMaterial.alpha = 0.6;
		holographicMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
		holographicMaterial.backFaceCulling = true;

		// APPLY
		panel.material = holographicMaterial;
		panel.position = config.position;
		panel.rotation.y = config.rotation + Math.PI;
		panel.rotation.x = inclinement;
		panel.parent = this.parentMesh;

		// OPTI (ONE TEXTURE FOR ALL PANELS)
		if (this.panelTextures.length === 0) {
			this.panelTextures.push(panelTexture);
		}

		this.createPanelBorders(panel, width, height, depth);

		return panel;
	}

	private createPanelBorders(panel: Mesh, panelWidth: number, panelHeight: number, panelDepth: number): void {
		// MAT
		const borderMaterial = new StandardMaterial(`${panel.name}_borderMat`, this.scene);
		borderMaterial.diffuseColor = Color3.FromHexString('#192e38');
		borderMaterial.emissiveColor = new Color3(0.05, 0.05, 0.05);

		// PROPERTIES
		const borderThickness = 0.08;
		const borderDepth = panelDepth + 0.01;

		// CONFIG
		const borders = [
			{ name: 'Top', width: panelWidth + borderThickness * 2, height: borderThickness, x: 0, y: panelHeight / 2 + borderThickness / 2 },
			{ name: 'Bottom', width: panelWidth + borderThickness * 2, height: borderThickness, x: 0, y: -panelHeight / 2 - borderThickness / 2 },
			{ name: 'Left', width: borderThickness, height: panelHeight, x: -panelWidth / 2 - borderThickness / 2, y: 0 },
			{ name: 'Right', width: borderThickness, height: panelHeight, x: panelWidth / 2 + borderThickness / 2, y: 0 }
		];

		for (const border of borders) {
			const borderMesh = MeshBuilder.CreateBox(
				`${panel.name}_border${border.name}`,
				{ width: border.width, height: border.height, depth: borderDepth },
				this.scene
			);
			borderMesh.material = borderMaterial;
			borderMesh.position = new Vector3(border.x, border.y, 0);
			borderMesh.parent = panel;
		}
	}

	private createCylinder(): void {
		const cylinderMidMaterial = new StandardMaterial('cylinderMidMat', this.scene);
		cylinderMidMaterial.diffuseColor = Color3.FromHexString('#0fb3ff');
		cylinderMidMaterial.specularColor = Color3.White();
		cylinderMidMaterial.alpha = 0.4;
		cylinderMidMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
		cylinderMidMaterial.backFaceCulling = false;

		const cylinderMidInnerMaterial = new StandardMaterial('cylinderMidInnerMat', this.scene);
		cylinderMidInnerMaterial.diffuseColor = Color3.Black();
		cylinderMidInnerMaterial.specularColor = new Color3(0.1, 0.1, 0.1);

		const cylinderTopBorderMaterial = new StandardMaterial('cylinderTopBorderMat', this.scene);
		const cylinderBottomBorderMaterial = new StandardMaterial('cylinderBottomBorderMat', this.scene);
		cylinderTopBorderMaterial.diffuseColor = Color3.FromHexString('#8fdbff');
		cylinderTopBorderMaterial.emissiveColor = Color3.FromHexString('#0fb3ff');
		cylinderTopBorderMaterial.specularColor = Color3.White();
		cylinderBottomBorderMaterial.diffuseColor = Color3.FromHexString('#8fdbff');
		cylinderBottomBorderMaterial.emissiveColor = Color3.FromHexString('#0fb3ff');
		cylinderBottomBorderMaterial.specularColor = Color3.White();

		const cylinderMid = MeshBuilder.CreateCylinder('cylinderMid', { diameterTop: 3, diameterBottom: 2.5, height: 0.5, tessellation: 32 }, this.scene);
		const cylinderMidInner = MeshBuilder.CreateCylinder('cylinderMidInner', { diameterTop: 2.5, diameterBottom: 2., height: 0.5, tessellation: 32 }, this.scene);
		const cylinderTopBorder = MeshBuilder.CreateCylinder('cylinderTopBorder', { diameter: 3.1, height: 0.04, tessellation: 32 }, this.scene);
		const cylinderBottomBorder = MeshBuilder.CreateCylinder('cylinderBottomBorder', { diameter: 2.6, height: 0.04, tessellation: 32 }, this.scene);

		cylinderMid.material = cylinderMidMaterial;
		cylinderMidInner.material = cylinderMidInnerMaterial;
		cylinderTopBorder.material = cylinderTopBorderMaterial;
		cylinderBottomBorder.material = cylinderBottomBorderMaterial;

		cylinderTopBorder.position = new Vector3(0, 0.25, 0);
		cylinderBottomBorder.position = new Vector3(0, -0.25, 0);

		cylinderMid.parent = this.parentMesh;
		cylinderMidInner.parent = this.parentMesh;
		cylinderTopBorder.parent = this.parentMesh;
		cylinderBottomBorder.parent = this.parentMesh;
	}

	private createScoreTexture(scoreLeft: number = 0, scoreRight: number = 0): DynamicTexture {
		const texture = new DynamicTexture('scoreTexture', { width: 1024, height: 1024 }, this.scene, false);
		this.updateScoreTexture(texture, scoreLeft, scoreRight);
		return texture;
	}

	private updateScoreTexture(texture: DynamicTexture, scoreLeft: number, scoreRight: number): void {
		const ctx = texture.getContext() as CanvasRenderingContext2D;

		ctx.fillStyle = '#0a4d66';
		ctx.fillRect(0, 0, 1024, 1024);

		ctx.fillStyle = '#083d52';
		for (let i = 0; i < 1024; i += 8) {
			ctx.fillRect(0, i, 1024, 4);
		}

		const scoreText = `${scoreLeft} - ${scoreRight}`;
		ctx.font = 'bold 300px Arial';
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';

		ctx.strokeStyle = '#000000';
		ctx.lineWidth = 16;
		ctx.strokeText(scoreText, 512, 512);

		ctx.shadowColor = '#00ffff';
		ctx.shadowBlur = 40;
		ctx.fillStyle = '#00d4ff';
		ctx.fillText(scoreText, 512, 512);

		ctx.shadowBlur = 0;
		ctx.fillStyle = '#FFFFFF';
		ctx.fillText(scoreText, 512, 512);

		texture.update();
	}

	public updateScore(scoreLeft: number, scoreRight: number): void {
		if (this.panelTextures.length > 0) {
			this.updateScoreTexture(this.panelTextures[0], scoreLeft, scoreRight);
		}
	}

	public update(): void {
	}

	public dispose(): void {
		for (const texture of this.panelTextures) {
			texture.dispose();
		}
		this.panelTextures = [];
		this.panels = [];
		this.parentMesh.dispose();
		super.dispose();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/entities/CelebrationSphere.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Entity } from "./Entity";
import { MeshBuilder, StandardMaterial, Color4, Scene, Mesh, ParticleSystem, DynamicTexture } from "@babylonjs/core";

export class CelebrationSphere extends Entity {
	private particleSystem?: ParticleSystem;

	constructor(scene: Scene, id: string = 'celebration-sphere') {
		super(scene, id);
		this.createMesh();
		this.createParticleSystem();
	}

	private createMesh(): void {
		const sphereCelebration = MeshBuilder.CreateSphere('sphereCelebration', { diameter: 149, sideOrientation: Mesh.BACKSIDE }, this.scene);
		const sphereCelebrationMaterial = new StandardMaterial('sphereCelebrationMat', this.scene);
		sphereCelebrationMaterial.alpha = 0;
		sphereCelebrationMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
		sphereCelebration.material = sphereCelebrationMaterial;
		this.mesh = sphereCelebration;
	}

	private createParticleSystem(): void {
		if (!this.mesh) return;
		const particleSystem = new ParticleSystem('celebrationParticles', 3000, this.scene);
		const particleTexture = new DynamicTexture('particleTexture', 64, this.scene, false);
		const ctx = particleTexture.getContext() as CanvasRenderingContext2D;
		const centerX = 32;
		const centerY = 32;
		const radius = 30;
		const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
		gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
		gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)');
		gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.5)');
		gradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.1)');
		gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
		ctx.fillStyle = gradient;
		ctx.fillRect(0, 0, 64, 64);
		particleTexture.update();
		particleSystem.particleTexture = particleTexture;

		particleSystem.emitter = this.mesh;
		particleSystem.createSphereEmitter(74.5, 0); // Radius 74.5 (149/2), radiusRange 0 = surface only
		particleSystem.color1 = new Color4(2, 2, 2, 1);
		particleSystem.color2 = new Color4(2, 2, 2, 1);
		particleSystem.colorDead = new Color4(1, 1, 1, 0);
		particleSystem.minSize = 0.3;
		particleSystem.maxSize = 0.8;
		particleSystem.minLifeTime = 0.2;
		particleSystem.maxLifeTime = 0.4;
		particleSystem.emitRate = 1500;
		particleSystem.minEmitPower = 0;
		particleSystem.maxEmitPower = 0;
		particleSystem.updateSpeed = 0.02;
		particleSystem.blendMode = ParticleSystem.BLENDMODE_ADD;
		// particleSystem.stop();
		this.particleSystem = particleSystem;
	}
	
	public update(): void {
		if (!this.mesh) return;
		const material = this.mesh.material as StandardMaterial;
		material.alpha = 0;
		this.particleSystem?.start();
		setTimeout(() => {
			this.particleSystem?.stop();
		}, 2000);
	}

	public dispose(): void {
		super.dispose();
		this.particleSystem?.dispose();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/entities/powerUp.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { Color3, MeshBuilder, Scene, StandardMaterial } from "@babylonjs/core";
import { Entity } from "./Entity";
import { powerUpConverter2DXto3DX, powerUpConverter2DYto3DZ } from "../utils/mathHelper";

export class PowerUp extends Entity {
	private type: 'blackout' | 'split' | 'blackhole';
	private state: {x: number; y: number; radius: number; type: string};

	constructor(scene: Scene, id: string, state: {x: number; y: number; radius: number; type: string}) {
		super(scene, id);
		this.state = state;
		this.type = state.type as 'blackout' | 'split' | 'blackhole';
		this.createMesh();
	}

	private createMesh(): void {
		this.mesh = MeshBuilder.CreateCylinder(this.id, { 
			diameter: this.state.radius * 2 * 0.01, 
			height: 1, 
			tessellation: 32
		}, this.scene);
		
		const material = new StandardMaterial(`powerup-mat-${this.id}`, this.scene);
		material.needDepthPrePass = true;
		material.backFaceCulling = false;
		material.alpha = 0.7;

		switch (this.type) {
			case 'split':
				material.diffuseColor = Color3.FromHexString('#FFD700');
				material.emissiveColor = Color3.FromHexString('#FFD700').scale(0.6);
				material.specularColor = Color3.FromHexString('#FFEA00');
				break;
			case 'blackout':
				material.diffuseColor = Color3.FromHexString('#9B59B6');
				material.emissiveColor = Color3.FromHexString('#9B59B6').scale(0.7);
				material.specularColor = Color3.FromHexString('#E74FF0');
				break;
			case 'blackhole':
				material.diffuseColor = Color3.FromHexString('#000000');
				material.emissiveColor = Color3.FromHexString('#111111').scale(0.6);
				material.specularColor = Color3.FromHexString('#333333');
				break;
		}
		this.mesh.material = material;
	}

	public updateState(state: {x: number; y: number; radius: number; type: string}): void {
		this.state = state;
	}

	public update(): void {
		if (!this.mesh) return;
		
		const time = Date.now() * 0.001;
		
		const floatOffset = Math.sin(time * 3) * 0.15;
		this.mesh.position.x = powerUpConverter2DXto3DX(this.state.x);
		this.mesh.position.z = powerUpConverter2DYto3DZ(this.state.y);
		this.mesh.position.y = 0.9 + floatOffset;
		
		this.mesh.rotation.y += 0.015;
		
		const pulse = 1 + Math.sin(time * 4) * 0.05;
		this.mesh.scaling.set(pulse, 1, pulse);
	}

	public dispose(): void {
		super.dispose();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/entities/Paddle.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { MeshBuilder, Vector3, StandardMaterial, Color3, Scene } from '@babylonjs/core';
import { PADDLE_3D, MATERIALS } from '../constants';
import { Entity } from './Entity';
import type { PaddleState } from '../types';

export class Paddle extends Entity {
	private side: 'left' | 'right'; 

	constructor(scene: Scene, side: 'left' | 'right') {
		super(scene, `paddle-${side}`);
		this.side = side;
		this.createMesh();
	}
	
	private createMesh(): void {
		this.mesh = MeshBuilder.CreateBox(
			this.id, {
				width: PADDLE_3D.X * PADDLE_3D.SCALE_3D,
				height: PADDLE_3D.Y * PADDLE_3D.SCALE_3D,
				depth: PADDLE_3D.Z * PADDLE_3D.SCALE_3D
			}, this.scene);

		const xPos = this.side === 'left' ? (-PADDLE_3D.START_POSX - PADDLE_3D.MARGIN) * PADDLE_3D.SCALE_3D  : (PADDLE_3D.START_POSX + PADDLE_3D.MARGIN) * PADDLE_3D.SCALE_3D 
		this.mesh.position = new Vector3(xPos, PADDLE_3D.START_POSY * PADDLE_3D.SCALE_3D, PADDLE_3D.START_POSZ * PADDLE_3D.SCALE_3D);

		const material = new StandardMaterial(`paddle-mat-${this.side}`, this.scene);
		material.diffuseColor = Color3.FromHexString(MATERIALS.PADDLE_COLOR);
		this.mesh.material = material;
	}

	public updateFromState(state: PaddleState, smashOffsetX?: number): void {
		if (!this.mesh) return;
		
		this.mesh.position.z = -(state.y - 540) * 0.01;

		// SMASH OFFSET de l'enfer
		const xPos = this.side === 'left' ? (-PADDLE_3D.START_POSX - PADDLE_3D.MARGIN) * PADDLE_3D.SCALE_3D  : (PADDLE_3D.START_POSX + PADDLE_3D.MARGIN) * PADDLE_3D.SCALE_3D 
		this.mesh.position.x = xPos + (smashOffsetX || 0);
	}

	public update(): void {
		if (!this.mesh) return;
	}

	public static getPaddleIntention(keys: { [key: string]: boolean }, side: 'left' | 'right'): number {
		if (side === 'left') {
			if (keys['w'] || keys['a']) return 1;
			if (keys['s'] || keys['d']) return -1;
		} else {
			if (keys['w'] || keys['d']) return 1;
			if (keys['s'] || keys['a']) return -1;
		}
		return 0;
	}

	public dispose(): void {
		super.dispose();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/systems/InputSystem.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ISystem, InputState } from '../types';

export class InputSystem implements ISystem {
	private keys: Map<string, boolean> = new Map();
	private canvas: HTMLCanvasElement;
	private vKeyWasPressed: boolean = false;

	constructor(canvas: HTMLCanvasElement) {
		this.canvas = canvas;
	}

	public initialize(): void {
		window.addEventListener('keydown', this.onKeyDown);
		window.addEventListener('keyup', this.onKeyUp);
		
		this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
	}
	
	private onKeyDown = (event: KeyboardEvent): void => {
		this.keys.set(event.key.toLowerCase(), true);
	}

	private onKeyUp = (event: KeyboardEvent): void => {
		this.keys.set(event.key.toLowerCase(), false);
	}

	public isKeyPressed(key: string): boolean {
		return this.keys.get(key.toLowerCase()) || false;
	}

	public getInput(): InputState {
		return {
			up: this.isKeyPressed('w'),
			down: this.isKeyPressed('s'),
			left: this.isKeyPressed('a'),
			right: this.isKeyPressed('d'),
		};
	}

	public isSkillKeyPressed(): boolean {
		return this.isKeyPressed(' ');
	}

	public isCameraToggleKeyPressed(): boolean {
		const isVPressed = this.isKeyPressed('v');
		
		if (isVPressed && !this.vKeyWasPressed) {
			this.vKeyWasPressed = true;
			return true;
		}
		
		if (!isVPressed) {
			this.vKeyWasPressed = false;
		}
		
		return false;
	}

	public update(): void {
	}

	public dispose(): void {
		window.removeEventListener('keydown', this.onKeyDown);
		window.removeEventListener('keyup', this.onKeyUp);
		this.keys.clear();
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/constants.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * Game3d Constants
 * 
 * These constants define the dimensions and properties of the 3D game world
 */

// Stadium dimensions (should match your stadium.gltf model)
export const STADIUM_WIDTH = 1920;
export const STADIUM_HEIGHT = 1080;

// Paddle dimensions
export const PADDLE_DEPTH = 100; // Z-axis size
export const PADDLE_WIDTH = 15;  // X-axis thickness

// Ball properties
export const BALL_DIAMETER = 30;
export const BALL_Y_POSITION = 15; // Height above ground

// Camera settings
export const CAMERA_INTRO_DURATION = 180; // frames at 60fps = 3 seconds
export const CAMERA_DEFAULT_ALPHA = Math.PI / 2;
export const CAMERA_DEFAULT_BETA = Math.PI / 3;
export const CAMERA_DEFAULT_RADIUS = 30;

// Positions
export const PADDLE_DISTANCE_FROM_CENTER = STADIUM_WIDTH / 2 - 50;


export const WORLD_3D = {
	WIDTH: 1920,
	HEIGHT: 1080,
	DEPTH: 500,
	CAMERA_DISTANCE: 1500
} as const;

export const PADDLE_3D = {
	START_POSX: 900,
	START_POSY: 15,
	START_POSZ: 0,
	X: 15,
	Y: 15,
	Z: 100,
	MARGIN: 30,
	SPEED: 800,
	SCALE_3D: 0.01
} as const;

export const BALL_3D = {
	START_POSX: 0,
	START_POSY: 15,
	START_POSZ: 0,
	DIAMETER: 30,
	SCALE_3D: 0.01,
} as const;

export const POWERUP_3D = {
	// cylinder
	RADIUS: 10,
	HEIGHT: 5,
} as const;

export const MATERIALS = {
	PADDLE_COLOR: '#5a5a5a',
	BALL_COLOR: '#FFFFFF',
	POWERUP_SPLIT: '#FFD700',
	POWERUP_BLACKOUT: '#1522da',
	POWERUP_BLACKHOLE: '#12012e',
	BORDER: '#3CFFE2',
	CABLE: '#ADFFE6',
	poleCylinder:'#2E2E2E',
	poleTop:'#00FFBC',
	poleMid:'#2E2E2E',
	poleBot:'#2E2E2E'
} as const;

export const CAMERA = {
	INITIAL_ALPHA: -Math.PI / 2,
	INITIAL_BETA: Math.PI / 3,
	INITIAL_RADIUS: 30,
	TARGET: {
		x: 0,
		y: 0,
		z: 0
	},
	MIN_RADIUS: 10,
	MAX_RADIUS: 400,
	ANIMATION : {
		START_ALPHA: Math.PI / 2,
		END_ALPHA: -Math.PI / 2,
		START_BETA: Math.PI / 6,
		END_BETA: Math.PI / 3,
		START_RADIUS: 80,
		END_RADIUS: 30,
		DURATION_FRAMES: 180
	},
	FPS_ALPHA: 0,
	FPS_BETA: Math.PI / 2.5,
	FPS_RADIUS: 20
} as const;



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Game3d/network/NetworkManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { WSClient, type PublicState } from "../../../net/wsClient";
import type { InputState } from "../types";

export class NetworkManager  {
	private wsClient: WSClient;
	private roomId: string;
	private isConnected: boolean = false;

	// callbacks
	public onStateUpdate?: (state: PublicState) => void;
	public onWelcome?: (side: 'left' | 'right' | 'spectator', playerNames?: any) => void;
	public onGameOver?: (winner: string, isTournament?: boolean, tournamentId?: string) => void;
	public onPaused?: () => void;
	public onResumed?: () => void;
	public onCountdown?: (value: number) => void;
	public onTimeoutStatus?: (status: { left: { active: boolean; remainingMs: number }; right: { active: boolean; remainingMs: number } }) => void;

	constructor(roomId: string) {
		this.roomId = roomId;
		this.wsClient = new WSClient();
		this.setupNetworkHandlers();
	}

	private setupNetworkHandlers() {
		this.wsClient.onState = (state) => {
			if (this.onStateUpdate) {
				this.onStateUpdate(state);
			}
		}
		this.wsClient.onWelcome = (side, playerNames) => {
			this.isConnected = true;
			if (this.onWelcome) {
				this.onWelcome(side, playerNames);
			}
		}
		this.wsClient.onGameOver = (winner, isTournament, tournamentId) => {
			if (this.onGameOver) {
				this.onGameOver(winner, isTournament, tournamentId);
			}
		}
		this.wsClient.onPaused = () => {
			if (this.onPaused) {
				this.onPaused();
			}
		}

		this.wsClient.onResumed = () => {
			if (this.onResumed) this.onResumed();
		};

		this.wsClient.onCountdown = (v) => {
			if (this.onCountdown) this.onCountdown(v);
		};

		this.wsClient.onTimeoutStatus = (s) => {
			if (this.onTimeoutStatus) this.onTimeoutStatus(s);
		};
	}

	public connect(): void {
		const storedUrl = sessionStorage.getItem('gameServerURL') || undefined;
		if (storedUrl) {
			this.wsClient.connect(storedUrl);
		} else {
			const host = import.meta.env.VITE_HOST;
			const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
			const fallbackUrl = host && endpoint && this.roomId
				? `wss://${host}${endpoint}/${this.roomId}`
				: undefined;
			this.wsClient.connect(fallbackUrl);
		}
	}

	public sendInput(input: InputState): void {
		if (!this.isConnected) return;
		const side = this.wsClient.side;

		let up = false;
		let down = false;

		if (side === 'left') {
			up = input.up || input.left;
			down = input.down || input.right;
		} else {
			up = input.up || input.right;
			down = input.down || input.left;
		}
		this.wsClient.sendInput(up, down);
	}

	public useSkill(): void {
		if (!this.isConnected) return;
		this.wsClient.useSkill();
	}

	public forfeit(): void {
		if (!this.isConnected) return;
		this.wsClient.forfeit();
	}

	public getSide(): 'left' | 'right' | 'spectator' {
		return this.wsClient.side;
	}

	public disconnect(): void {
		this.wsClient.cleanup();
		this.isConnected = false;
		this.onStateUpdate = undefined;
		this.onWelcome = undefined;
		this.onGameOver = undefined;
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/JoinTournament.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ComponentProps, Component } from "./types";

interface JoinTournamentProps extends ComponentProps
{
	slots: number
}

export class JoinTournamentComponent implements Component
{
	private element: HTMLElement
	private slots: string | null

	constructor(element: HTMLElement)
	{

		this.element = element;
		this.slots = element.getAttribute('data-slots')
		this.init();
	}

	private init(): void
	{

	}
	
	cleanup(): void
	{

	}
}

export function JoinTournament({
	className = 'px-32 py-16 border-2 border-red-400 rounded-2xl cursor-pointer',
	slots
} : JoinTournamentProps) {
	const chatClasses = `${className}`

	return `
		<button class="${chatClasses}"
			data-component="joinTournament"
			data-slots=${slots}	
		>
			${slots} Players
			<span></span>
		<button>
	`
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/types.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export interface ComponentProps {
    children?: string | string[];
    className?: string;
    id?: string;
    [key: string]: any;
}

export function renderChildren(children?: string | string[]): string {
    if (!children) return '';
    return Array.isArray(children) ? children.join('') : children;
}

export interface Component
{
    cleanup(): void;
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/ComponantManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Component } from "./types";

type ComponentConstructor = new (element: HTMLElement) => Component;

export class ComponentRegistry
{
    private static components: Map<string, ComponentConstructor> = new Map();

    static register(name: string, constructor: ComponentConstructor): void
    {
        this.components.set(name, constructor);
    }

    static get(name: string): ComponentConstructor | undefined
    {
        return this.components.get(name);
    }
}

export class ComponentManager
{
    private instances: Map<HTMLElement, Component> = new Map();
    
    scanAndMount(): void
    {
        const components = document.querySelectorAll('[data-component]');
        console.log(components)
        
        components.forEach(element => {
            const componentName = element.getAttribute('data-component');
            if (!componentName) return;
            
            const ComponentClass = ComponentRegistry.get(componentName);
            
            if (ComponentClass && !this.instances.has(element as HTMLElement))
            {
                const instance = new ComponentClass(element as HTMLElement);
                this.instances.set(element as HTMLElement, instance);
            }
        });
    }
    
    cleanupAll(): void
    {
        this.instances.forEach(instance => instance.cleanup());
        this.instances.clear();
    }
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/components/Layout.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export interface LayoutOptions {
	/** Afficher le bouton Back dans le header */
	showBackButton?: boolean;
	/** Afficher le bouton Sign In dans le header */
	showSignInButton?: boolean;
	/** Contenu personnalisÃ© pour le header (remplace le header par dÃ©faut si fourni) */
	customHeader?: string;
	/** Afficher le footer */
	showFooter?: boolean;
	/** Texte personnalisÃ© pour le footer */
	footerText?: string;
	/** Afficher les particules flottantes */
	showParticles?: boolean;
	/** Nombre de particules Ã  afficher */
	particleCount?: number;
	/** Classes CSS additionnelles pour le conteneur principal */
	containerClass?: string;
}

/**
 * Composant Layout qui centralise les Ã©lÃ©ments communs Ã  toutes les pages
 * - Fond avec grille animÃ©e
 * - Effet scanline
 * - Header (configurable)
 * - Footer (configurable)
 * - Particules flottantes (optionnel)
 */
export class Layout {
	/**
	 * GÃ©nÃ¨re le HTML du layout avec le contenu fourni
	 * @param content - Contenu HTML Ã  insÃ©rer dans le layout
	 * @param options - Options de configuration du layout
	 * @returns HTML complet du layout
	 */
	static render(content: string, options: LayoutOptions = {}): string {
		const {
			showBackButton = true,
			showSignInButton = false,
			customHeader = null,
			showFooter = true,
			footerText = 'Â© 2025 PONG - SKILL ISSUE',
			showParticles = false,
			particleCount = 30,
			containerClass = ''
		} = options;

		return `
			<!-- Fond avec grille animÃ©e -->
			<div class="fixed inset-0 bg-black overflow-hidden">
				<!-- Grille de fond -->
				<div class="absolute inset-0" style="
					background-image:
						linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
						linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
					background-size: 50px 50px;
					animation: gridMove 20s linear infinite;
				"></div>

				<!-- Scanline effect -->
				<div class="absolute inset-0 pointer-events-none opacity-10">
					<div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
				</div>

				${showParticles ? this.renderParticles(particleCount) : ''}
			</div>

			<!-- Contenu principal -->
			<div class="relative z-10 min-h-screen flex flex-col ${containerClass}">
				${customHeader !== null ? customHeader : this.renderDefaultHeader(showBackButton, showSignInButton)}

				<!-- Zone centrale -->
				<div class="flex-1 flex flex-col">
					${content}
				</div>

				${showFooter ? this.renderFooter(footerText) : ''}
			</div>
		`;
	}

	/**
	 * GÃ©nÃ¨re le header par dÃ©faut
	 */
	private static renderDefaultHeader(showBackButton: boolean, showSignInButton: boolean): string {
		if (!showBackButton && !showSignInButton) {
			return '';
		}

		return `
			<header class="flex justify-between items-center px-8 py-6">
				${showBackButton ? `
					<button
						onclick="window.router.goBack()"
						class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
						id="back-button"
					>
						â† BACK
					</button>
				` : '<div></div>'}

				${showSignInButton ? `
					<a href="/login"
					   class="pixel-font bg-blue-500 opacity-80 text-black px-6 py-3 text-sm md:text-base hover:bg-blue-400 transition-all neon-border flex items-center gap-2">
						<span>SIGN IN</span>
					</a>
				` : ''}
			</header>
		`;
	}

	/**
	 * GÃ©nÃ¨re le footer
	 */
	private static renderFooter(text: string): string {
		return `
			<footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
				<p>${text}</p>
			</footer>
		`;
	}

	/**
	 * GÃ©nÃ¨re les particules flottantes
	 */
	private static renderParticles(count: number): string {
		const particles: string[] = [];

		for (let i = 0; i < count; i++) {
			const size = 2 + Math.random() * 3;
			const left = Math.random() * 100;
			const top = Math.random() * 100;
			const duration = 10 + Math.random() * 20;
			const delay = Math.random() * 5;

			particles.push(`
				<div
					class="absolute bg-blue-400 rounded-full opacity-20"
					style="
						width: ${size}px;
						height: ${size}px;
						left: ${left}%;
						top: ${top}%;
						animation: float ${duration}s ease-in-out ${delay}s infinite;
					"
				></div>
			`);
		}

		return particles.join('');
	}

	/**
	 * Helper pour crÃ©er un header personnalisÃ© type HomeView
	 */
	static renderHomeHeader(): string {
		return `
			<header class="flex justify-between items-center px-8 py-6">
				<!-- Logo PONG -->
				<div class="pixel-font text-4xl md:text-5xl text-blue-400" style="animation: neonPulse 2s ease-in-out infinite;">
					PONG
				</div>

				<!-- Bouton Connexion -->
				<a href="/login"
				   class="pixel-font bg-blue-500 opacity-80 text-black px-6 py-3 text-sm md:text-base hover:bg-blue-400 transition-all neon-border flex items-center gap-2">
					<span>SIGN IN</span>
				</a>
			</header>

			<!-- Ligne horizontale nÃ©on -->
			<div class="w-full h-1 bg-gradient-to-r from-transparent via-blue-500 to-transparent opacity-50"></div>
		`;
	}

	/**
	 * Helper pour crÃ©er un header avec status indicator (WaitingRoom)
	 */
	static renderWaitingRoomHeader(): string {
		return `
			<header class="flex justify-between items-center px-8 py-6">
				<button
					onclick="window.router.goBack()"
					class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
					id="back-button"
				>
					â† BACK
				</button>

				<!-- Status indicator -->
				<div class="flex items-center gap-3 neon-border bg-black/50 backdrop-blur-sm rounded-lg px-4 py-2">
					<div class="status-indicator"></div>
					<span class="pixel-font text-sm text-blue-300">SEARCHING</span>
				</div>
			</header>
		`;
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/utils/CleanupManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * Gestionnaire de cleanup pour Ã©viter les fuites mÃ©moire
 * GÃ¨re automatiquement les timeouts, intervals, event listeners et animations GSAP
 */
export class CleanupManager {
	private timeouts: Set<number> = new Set();
	private intervals: Set<number> = new Set();
	private gsapTargets: Set<string | Element> = new Set();
	private cleanupCallbacks: Array<() => void> = [];

	/**
	 * Enregistre un setTimeout et retourne son ID
	 */
	setTimeout(callback: () => void, delay: number): number {
		const id = window.setTimeout(() => {
			this.timeouts.delete(id);
			callback();
		}, delay);
		this.timeouts.add(id);
		return id;
	}

	/**
	 * Enregistre un setInterval et retourne son ID
	 */
	setInterval(callback: () => void, delay: number): number {
		const id = window.setInterval(callback, delay);
		this.intervals.add(id);
		return id;
	}

	/**
	 * Enregistre une cible GSAP pour cleanup automatique
	 */
	registerGsapTarget(target: string | Element): void {
		this.gsapTargets.add(target);
	}

	/**
	 * Enregistre un callback de cleanup personnalisÃ©
	 */
	onCleanup(callback: () => void): void {
		this.cleanupCallbacks.push(callback);
	}

	/**
	 * Nettoie tous les timeouts enregistrÃ©s
	 */
	private clearTimeouts(): void {
		this.timeouts.forEach(id => window.clearTimeout(id));
		this.timeouts.clear();
	}

	/**
	 * Nettoie tous les intervals enregistrÃ©s
	 */
	private clearIntervals(): void {
		this.intervals.forEach(id => window.clearInterval(id));
		this.intervals.clear();
	}

	/**
	 * Tue toutes les animations GSAP enregistrÃ©es
	 */
	private killGsapAnimations(): void {
		if (typeof window !== 'undefined' && (window as any).gsap) {
			const gsap = (window as any).gsap;
			this.gsapTargets.forEach(target => {
				gsap.killTweensOf(target);
			});
		}
		this.gsapTargets.clear();
	}

	/**
	 * ExÃ©cute tous les callbacks de cleanup
	 */
	private runCallbacks(): void {
		this.cleanupCallbacks.forEach(callback => {
			try {
				callback();
			} catch (error) {
				console.error('Error in cleanup callback:', error);
			}
		});
		this.cleanupCallbacks = [];
	}

	/**
	 * Nettoie tout
	 */
	cleanup(): void {
		this.clearTimeouts();
		this.clearIntervals();
		this.killGsapAnimations();
		this.runCallbacks();
	}

	/**
	 * CrÃ©e une fonction de cleanup pour le router
	 */
	getCleanupFunction(): () => void {
		return () => this.cleanup();
	}
}

/**
 * Helper pour crÃ©er un CleanupManager dans les vues
 */
export function createCleanupManager(): CleanupManager {
	return new CleanupManager();
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/utils/localTournamentManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * Local Tournament Manager
 * Manages local tournament bracket generation and state without backend
 */

export interface LocalPlayer {
  id: string;
  username: string;
  selectedSkill: 'smash' | 'dash';
  eliminated: boolean;
}

export interface LocalMatch {
  id: string;
  round: number;
  position: number;
  player1?: LocalPlayer;
  player2?: LocalPlayer;
  winner?: LocalPlayer;
  status: 'pending' | 'ready' | 'in_progress' | 'finished';
}

export interface LocalTournament {
  id: string;
  size: 4 | 8;
  players: LocalPlayer[];
  bracket: LocalMatch[];
  currentRound: number;
  status: 'setup' | 'in_progress' | 'finished';
  winner?: LocalPlayer;
  createdAt: Date;
}

export class LocalTournamentManager {
  private static readonly STORAGE_KEY = 'localTournament';

  /**
   * Create a new local tournament
   */
  static createTournament(size: 4 | 8, players: Omit<LocalPlayer, 'eliminated'>[]): LocalTournament {
    if (players.length !== size) {
      throw new Error(`Expected ${size} players, got ${players.length}`);
    }

    const tournament: LocalTournament = {
      id: this.generateId(),
      size,
      players: players.map(p => ({ ...p, eliminated: false })),
      bracket: [],
      currentRound: 1,
      status: 'setup',
      createdAt: new Date(),
    };

    // Shuffle players for fairness
    const shuffledPlayers = this.shuffleArray([...tournament.players]);

    // Generate first round bracket
    tournament.bracket = this.generateFirstRound(shuffledPlayers);
    tournament.status = 'in_progress';

    this.saveTournament(tournament);
    return tournament;
  }

  /**
   * Generate first round matches from shuffled players
   */
  private static generateFirstRound(players: LocalPlayer[]): LocalMatch[] {
    const matches: LocalMatch[] = [];
    const matchCount = players.length / 2;

    for (let i = 0; i < matchCount; i++) {
      matches.push({
        id: this.generateId(),
        round: 1,
        position: i,
        player1: players[i * 2],
        player2: players[i * 2 + 1],
        status: 'ready',
      });
    }

    return matches;
  }

  /**
   * Get the current tournament from storage
   */
  static getCurrentTournament(): LocalTournament | null {
    const data = sessionStorage.getItem(this.STORAGE_KEY);
    if (!data) return null;

    try {
      const tournament = JSON.parse(data);
      // Convert date strings back to Date objects
      tournament.createdAt = new Date(tournament.createdAt);
      return tournament;
    } catch (error) {
      console.error('Failed to parse tournament data:', error);
      return null;
    }
  }

  /**
   * Save tournament to storage
   */
  static saveTournament(tournament: LocalTournament): void {
    sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(tournament));
  }

  /**
   * Clear tournament from storage
   */
  static clearTournament(): void {
    sessionStorage.removeItem(this.STORAGE_KEY);
  }

  /**
   * Get the next match to be played
   */
  static getNextMatch(tournament: LocalTournament): LocalMatch | null {
    return tournament.bracket.find(
      m => m.status === 'ready' && m.round === tournament.currentRound
    ) || null;
  }

  /**
   * Get all matches for a specific round
   */
  static getMatchesForRound(tournament: LocalTournament, round: number): LocalMatch[] {
    return tournament.bracket.filter(m => m.round === round);
  }

  /**
   * Record match result and update bracket
   */
  static recordMatchResult(matchId: string, winnerId: string): LocalTournament | null {
    const tournament = this.getCurrentTournament();
    if (!tournament) return null;

    const match = tournament.bracket.find(m => m.id === matchId);
    if (!match) return null;

    // Determine winner and loser
    const winner = match.player1?.id === winnerId ? match.player1 : match.player2;
    const loser = match.player1?.id === winnerId ? match.player2 : match.player1;

    if (!winner || !loser) return null;

    // Update match
    match.winner = winner;
    match.status = 'finished';

    // Mark loser as eliminated
    const loserInPlayers = tournament.players.find(p => p.id === loser.id);
    if (loserInPlayers) {
      loserInPlayers.eliminated = true;
    }

    // Check if current round is complete
    const currentRoundMatches = this.getMatchesForRound(tournament, tournament.currentRound);
    const allFinished = currentRoundMatches.every(m => m.status === 'finished');

    if (allFinished) {
      // Check if tournament is over
      if (currentRoundMatches.length === 1) {
        // Final match - tournament complete
        tournament.status = 'finished';
        tournament.winner = winner;
      } else {
        // Create next round
        this.createNextRound(tournament);
      }
    }

    this.saveTournament(tournament);
    return tournament;
  }

  /**
   * Create next round from winners of current round
   */
  private static createNextRound(tournament: LocalTournament): void {
    const currentRoundMatches = this.getMatchesForRound(tournament, tournament.currentRound);
    const winners = currentRoundMatches
      .filter(m => m.winner)
      .map(m => m.winner!);

    if (winners.length < 2) {
      console.error('Not enough winners to create next round');
      return;
    }

    tournament.currentRound++;
    const newMatches: LocalMatch[] = [];
    const matchCount = winners.length / 2;

    for (let i = 0; i < matchCount; i++) {
      newMatches.push({
        id: this.generateId(),
        round: tournament.currentRound,
        position: i,
        player1: winners[i * 2],
        player2: winners[i * 2 + 1],
        status: 'ready',
      });
    }

    tournament.bracket.push(...newMatches);
  }

  /**
   * Mark match as in progress
   */
  static markMatchInProgress(matchId: string): void {
    const tournament = this.getCurrentTournament();
    if (!tournament) return;

    const match = tournament.bracket.find(m => m.id === matchId);
    if (match) {
      match.status = 'in_progress';
      this.saveTournament(tournament);
    }
  }

  /**
   * Get total number of rounds for tournament size
   */
  static getTotalRounds(size: 4 | 8): number {
    return size === 4 ? 2 : 3; // 4 players = 2 rounds, 8 players = 3 rounds
  }

  /**
   * Get round name
   */
  static getRoundName(round: number, totalRounds: number): string {
    if (round === totalRounds) return 'Final';
    if (round === totalRounds - 1) return 'Semi-Finals';
    if (round === totalRounds - 2) return 'Quarter-Finals';
    return `Round ${round}`;
  }

  /**
   * Shuffle array using Fisher-Yates algorithm
   */
  private static shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  /**
   * Generate unique ID
   */
  private static generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/vite-env.d.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/// <reference types="vite/client" />

interface ImportMetaEnv {
    readonly VITE_HOST: string
    readonly VITE_GAME_ENDPOINT: string
    readonly VITE_CHAT_ENDPOINT: string
    readonly VITE_CREATEGAME_ENDPOINT: string
    // Ajoute ici toutes tes variables d'environnement VITE_*
}

interface ImportMeta {
    readonly env: ImportMetaEnv
}


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/LocalGameView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

const makeId = () => {
	if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
		return crypto.randomUUID();
	}
	return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
};

export const LocalGameView: ViewFunction = () => {
	const content = `
			<style>
				.control-hint {
					background: rgba(59, 130, 246, 0.1);
					border: 1px solid rgba(59, 130, 246, 0.3);
				}
			</style>

			<!-- Zone centrale -->
			<div class="flex-1 flex items-center justify-center px-4 py-12">
				<div class="w-full max-w-6xl">
					
					<!-- Titre principal -->
					<div class="text-center mb-12">
						<h1 class="pixel-font text-5xl md:text-7xl text-blue-400 mb-4" 
							style="animation: neonPulse 2s ease-in-out infinite;"
							id="local-title">
							ğŸ® LOCAL GAME ğŸ®
						</h1>
						<p class="pixel-font text-lg text-blue-300 opacity-80">
							>>> TWO PLAYERS - ONE SCREEN <<<
						</p>
					</div>

					<!-- Formulaire -->
					<form id="local-game-form" class="space-y-8">
						<!-- Grid pour les deux joueurs -->
						<div class="grid grid-cols-1 md:grid-cols-2 gap-6">
							
							<!-- Joueur 1 (Gauche) -->
							<div class="player-card neon-border rounded-lg p-6" id="player-left-card" style="opacity: 0; transform: translateX(-100px);">
								<!-- Header -->
								<div class="flex items-center justify-between mb-6">
									<h2 class="pixel-font text-2xl text-blue-400 ">PLAYER 1</h2>
								</div>

								<!-- Username -->
								<div class="mb-4">
									<label for="local-left-name" class="block mb-2 pixel-font text-sm text-blue-300">
										USERNAME:
									</label>
									<input 
										type="text" 
										id="local-left-name" 
										name="left-name"
										placeholder="Player 1"
										maxlength="24"
										required
										class="w-full p-3 rounded pixel-font text-sm neon-input"
									/>
								</div>

								<!-- Skill -->
								<div class="mb-6">
									<label for="local-left-skill" class="block mb-2 pixel-font text-sm text-blue-300">
										SKILL:
									</label>
									<select 
										id="local-left-skill" 
										name="left-skill"
										class="w-full p-3 rounded pixel-font text-sm neon-input cursor-pointer"
									>
										<option value="smash">ğŸ’¥ Smash</option>
										<option value="dash">âš¡ Dash</option>
									</select>
								</div>

								<!-- ContrÃ´les -->
								<div class="control-hint rounded-lg p-4">
									<div class="pixel-font text-xs text-blue-300 mb-2 font-bold">
										CONTROLS:
									</div>
									<div class="space-y-1 pixel-font text-xs text-blue-300/80">
										<div>W / S â†’ Move paddle</div>
										<div>SPACE â†’ Use skill</div>
									</div>
								</div>
							</div>

							<!-- Joueur 2 (Droite) -->
							<div class="player-card neon-border rounded-lg p-6" id="player-right-card" style="opacity: 0; transform: translateX(100px);">
								<!-- Header -->
								<div class="flex items-center justify-between mb-6">
									<h2 class="pixel-font text-2xl text-red-500">PLAYER 2</h2>
								</div>

								<!-- Username -->
								<div class="mb-4">
									<label for="local-right-name" class="block mb-2 pixel-font text-sm text-red-400">
										USERNAME:
									</label>
									<input 
										type="text" 
										id="local-right-name" 
										name="right-name"
										placeholder="Player 2"
										maxlength="24"
										required
										class="w-full p-3 rounded pixel-font text-sm neon-input"
									/>
								</div>

								<!-- Skill -->
								<div class="mb-6">
									<label for="local-right-skill" class="block mb-2 pixel-font text-sm text-red-400">
										SKILL:
									</label>
									<select 
										id="local-right-skill" 
										name="right-skill"
										class="w-full p-3 rounded pixel-font text-sm neon-input cursor-pointer"
									>
										<option value="smash">ğŸ’¥ Smash</option>
										<option value="dash">âš¡ Dash</option>
									</select>
								</div>

								<!-- ContrÃ´les -->
								<div class="control-hint rounded-lg p-4">
									<div class="pixel-font text-xs text-red-400 mb-2 font-bold">
										CONTROLS:
									</div>
									<div class="space-y-1 pixel-font text-xs text-red-400/80">
										<div>â†‘ / â†“ â†’ Move paddle</div>
										<div>ENTER â†’ Use skill</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Message d'erreur -->
						<div id="local-game-feedback" class="hidden neon-border bg-red-500/10 rounded-lg p-4 text-center">
							<p class="pixel-font text-sm text-red-400"></p>
						</div>

						<!-- Boutons d'action -->
						<div class="flex flex-col gap-4">
							<!-- Bouton START -->
							<button 
								type="submit" 
								class="w-full py-4 pixel-font text-lg neon-border bg-green-500/20 text-green-400 hover:bg-green-500/40 hover:text-white transition-all relative group"
								id="start-btn"
							>
								<span class="relative z-10">>>> START GAME <<<</span>
								<div class="absolute inset-0 bg-green-500/0 group-hover:bg-green-500/10 transition-all rounded"></div>
							</button>

							<!-- Bouton RETOUR -->
							<button 
								type="button" 
								id="local-back-btn"
								class="w-full py-3 pixel-font text-sm neon-border bg-transparent text-blue-400 hover:bg-blue-500/20 transition-all"
							>
								â† BACK TO MENU
							</button>
						</div>
					</form>

					<!-- Info supplÃ©mentaire -->
					<div class="mt-8 text-center">
						<div class="inline-block neon-border bg-blue-500/10 rounded-lg px-6 py-3">
							<p class="pixel-font text-xs text-blue-300/60">
								ğŸ’¡ TIP: Choose different skills for more strategic gameplay!
							</p>
						</div>
					</div>
				</div>
			</div>
	`;

	return Layout.render(content, {
		showBackButton: true,
		showSignInButton: true,
		showFooter: true
	});
};

export const localGameLogic = (): CleanupFunction | void => {
	const cleanupManager = createCleanupManager();

	// Enregistrer les cibles GSAP
	cleanupManager.registerGsapTarget('#local-title');
	cleanupManager.registerGsapTarget('#player-left-card');
	cleanupManager.registerGsapTarget('#player-right-card');
	cleanupManager.registerGsapTarget('#local-game-feedback');

	// Animations d'entrÃ©e - UNE SEULE FOIS
	gsap.to('#local-title', {
		scale: 1,
		opacity: 1,
		duration: 1,
		ease: 'back.out(1.7)'
	});

	gsap.to('#player-left-card', {
		x: 0,
		opacity: 1,
		duration: 0.8,
		delay: 0.3,
		ease: 'power2.out'
	});

	gsap.to('#player-right-card', {
		x: 0,
		opacity: 1,
		duration: 0.8,
		delay: 0.3,
		ease: 'power2.out'
	});

	const form = document.getElementById('local-game-form') as HTMLFormElement | null;
	const feedbackEl = document.getElementById('local-game-feedback');
	const feedbackText = feedbackEl?.querySelector('p');
	const backBtn = document.getElementById('local-back-btn');

	if (!form) {
		return;
	}

	const host = import.meta.env.VITE_HOST || 'localhost:8443';
	const createEndpoint = import.meta.env.VITE_CREATEGAME_ENDPOINT || '/gameback/create';
	const gameEndpoint = import.meta.env.VITE_GAME_ENDPOINT || '/gameback/game';

	const showError = (message: string) => {
		if (feedbackEl && feedbackText) {
			feedbackText.textContent = message;
			feedbackEl.classList.remove('hidden');
			
			// Animation de l'erreur
			gsap.fromTo(feedbackEl, 
				{ scale: 0.8, opacity: 0 },
				{ scale: 1, opacity: 1, duration: 0.3, ease: 'back.out' }
			);
		}
	};

	const hideError = () => {
		if (feedbackEl) {
			feedbackEl.classList.add('hidden');
		}
	};

	const backHandler = () => {
		window.router?.goBack();
	};

	backBtn?.addEventListener('click', backHandler);

	const submitHandler = async (event: Event) => {
		event.preventDefault();
		hideError();
		
		const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement | null;
		if (submitBtn) {
			submitBtn.disabled = true;
			
			// Animation du bouton
			gsap.to(submitBtn, {
				scale: 0.95,
				duration: 0.1,
				yoyo: true,
				repeat: 1
			});
		}

		const leftName = (form.querySelector<HTMLInputElement>('input[name="left-name"]')?.value.trim() || 'Player 1');
		const rightName = (form.querySelector<HTMLInputElement>('input[name="right-name"]')?.value.trim() || 'Player 2');
		const leftSkill = (form.querySelector<HTMLSelectElement>('select[name="left-skill"]')?.value === 'dash') ? 'dash' : 'smash';
		const rightSkill = (form.querySelector<HTMLSelectElement>('select[name="right-skill"]')?.value === 'dash') ? 'dash' : 'smash';

		const roomId = makeId();
		const leftId = makeId();
		const rightId = makeId();

		try {
			const response = await fetch(`https://${host}${createEndpoint}`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					roomId,
					player1: { id: leftId, username: leftName, selectedSkill: leftSkill },
					player2: { id: rightId, username: rightName, selectedSkill: rightSkill }
				})
			});

			if (!response.ok) {
				throw new Error(`Server error (${response.status})`);
			}

			const wsUrl = `wss://${host}${gameEndpoint}/${roomId}`;
			sessionStorage.setItem('gameWsURL', wsUrl);
			sessionStorage.setItem('localGameConfig', JSON.stringify({
				roomId,
				left: { id: leftId, username: leftName, selectedSkill: leftSkill },
				right: { id: rightId, username: rightName, selectedSkill: rightSkill }
			}));

			// Redirection immÃ©diate
			window.router?.navigateTo(`/game/${roomId}`);
		} catch (err) {
			console.error('Failed to create local game session', err);
			showError(err instanceof Error ? err.message : 'Unable to create local game.');
			
			if (submitBtn) {
				submitBtn.disabled = false;
			}
		}
	};

	form.addEventListener('submit', submitHandler);

	// Enregistrer le cleanup
	cleanupManager.onCleanup(() => {
		form.removeEventListener('submit', submitHandler);
		backBtn?.removeEventListener('click', backHandler);
	});

	return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/Game3dView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction } from "../router/types";
import { Game3dComponent, Game3D } from "../components/Game3d/Game3d";

 export const Game3dView: ViewFunction = () => {
	setTimeout(() => {
		const gameContainer = document.getElementById('game-content');
		if (gameContainer) {
			new Game3D(gameContainer);
		} else
			console.error('Game container not found');
	}, 100);
	
	return `
		<div id="game-content">
			${Game3dComponent()}
		</div>
	`
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/DbUserView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction } from "../router/types";
import { Header } from "../components/Header";
import { createCleanupManager } from "../utils/CleanupManager";

export const dbUserView: ViewFunction = () => {
    return `
        <div class="fixed inset-0 bg-[#04071A] overflow-hidden">
			<!-- Ã‰toiles -->
			${Array.from({length: 150}, (_, i) => `
			<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			<!-- Ã‰toiles normales -->
			${Array.from({length: 150}, (_, i) => `
				<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			
			<!-- Ã‰toiles qui scintillent fort -->
			${Array.from({length: 50}, (_) => `
				<div 
					class="absolute"
					style="
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
					"
				>
					<div class="w-[4px] h-[4px] bg-white rounded-full"></div>
				</div>
			`).join('')}
			
			<style>
				@keyframes strong-sparkle {
					0%, 100% {
						opacity: 0.3;
						filter: blur(0px);
					}
					50% {
						opacity: 1;
						filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
					}
				}
			</style>

        ${Header({ isLogged: false })}
        <h1>bonjour kenzo</h1>

        `;
};

export const dbUserLogic = (): CleanupFunction => {
    const cleanupManager = createCleanupManager();

    function handleClick() {
        alert("ok")
    }

    document?.querySelector('h1')?.addEventListener("click", handleClick)

    // Enregistrer le cleanup
    cleanupManager.onCleanup(() => {
        document.querySelector('h1')?.removeEventListener("click", handleClick)
    });

    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/GameDetailView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction } from "../router/types";
import { BackButton } from "../components/Button";
import { gsap } from "gsap";
import { createCleanupManager } from "../utils/CleanupManager";

interface GameDetail {
    id: string;
    room_id: string;
    game_type: 'quickplay' | 'tournament';
    tournament_id?: string;
    tournament_round?: number;
    player_left_id: string;
    player_right_id: string;
    player_left_username: string;
    player_right_username: string;
    winner_username?: string;
    score_left: number;
    score_right: number;
    status: string;
    end_reason?: 'score' | 'timeout' | 'forfeit';
    created_at: string;
    started_at?: string;
    finished_at?: string;
    duration_seconds?: number;
    stats: GameStat[];
    skills: SkillUsed[];
    powerUps: PowerUpUsed[];
    goals: Goal[];
}

interface GameStat {
    player_id: string;
    username: string;
    side: 'left' | 'right';
    paddle_hits: number;
    max_ball_speed: number;
    power_ups_collected: number;
    skills_used: number;
    time_disconnected_ms: number;
}

interface SkillUsed {
    player_id: string;
    username: string;
    skill_type: string;
    activated_at_game_time: number;
    was_successful: boolean;
}

interface PowerUpUsed {
    player_id: string;
    username: string;
    power_up_type: 'split' | 'blackout' | 'blackhole';
    collected_at_game_time?: number;
    activated_at_game_time: number;
}

interface Goal {
    id: number;
    game_id: string;
    scorer_side: 'left' | 'right';
    scored_against_side: 'left' | 'right';
    ball_y_position: number;
    scored_at_game_time: number;
}

export const GameDetailView: ViewFunction = (params) => {
    const gameId = params?.id || '';
    
    return `
        <!-- Fond Ã©toilÃ© -->
        <div class="fixed inset-0 bg-[#04071A] overflow-hidden">
            ${Array.from({length: 150}, (_, i) => `
                <div 
                    class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
                    style="
                        width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                        height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        opacity: ${0.3 + Math.random() * 0.7};
                        ${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
                    "
                ></div>
            `).join('')}
            
            ${Array.from({length: 50}, (_) => `
                <div 
                    class="absolute"
                    style="
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
                    "
                >
                    <div class="w-[4px] h-[4px] bg-white rounded-full"></div>
                </div>
            `).join('')}
            
            <style>
                @keyframes strong-sparkle {
                    0%, 100% {
                        opacity: 0.3;
                        filter: blur(0px);
                    }
                    50% {
                        opacity: 1;
                        filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
                    }
                }
            </style>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen">
            <!-- Header avec BackButton -->
            <div class="p-8">
                ${BackButton({
                    size: "lg",
                    className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
                })}
            </div>

            <!-- Container principal -->
            <div class="container mx-auto px-8 pb-8" data-game-id="${gameId}">
                <!-- Loading state -->
                <div id="game-loading" class="text-center py-12">
                    <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
                    <p class="text-white/60 mt-4">Chargement des dÃ©tails...</p>
                </div>

                <!-- Content (sera injectÃ© par JS) -->
                <div id="game-content" style="display: none;">
                    <!-- Le contenu sera gÃ©nÃ©rÃ© dynamiquement -->
                </div>

                <!-- Error state -->
                <div id="game-error" style="display: none;" class="text-center py-12">
                    <div class="text-6xl mb-4">âš ï¸</div>
                    <h3 class="text-2xl font-bold text-red-400 mb-2">Partie non trouvÃ©e</h3>
                    <p class="text-white/60">Impossible de charger les dÃ©tails de cette partie</p>
                </div>
            </div>
        </div>
    `;
};

export const gameDetailLogic = (params?: Record<string, string>): (() => void) => {
    const cleanupManager = createCleanupManager();
    const gameId = params?.id;

    // Enregistrer les cibles GSAP
    cleanupManager.registerGsapTarget('#game-content > *');

    if (!gameId) {
        showError();
        return () => {};
    }

    const fetchGameDetails = async (): Promise<void> => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/gamedb/games/${gameId}`);
            
            if (!response.ok) {
                throw new Error('Failed to fetch game details');
            }

            const data = await response.json();
            
            if (data.success && data.game) {
                displayGameDetails(data.game);
                hideLoading();
            } else {
                showError();
            }
        } catch (err) {
            console.error('Error fetching game details:', err);
            showError();
        }
    };

    const displayGameDetails = (game: GameDetail): void => {
        const contentElement = document.getElementById('game-content');
        if (!contentElement) return;

        const date = new Date(game.created_at);
        const formattedDate = date.toLocaleDateString('fr-FR', {
            day: '2-digit',
            month: 'long',
            year: 'numeric'
        });
        const formattedTime = date.toLocaleTimeString('fr-FR', {
            hour: '2-digit',
            minute: '2-digit'
        });

        const duration = game.duration_seconds 
            ? `${Math.floor(game.duration_seconds / 60)}:${(game.duration_seconds % 60).toString().padStart(2, '0')}`
            : '-';

        const isWinner = game.score_left > game.score_right;
        const isDraw = game.score_left === game.score_right;
        const resultIcon = isWinner ? 'ğŸ†' : isDraw ? 'ğŸ¤' : 'ğŸ’€';

        const gameTypeLabel = game.game_type === 'tournament' ? 'ğŸ† Tournoi' : 'âš¡ QuickPlay';
        const gameTypeBg = game.game_type === 'tournament' ? 'bg-purple-500/20' : 'bg-blue-500/20';

        // Trouver les stats de chaque joueur
        const leftStats = game.stats.find(s => s.side === 'left');
        const rightStats = game.stats.find(s => s.side === 'right');

        // Grouper skills et power-ups par joueur
        const leftSkills = game.skills.filter(s => s.player_id === game.player_left_id);
        const rightSkills = game.skills.filter(s => s.player_id === game.player_right_id);
        const leftPowerUps = game.powerUps.filter(p => p.player_id === game.player_left_id);
        const rightPowerUps = game.powerUps.filter(p => p.player_id === game.player_right_id);

        // Calculer taux de rÃ©ussite des skills par joueur
        const calculateSkillSuccessRate = (skills: SkillUsed[]) => {
            if (skills.length === 0) return { total: 0, successful: 0, rate: 0 };
            const successful = skills.filter(s => s.was_successful).length;
            return {
                total: skills.length,
                successful,
                rate: (successful / skills.length) * 100
            };
        };

        const leftSkillStats = calculateSkillSuccessRate(leftSkills);
        const rightSkillStats = calculateSkillSuccessRate(rightSkills);

        // CrÃ©er la timeline des Ã©vÃ©nements (skills + power-ups)
        const createTimeline = () => {
            const events: Array<{
                time: number;
                type: 'skill' | 'powerup' | 'goal';
                player: string;
                playerId: string;
                data: SkillUsed | PowerUpUsed | Goal;
            }> = [];

            // Ajouter les skills
            game.skills.forEach(skill => {
                events.push({
                    time: skill.activated_at_game_time,
                    type: 'skill',
                    player: skill.username,
                    playerId: skill.player_id,
                    data: skill
                });
            });

            // Ajouter les power-ups
            game.powerUps.forEach(powerUp => {
                events.push({
                    time: powerUp.activated_at_game_time,
                    type: 'powerup',
                    player: powerUp.username,
                    playerId: powerUp.player_id,
                    data: powerUp
                });
            });

            // Ajouter les goals
            game.goals.forEach(goal => {
                const scorerUsername = goal.scorer_side === 'left' ? game.player_left_username : game.player_right_username;
                const scorerPlayerId = goal.scorer_side === 'left' ? game.player_left_id : game.player_right_id;
                events.push({
                    time: goal.scored_at_game_time,
                    type: 'goal',
                    player: scorerUsername,
                    playerId: scorerPlayerId,
                    data: goal
                });
            });

            // Trier par temps
            events.sort((a, b) => a.time - b.time);

            return events;
        };

        const timeline = createTimeline();

        contentElement.innerHTML = `
            <!-- Titre -->
            <div class="text-center mb-8">
                <h1 class="text-5xl font-bold text-white mb-2">DÃ©tails de la Partie</h1>
                <p class="text-white/60 text-lg">${formattedDate} Ã  ${formattedTime}</p>
            </div>

            <!-- Infos principales -->
            <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-8 mb-6">
                <div class="flex items-center justify-between mb-6">
                    <div class="flex items-center gap-4">
                        <div class="text-5xl">${resultIcon}</div>
                        <div>
                            <div class="text-3xl font-bold text-white">
                                ${isDraw ? 'Ã‰GALITÃ‰' : `Victoire de ${game.winner_username}`}
                            </div>
                            <div class="${gameTypeBg} inline-block px-4 py-2 rounded-lg text-white text-sm mt-2">
                                ${gameTypeLabel}
                            </div>
                        </div>
                    </div>
                    <div class="text-right">
                        ${game.end_reason ? `
                            <div class="text-white/60 text-sm mb-2">
                                ${game.end_reason === 'score' ? 'ğŸ¯ TerminÃ© au score' : 
                                  game.end_reason === 'timeout' ? 'â±ï¸ Timeout' : 
                                  'ğŸš« Forfait'}
                            </div>
                        ` : ''}
                        <div class="text-white/60 text-sm">â±ï¸ DurÃ©e: ${duration}</div>
                    </div>
                </div>

                <!-- Score -->
                <div class="grid grid-cols-3 gap-8 items-center">
                    <div class="text-center">
                        <div class="text-white text-2xl font-semibold mb-3">
                            ${game.player_left_username}
                        </div>
                        <div class="text-6xl font-bold ${game.score_left > game.score_right ? 'text-green-400' : 'text-white/60'}">
                            ${game.score_left}
                        </div>
                    </div>
                    <div class="text-center">
                        <div class="text-white/40 text-3xl font-bold">VS</div>
                    </div>
                    <div class="text-center">
                        <div class="text-white text-2xl font-semibold mb-3">
                            ${game.player_right_username}
                        </div>
                        <div class="text-6xl font-bold ${game.score_right > game.score_left ? 'text-green-400' : 'text-white/60'}">
                            ${game.score_right}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Statistiques dÃ©taillÃ©es -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <!-- Stats joueur gauche -->
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                    <h3 class="text-2xl font-bold text-white mb-4 flex items-center gap-2">
                        <span>ğŸ“Š</span> Stats - ${game.player_left_username}
                    </h3>
                    ${leftStats ? `
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">ğŸ“ Touches de paddle</span>
                                <span class="text-white font-bold text-xl">${leftStats.paddle_hits}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">ğŸ Power-ups collectÃ©s</span>
                                <span class="text-white font-bold text-xl">${leftStats.power_ups_collected}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">ğŸ’¥ Skills utilisÃ©s</span>
                                <span class="text-white font-bold text-xl">${leftStats.skills_used}</span>
                            </div>
                            ${leftSkillStats.total > 0 ? `
                                <div class="flex justify-between items-center">
                                    <span class="text-white/60">ğŸ¯ Taux de rÃ©ussite</span>
                                    <span class="${leftSkillStats.rate >= 50 ? 'text-green-400' : 'text-orange-400'} font-bold text-xl">
                                        ${leftSkillStats.rate.toFixed(0)}%
                                    </span>
                                </div>
                                <div class="w-full bg-white/10 rounded-full h-2 overflow-hidden">
                                    <div class="h-full ${leftSkillStats.rate >= 50 ? 'bg-green-400' : 'bg-orange-400'} transition-all" 
                                         style="width: ${leftSkillStats.rate}%"></div>
                                </div>
                            ` : ''}
                            ${leftStats.time_disconnected_ms > 0 ? `
                                <div class="flex justify-between items-center">
                                    <span class="text-white/60">ğŸ”Œ Temps dÃ©connectÃ©</span>
                                    <span class="text-red-400 font-bold text-xl">${(leftStats.time_disconnected_ms / 1000).toFixed(1)}s</span>
                                </div>
                            ` : ''}
                        </div>
                    ` : '<p class="text-white/40">Aucune statistique disponible</p>'}
                </div>

                <!-- Stats joueur droit -->
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                    <h3 class="text-2xl font-bold text-white mb-4 flex items-center gap-2">
                        <span>ğŸ“Š</span> Stats - ${game.player_right_username}
                    </h3>
                    ${rightStats ? `
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">ğŸ“ Touches de paddle</span>
                                <span class="text-white font-bold text-xl">${rightStats.paddle_hits}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">ğŸ Power-ups collectÃ©s</span>
                                <span class="text-white font-bold text-xl">${rightStats.power_ups_collected}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">ğŸ’¥ Skills utilisÃ©s</span>
                                <span class="text-white font-bold text-xl">${rightStats.skills_used}</span>
                            </div>
                            ${rightSkillStats.total > 0 ? `
                                <div class="flex justify-between items-center">
                                    <span class="text-white/60">ğŸ¯ Taux de rÃ©ussite</span>
                                    <span class="${rightSkillStats.rate >= 50 ? 'text-green-400' : 'text-orange-400'} font-bold text-xl">
                                        ${rightSkillStats.rate.toFixed(0)}%
                                    </span>
                                </div>
                                <div class="w-full bg-white/10 rounded-full h-2 overflow-hidden">
                                    <div class="h-full ${rightSkillStats.rate >= 50 ? 'bg-green-400' : 'bg-orange-400'} transition-all" 
                                         style="width: ${rightSkillStats.rate}%"></div>
                                </div>
                            ` : ''}
                            ${rightStats.time_disconnected_ms > 0 ? `
                                <div class="flex justify-between items-center">
                                    <span class="text-white/60">ğŸ”Œ Temps dÃ©connectÃ©</span>
                                    <span class="text-red-400 font-bold text-xl">${(rightStats.time_disconnected_ms / 1000).toFixed(1)}s</span>
                                </div>
                            ` : ''}
                        </div>
                    ` : '<p class="text-white/40">Aucune statistique disponible</p>'}
                </div>
            </div>

            <!-- Heatmap des goals -->
            ${game.goals && game.goals.length > 0 ? `
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6 mb-6">
                    <h3 class="text-2xl font-bold text-white mb-6 flex items-center gap-2">
                        <span>ğŸ¯</span> Heatmap des Goals
                    </h3>
                    
                    <!-- Terrain de jeu unifiÃ© -->
                    <div class="relative w-full" style="height: 400px;">
                        <!-- Terrain -->
                        <div class="absolute inset-0 bg-[#101C69]/40 rounded-lg border-2 border-white/20">
                            <!-- Ligne centrale verticale -->
                            <div class="absolute left-1/2 top-0 bottom-0 w-px bg-white/30"></div>
                            
                            <!-- Ligne centrale horizontale -->
                            <div class="absolute left-0 right-0 top-1/2 h-px bg-white/20"></div>
                            
                            <!-- Paddles visuels -->
                            <div class="absolute left-2 top-1/2 w-2 h-24 bg-blue-400/30 -translate-y-1/2 rounded"></div>
                            <div class="absolute right-2 top-1/2 w-2 h-24 bg-orange-400/30 -translate-y-1/2 rounded"></div>
                            
                            <!-- Goals marquÃ©s par le joueur de GAUCHE (bord droit) -->
                            ${game.goals.filter(g => g.scorer_side === 'left').map(goal => {
                                const yPercent = (goal.ball_y_position / 1080) * 100;
                                return `
                                    <div class="absolute" style="right: 0%; top: ${yPercent}%; transform: translate(50%, -50%);">
                                        <div class="w-4 h-4 bg-blue-500 rounded-full shadow-lg shadow-blue-500/50 border-2 border-blue-300 animate-pulse" 
                                             title="${game.player_left_username} - ${goal.scored_at_game_time.toFixed(1)}s - Y: ${goal.ball_y_position.toFixed(0)}"></div>
                                    </div>
                                `;
                            }).join('')}
                            
                            <!-- Goals marquÃ©s par le joueur de DROITE (bord gauche) -->
                            ${game.goals.filter(g => g.scorer_side === 'right').map(goal => {
                                const yPercent = (goal.ball_y_position / 1080) * 100;
                                return `
                                    <div class="absolute" style="left: 0%; top: ${yPercent}%; transform: translate(-50%, -50%);">
                                        <div class="w-4 h-4 bg-orange-500 rounded-full shadow-lg shadow-orange-500/50 border-2 border-orange-300 animate-pulse" 
                                             title="${game.player_right_username} - ${goal.scored_at_game_time.toFixed(1)}s - Y: ${goal.ball_y_position.toFixed(0)}"></div>
                                    </div>
                                `;
                            }).join('')}
                            
                            <!-- Labels -->
                            <div class="absolute top-2 left-1/2 -translate-x-1/2 text-white/40 text-xs font-semibold">Haut</div>
                            <div class="absolute bottom-2 left-1/2 -translate-x-1/2 text-white/40 text-xs font-semibold">Bas</div>
                            
                            <!-- Noms des joueurs -->
                            <div class="absolute top-1/2 left-8 -translate-y-1/2 -rotate-90 text-blue-400 text-sm font-bold bg-[#04071A]/80 px-2 py-1 rounded">
                                ${game.player_left_username}
                            </div>
                            <div class="absolute top-1/2 right-8 -translate-y-1/2 rotate-90 text-orange-400 text-sm font-bold bg-[#04071A]/80 px-2 py-1 rounded">
                                ${game.player_right_username}
                            </div>
                        </div>
                    </div>

                    <!-- LÃ©gende -->
                    <div class="mt-6 flex justify-center gap-8">
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 bg-blue-500 rounded-full shadow-lg shadow-blue-500/50 border-2 border-blue-300"></div>
                            <span class="text-white/80 text-sm">Goals de ${game.player_left_username} (${game.goals.filter(g => g.scorer_side === 'left').length})</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 bg-orange-500 rounded-full shadow-lg shadow-orange-500/50 border-2 border-orange-300"></div>
                            <span class="text-white/80 text-sm">Goals de ${game.player_right_username} (${game.goals.filter(g => g.scorer_side === 'right').length})</span>
                        </div>
                    </div>
                </div>
            ` : ''}

            <!-- Timeline des Ã©vÃ©nements -->
            ${timeline.length > 0 ? `
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6 mb-6">
                    <h3 class="text-2xl font-bold text-white mb-6 flex items-center gap-2">
                        <span>ğŸ“…</span> Timeline du Match
                    </h3>
                    
                    <!-- Filtres -->
                    <div class="flex flex-wrap gap-2 mb-6">
                        <button class="timeline-filter active px-3 py-1 rounded-lg bg-white/20 border border-white/30 text-white text-sm hover:bg-white/30 transition-all" data-filter="all">
                            Tout afficher
                        </button>
                        <button class="timeline-filter px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-white text-sm hover:bg-white/30 transition-all" data-filter="goals">
                            ğŸ¯ Goals uniquement
                        </button>
                        <button class="timeline-filter px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-white text-sm hover:bg-white/30 transition-all" data-filter="skills">
                            ğŸ’¥ Skills uniquement
                        </button>
                        <button class="timeline-filter px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-white text-sm hover:bg-white/30 transition-all" data-filter="powerups">
                            âš¡ Power-ups uniquement
                        </button>
                    </div>
                    
                    <div class="relative" style="padding-top: 140px; padding-bottom: 120px;">
                        <!-- Ligne horizontale principale -->
                        <div class="absolute h-1 bg-gradient-to-r from-blue-500/20 via-white/30 to-orange-500/20 rounded" style="top: 150px; left: 0; right: 0;"></div>
                        
                        <!-- Goals (au-dessus de la ligne) -->
                        ${timeline.filter(e => e.type === 'goal').map((event, index) => {
                            const isLeft = event.playerId === game.player_left_id;
                            const goal = event.data as Goal;
                            const timePercent = game.duration_seconds ? (event.time / game.duration_seconds) * 100 : 50;
                            
                            return `
                                <div class="absolute timeline-event timeline-goal" style="left: ${timePercent}%; top: 0; transform: translateX(-50%);">
                                    <div class="flex flex-col items-center">
                                        <!-- Carte goal -->
                                        <div class="bg-gradient-to-br ${isLeft ? 'from-blue-500/20 to-blue-600/10 border-blue-400/40' : 'from-orange-500/20 to-orange-600/10 border-orange-400/40'} px-3 py-2 rounded-lg border-2 backdrop-blur-sm shadow-lg mb-2">
                                            <div class="text-2xl mb-1">ğŸ¯</div>
                                            <div class="text-xs font-bold ${isLeft ? 'text-blue-300' : 'text-orange-300'} whitespace-nowrap">${event.player}</div>
                                            <div class="text-xs text-white/60">${event.time.toFixed(1)}s</div>
                                        </div>
                                        <!-- Ligne vers timeline -->
                                        <div class="w-px ${isLeft ? 'bg-blue-400/60' : 'bg-orange-400/60'}" style="height: 50px;"></div>
                                        <!-- Point sur la timeline -->
                                        <div class="w-4 h-4 rounded-full ${isLeft ? 'bg-blue-500 border-blue-300' : 'bg-orange-500 border-orange-300'} border-2 shadow-lg"></div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        
                        <!-- Events (en dessous de la ligne, sans cascade) -->
                        ${timeline.filter(e => e.type !== 'goal').map((event, index) => {
                            const isLeft = event.playerId === game.player_left_id;
                            const isSkill = event.type === 'skill';
                            const timePercent = game.duration_seconds ? (event.time / game.duration_seconds) * 100 : 50;
                            const eventClass = isSkill ? 'timeline-skill' : 'timeline-powerup';
                            
                            if (isSkill) {
                                const skill = event.data as SkillUsed;
                                return `
                                    <div class="absolute timeline-event ${eventClass}" style="left: ${timePercent}%; top: 146px; transform: translateX(-50%);">
                                        <div class="flex flex-col items-center">
                                            <!-- Point sur la timeline -->
                                            <div class="w-3 h-3 rounded-full ${skill.was_successful ? 'bg-green-500 border-green-300' : 'bg-red-500 border-red-300'} border-2 shadow-md"></div>
                                            <!-- Ligne vers carte -->
                                            <div class="w-px ${skill.was_successful ? 'bg-green-400/40' : 'bg-red-400/40'}" style="height: 15px;"></div>
                                            <!-- Carte compacte -->
                                            <div class="bg-[#04071A]/95 px-2 py-1 rounded border ${skill.was_successful ? 'border-green-500/30' : 'border-red-500/30'} backdrop-blur-sm shadow-md">
                                                <div class="flex items-center gap-1">
                                                    <span class="text-lg">ğŸ’¥</span>
                                                    <div class="text-xs ${isLeft ? 'text-blue-300' : 'text-orange-300'} font-semibold whitespace-nowrap">${event.player}</div>
                                                    <span class="text-xs ${skill.was_successful ? 'text-green-400' : 'text-red-400'}">${skill.was_successful ? 'âœ“' : 'âœ—'}</span>
                                                </div>
                                                <div class="text-xs text-white/40 text-center">${event.time.toFixed(1)}s</div>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            } else {
                                const powerUp = event.data as PowerUpUsed;
                                const powerUpIcon = powerUp.power_up_type === 'split' ? 'âš¡' : 
                                                  powerUp.power_up_type === 'blackout' ? 'ğŸŒ‘' : 'ğŸŒ€';
                                const powerUpColor = powerUp.power_up_type === 'split' ? 'border-yellow-500/30' : 
                                                   powerUp.power_up_type === 'blackout' ? 'border-purple-500/30' : 'border-cyan-500/30';
                                return `
                                    <div class="absolute timeline-event ${eventClass}" style="left: ${timePercent}%; top: 146px; transform: translateX(-50%);">
                                        <div class="flex flex-col items-center">
                                            <!-- Point sur la timeline -->
                                            <div class="w-3 h-3 rounded-full bg-cyan-500 border-2 border-cyan-300 shadow-md"></div>
                                            <!-- Ligne vers carte -->
                                            <div class="w-px bg-cyan-400/40" style="height: 15px;"></div>
                                            <!-- Carte compacte -->
                                            <div class="bg-[#04071A]/95 px-2 py-1 rounded border ${powerUpColor} backdrop-blur-sm shadow-md">
                                                <div class="flex items-center gap-1">
                                                    <span class="text-lg">${powerUpIcon}</span>
                                                    <div class="text-xs ${isLeft ? 'text-blue-300' : 'text-orange-300'} font-semibold whitespace-nowrap">${event.player}</div>
                                                </div>
                                                <div class="text-xs text-white/40 text-center">${event.time.toFixed(1)}s</div>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }
                        }).join('')}
                        
                        <!-- Marqueurs de temps -->
                        <div class="absolute left-0" style="top: 140px; transform: translateY(-50%);">
                            <div class="w-2 h-2 rounded-full bg-white/50"></div>
                        </div>
                        <div class="absolute right-0" style="top: 140px; transform: translateY(-50%);">
                            <div class="w-2 h-2 rounded-full bg-white/50"></div>
                        </div>
                    </div>
                    
                    <!-- Labels de temps -->
                    <div class="flex justify-between text-white/40 text-xs mt-2 px-2">
                        <span>ğŸ• 0:00</span>
                        ${game.duration_seconds ? `<span>ğŸ ${Math.floor(game.duration_seconds / 60)}:${(game.duration_seconds % 60).toString().padStart(2, '0')}</span>` : ''}
                    </div>
                    
                    <!-- LÃ©gende -->
                    <div class="flex flex-wrap justify-center gap-4 mt-6 text-xs">
                        <div class="flex items-center gap-1">
                            <div class="w-3 h-3 rounded-full bg-blue-500 border border-blue-300"></div>
                            <span class="text-white/60">Goal ${game.player_left_username}</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <div class="w-3 h-3 rounded-full bg-orange-500 border border-orange-300"></div>
                            <span class="text-white/60">Goal ${game.player_right_username}</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="text-lg">ğŸ’¥</span>
                            <span class="text-white/60">Skill</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="text-lg">âš¡ğŸŒ‘ğŸŒ€</span>
                            <span class="text-white/60">Power-ups</span>
                        </div>
                    </div>
                    
                    <style>
                        .timeline-event {
                            z-index: 1;
                            transition: opacity 0.3s ease;
                        }
                        .timeline-event:hover {
                            z-index: 100;
                        }
                        .timeline-event:hover > div > div:last-child {
                            transform: scale(1.15);
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
                        }
                        .timeline-event.hidden {
                            opacity: 0;
                            pointer-events: none;
                        }
                    </style>
                </div>
            ` : ''}

            ${game.tournament_id ? `
                <div class="mt-6 text-center">
                    <a href="/tournament/${game.tournament_id}" class="inline-block px-6 py-3 bg-purple-500/20 border border-purple-500/40 rounded-lg text-purple-300 hover:bg-purple-500/30 transition-all">
                        â†’ Voir le tournoi complet
                    </a>
                </div>
            ` : ''}
        `;

        contentElement.style.display = 'block';

        // Animations d'entrÃ©e
        gsap.fromTo('#game-content > *', 
            { opacity: 0, y: 20 },
            { 
                opacity: 1, 
                y: 0, 
                duration: 0.6, 
                stagger: 0.1,
                ease: 'power2.out'
            }
        );
    };

    const hideLoading = (): void => {
        const loading = document.getElementById('game-loading');
        if (loading) loading.style.display = 'none';
    };

    const showError = (): void => {
        hideLoading();
        const error = document.getElementById('game-error');
        if (error) error.style.display = 'block';
    };

    // Gestion des filtres de timeline
    const setupTimelineFilters = (): void => {
        const filterButtons = document.querySelectorAll('.timeline-filter');
        
        filterButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                const filter = target.dataset.filter;
                
                if (!filter) return;
                
                // Mettre Ã  jour les boutons actifs
                filterButtons.forEach(btn => {
                    btn.classList.remove('active', 'bg-white/20', 'border-white/30');
                    btn.classList.add('bg-white/10', 'border-white/20');
                });
                target.classList.add('active', 'bg-white/20', 'border-white/30');
                target.classList.remove('bg-white/10', 'border-white/20');
                
                // Filtrer les Ã©vÃ©nements
                const allEvents = document.querySelectorAll('.timeline-event');
                
                allEvents.forEach(event => {
                    event.classList.remove('hidden');
                });
                
                if (filter === 'goals') {
                    document.querySelectorAll('.timeline-skill, .timeline-powerup').forEach(el => {
                        el.classList.add('hidden');
                    });
                } else if (filter === 'skills') {
                    document.querySelectorAll('.timeline-goal, .timeline-powerup').forEach(el => {
                        el.classList.add('hidden');
                    });
                } else if (filter === 'powerups') {
                    document.querySelectorAll('.timeline-goal, .timeline-skill').forEach(el => {
                        el.classList.add('hidden');
                    });
                }
            });
        });
    };

    // Charger les dÃ©tails
    fetchGameDetails().then(() => {
        // Setup des filtres aprÃ¨s que le contenu soit chargÃ©
        cleanupManager.setTimeout(setupTimelineFilters, 100);
    });

    // Enregistrer le cleanup des filtres
    cleanupManager.onCleanup(() => {
        const filterButtons = document.querySelectorAll('.timeline-filter');
        filterButtons.forEach(button => {
            button.removeEventListener('click', () => {});
        });
    });

    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/GameView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction } from "../router/types";
import { Pong } from "../components/PongGame/PongGame";
import { gsap } from "gsap";

export const GameView: ViewFunction = () => {
	return `
		<!-- Fond avec grille animÃ©e -->
		<div class="fixed inset-0 bg-black overflow-hidden">
			<!-- Grille de fond -->
			<div class="absolute inset-0" style="
				background-image: 
					linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
					linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
				background-size: 50px 50px;
				animation: gridMove 20s linear infinite;
			"></div>
			
			<style>
				@keyframes glitch {
					0%, 100% { transform: translate(0); }
					20% { transform: translate(-2px, 2px); }
					40% { transform: translate(-2px, -2px); }
					60% { transform: translate(2px, 2px); }
					80% { transform: translate(2px, -2px); }
				}

				.neon-border-green {
					box-shadow: 
						0 0 10px rgba(34, 197, 94, 0.5),
						inset 0 0 10px rgba(34, 197, 94, 0.2);
					border: 3px solid rgba(34, 197, 94, 0.8);
				}

				.neon-border-red {
					box-shadow: 
						0 0 10px rgba(239, 68, 68, 0.5),
						inset 0 0 10px rgba(239, 68, 68, 0.2);
					border: 3px solid rgba(239, 68, 68, 0.8);
				}

				.game-hud {
					background: rgba(4, 7, 26, 0.85);
					backdrop-filter: blur(10px);
				}

				.player-info {
					transition: all 0.3s ease;
				}

				.player-info:hover {
					transform: translateY(-2px);
				}

				#pong-canvas {
					box-shadow: 
						0 0 30px rgba(59, 130, 246, 0.4),
						0 0 60px rgba(59, 130, 246, 0.2),
						inset 0 0 30px rgba(59, 130, 246, 0.1);
					border: 3px solid rgba(59, 130, 246, 0.6);
				}

				.action-button {
					transition: all 0.2s ease;
					position: relative;
					overflow: hidden;
				}

				.action-button::before {
					content: '';
					position: absolute;
					top: 50%;
					left: 50%;
					width: 0;
					height: 0;
					border-radius: 50%;
					background: rgba(255, 255, 255, 0.1);
					transform: translate(-50%, -50%);
					transition: width 0.6s, height 0.6s;
				}

				.action-button:hover::before {
					width: 300px;
					height: 300px;
				}

				.action-button:active {
					transform: scale(0.95);
				}

				.forfeit-button:hover {
					box-shadow: 
						0 0 20px rgba(239, 68, 68, 0.6),
						inset 0 0 20px rgba(239, 68, 68, 0.3);
				}

				.status-indicator {
					animation: neonPulse 2s ease-in-out infinite;
				}

				.game-container {
					animation: fadeIn 0.8s ease-out;
				}

				@keyframes fadeIn {
					from { opacity: 0; transform: scale(0.95); }
					to { opacity: 1; transform: scale(1); }
				}

				.corner-decoration {
					position: absolute;
					width: 20px;
					height: 20px;
				}

				.corner-decoration-blue {
					border: 2px solid rgba(59, 130, 246, 0.5);
				}

				.corner-decoration-green {
					border: 2px solid rgba(34, 197, 94, 0.5);
				}

				.corner-decoration-red {
					border: 2px solid rgba(239, 68, 68, 0.5);
				}

				.corner-tl { top: -2px; left: -2px; border-right: none; border-bottom: none; }
				.corner-tr { top: -2px; right: -2px; border-left: none; border-bottom: none; }
				.corner-bl { bottom: -2px; left: -2px; border-right: none; border-top: none; }
				.corner-br { bottom: -2px; right: -2px; border-left: none; border-top: none; }

				.stat-good { color: #4ade80; }
				.stat-medium { color: #fbbf24; }
				.stat-bad { color: #ef4444; }
			</style>
			
			<!-- Scanline effect -->
			<div class="absolute inset-0 pointer-events-none opacity-10">
				<div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
			</div>

			<!-- Particules flottantes -->
			${Array.from({length: 30}, (_, i) => `
				<div 
					class="absolute bg-blue-400 rounded-full opacity-20"
					style="
						width: ${2 + Math.random() * 3}px;
						height: ${2 + Math.random() * 3}px;
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						animation: float ${10 + Math.random() * 20}s ease-in-out ${Math.random() * 5}s infinite;
					"
				></div>
			`).join('')}

			<style>
				@keyframes float {
					0%, 100% { transform: translateY(0) translateX(0); }
					25% { transform: translateY(-20px) translateX(10px); }
					50% { transform: translateY(-10px) translateX(-10px); }
					75% { transform: translateY(-30px) translateX(5px); }
				}
			</style>
		</div>

		<!-- Contenu principal -->
		<div class="relative z-10 min-h-screen flex flex-col game-container">
			
			<!-- Header HUD -->
			<div class="game-hud border-b border-white/10">
				<div class="container mx-auto px-4 py-4">
					<div class="flex items-center justify-between">
						
						<!-- Left: Back button -->
						<button 
							onclick="window.router.goBack()" 
							class="action-button pixel-font px-4 py-2 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all text-sm"
							id="back-button"
						>
							<span class="relative z-10">â† EXIT</span>
						</button>

						<!-- Center: Status indicator -->
						<div class="flex items-center gap-3">
							<div id="connection-indicator" class="status-indicator w-3 h-3 bg-green-400 rounded-full"></div>
							<span class="pixel-font text-sm text-blue-300">
								LIVE MATCH
							</span>
						</div>

						<!-- Right: Forfeit button (si pas mode local) -->
						<button 
							id="forfeit-btn"
							class="action-button forfeit-button pixel-font px-4 py-2 neon-border-red bg-red-500/10 text-red-400 hover:bg-red-500/20 transition-all text-sm relative z-10"
						>
							<span class="relative z-10">ğŸ³ï¸ SURRENDER</span>
						</button>
					</div>
				</div>
			</div>

			<!-- Game Area -->
			<div class="flex-1 flex items-center justify-center px-4 py-8">
				<div class="w-full max-w-[95vw]">
					
					<!-- Players Info Bar -->
					<div class="mb-6 grid grid-cols-3 gap-4 items-center">
						
						<!-- Player Left -->
						<div class="player-info neon-border bg-blue-500/5 backdrop-blur-sm rounded-lg p-4 relative">
							<div class="corner-decoration corner-decoration-blue corner-tl"></div>
							<div class="corner-decoration corner-decoration-blue corner-bl"></div>
							
							<div class="flex items-center gap-3">
								<div class="w-12 h-12 rounded-full bg-blue-500/20 flex items-center justify-center border-2 border-blue-500/50">
									<!-- PP du player -->
								</div>
								<div class="flex-1">
									<div id="player-left-name" class="pixel-font text-lg text-blue-500 mb-1">
										Player 1
									</div>
									<div class="flex items-center gap-2">
										<div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
										<span class="pixel-font text-xs text-blue-300/60">READY</span>
									</div>
								</div>
							</div>
						</div>

						<!-- Center: VS -->
						<div class="text-center">
							<div class="inline-block neon-border bg-blue-500/10 backdrop-blur-sm rounded-lg px-6 py-3">
								<span class="pixel-font text-3xl text-blue-400" style="animation: neonPulse 2s ease-in-out infinite;">
									VS
								</span>
							</div>
						</div>

						<!-- Player Right -->
						<div class="player-info neon-border-red bg-red-500/5 backdrop-blur-sm rounded-lg p-4 relative">
							<div class="corner-decoration corner-decoration-red corner-tr"></div>
							<div class="corner-decoration corner-decoration-red corner-br"></div>
							
							<div class="flex items-center gap-3 justify-end">
								<div class="flex-1 text-right">
									<div id="player-right-name" class="pixel-font text-lg text-red-400 mb-1">
										Player 2
									</div>
									<div class="flex items-center gap-2 justify-end">
										<span class="pixel-font text-xs text-red-300/60">READY</span>
										<div class="w-2 h-2 bg-red-400 rounded-full animate-pulse"></div>
									</div>
								</div>
								<div class="w-12 h-12 rounded-full bg-red-500/20 flex items-center justify-center border-2 border-red-500/50">
									<!-- PP du player -->
								</div>
							</div>
						</div>
					</div>

					<!-- Canvas Container avec decorations -->
					<div class="relative">
						<!-- Corner decorations for canvas -->
						<div class="absolute -top-3 -left-3 w-8 h-8 border-l-2 border-t-2 border-blue-400/50"></div>
						<div class="absolute -top-3 -right-3 w-8 h-8 border-r-2 border-t-2 border-blue-400/50"></div>
						<div class="absolute -bottom-3 -left-3 w-8 h-8 border-l-2 border-b-2 border-blue-400/50"></div>
						<div class="absolute -bottom-3 -right-3 w-8 h-8 border-r-2 border-b-2 border-blue-400/50"></div>

						<!-- Pong Game Component -->
						<div data-component="pong-game">
							<canvas id="pong-canvas"></canvas>
						</div>
					</div>

					<!-- Controls Info -->
					<div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
						
						<!-- Left Player Controls -->
						<div class="neon-border bg-blue-500/5 backdrop-blur-sm rounded-lg p-4">
							<div class="pixel-font text-sm text-blue-300 mb-3 flex items-center gap-2">
								<span>PLAYER 1 CONTROLS</span>
							</div>
							<div class="space-y-2 pixel-font text-xs text-blue-300/60">
								<div class="flex items-center gap-2">
									<kbd class="px-2 py-1 bg-blue-500/20 rounded border border-blue-500/30">W</kbd>
									<kbd class="px-2 py-1 bg-blue-500/20 rounded border border-blue-500/30">S</kbd>
									<span>Move paddle</span>
								</div>
								<div class="flex items-center gap-2">
									<kbd class="px-3 py-1 bg-blue-500/20 rounded border border-blue-500/30">SPACE</kbd>
									<span>Use skill</span>
								</div>
								<div class="flex items-center gap-2">
									<kbd class="px-2 py-1 bg-blue-500/20 rounded border border-blue-500/30">P</kbd>
									<kbd class="px-2 py-1 bg-blue-500/20 rounded border border-blue-500/30">ESC</kbd>
									<span>Pause</span>
								</div>
							</div>
						</div>

						<!-- Right Player Controls -->
						<div class="neon-border bg-red-500/5 backdrop-blur-sm rounded-lg p-4">
							<div class="pixel-font text-sm text-red-300 mb-3 flex items-center gap-2 justify-end">
								<span>PLAYER 2 CONTROLS</span>
							</div>
							<div class="space-y-2 pixel-font text-xs text-red-300/60 text-right">
								<div class="flex items-center gap-2 justify-end">
									<span>Move paddle</span>
									<kbd class="px-2 py-1 bg-red-500/20 rounded border border-red-500/30">â†‘</kbd>
									<kbd class="px-2 py-1 bg-red-500/20 rounded border border-red-500/30">â†“</kbd>
								</div>
								<div class="flex items-center gap-2 justify-end">
									<span>Use skill</span>
									<kbd class="px-3 py-1 bg-red-500/20 rounded border border-red-500/30">ENTER</kbd>
								</div>
								<div class="flex items-center gap-2 justify-end">
									<span>Pause</span>
									<kbd class="px-2 py-1 bg-red-500/20 rounded border border-red-500/30">P</kbd>
									<kbd class="px-2 py-1 bg-red-500/20 rounded border border-red-500/30">ESC</kbd>
								</div>
							</div>
						</div>
					</div>

					<!-- Power-ups Legend -->
					<div class="mt-4 neon-border bg-green-300/5 backdrop-blur-sm rounded-lg p-4">
						<div class="pixel-font text-sm text-green-300 mb-3 text-center">
							âš¡ POWER-UPS LEGEND
						</div>
						<div class="grid grid-cols-3 gap-4 pixel-font text-xs text-green-300/60">
							<div class="text-center">
								<div class="text-2xl mb-1">âš¡</div>
								<div>SPLIT</div>
								<div class="text-green-300/40 text-[10px]">Duplicate ball</div>
							</div>
							<div class="text-center">
								<div class="text-2xl mb-1">ğŸŒ‘</div>
								<div>BLACKOUT</div>
								<div class="text-green-300/40 text-[10px]">Blind opponent</div>
							</div>
							<div class="text-center">
								<div class="text-2xl mb-1">ğŸŒ€</div>
								<div>BLACKHOLE</div>
								<div class="text-green-300/40 text-[10px]">Gravity pull</div>
							</div>
						</div>
					</div>
				</div>
			</div>

			<!-- Footer HUD avec vraies stats -->
			<div class="game-hud border-t border-white/10">
				<div class="container mx-auto px-4 py-3">
					<div class="flex items-center justify-center gap-8 pixel-font text-xs text-blue-300/60">
						<div class="flex items-center gap-2">
							<div id="ws-indicator" class="w-2 h-2 bg-gray-400 rounded-full"></div>
							<span id="connection-status">CONNECTION: CONNECTING...</span>
						</div>
						<div>|</div>
						<div>PING: <span id="ping-value" class="stat-medium">--ms</span></div>
						<div>|</div>
						<div>FPS: <span id="fps-value" class="stat-good">--</span></div>
					</div>
				</div>
			</div>
		</div>
	`;
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/TournamentView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

export const TournamentView: ViewFunction = () => {
    const content = `
            <div class="flex-1 flex items-center justify-center px-4 py-12">
                <div class="w-full max-w-4xl">
                    
					<!-- Titre principal -->
					<div class="text-center mb-12">
						<h1 class="pixel-font text-6xl md:text-8xl text-blue-400 mb-4" 
							style="animation: neonPulse 2s ease-in-out infinite;"
							id="tournament-title">
							TOURNAMENT
						</h1>
						<p class="pixel-font text-lg md:text-xl text-blue-300 tracking-wider">
							>>> SKILL ISSUE <<<
						</p>
					</div>

                    <!-- Input Username -->
                    <div class="mb-8 neon-border bg-black/50 backdrop-blur-sm rounded-lg p-6" id="username-section">
                        <label for="usernameInput" class="block mb-3 pixel-font text-sm text-blue-300 text-center">
                            ENTER YOUR USERNAME:
                        </label>
                        <input 
                            type="text" 
                            name="username" 
                            id="usernameInput" 
                            value="Anon"
                            maxlength="20"
                            class="w-full p-3 rounded pixel-font text-center text-lg neon-input"
                            placeholder="Your username..."
                        />
                    </div>

                    <!-- Cartes de tournois -->
					<div class="grid grid-cols-1 md:grid-cols-3 gap-6" id="tournament-cards">
						<!-- 4 Players -->
						<div 
							class="tournament-card neon-border rounded-lg p-8 relative flex flex-col items-center"
							data-component="joinTournament"
							data-slots="4"
							data-tournament-id=""
							id="tournament-4"
						>
							<!-- Badge de statut -->
							<div class="absolute top-4 right-4 pixel-font text-xs text-green-400 bg-green-500/20 px-3 py-1 rounded border border-green-500/50">
								OPEN
							</div>

							<!-- IcÃ´ne -->
							<div class="text-6xl md:text-7xl mb-6 text-blue-500">
								âš¡
							</div>
							
							<!-- Titre -->
							<h3 class="pixel-font text-4xl text-blue-400 mb-2">
								4
							</h3>
							<p class="pixel-font text-sm text-blue-300 mb-6 opacity-80">
								PLAYERS
							</p>
							
							<!-- Compteur -->
							<div class="mb-6">
								<span class="pixel-font text-3xl text-yellow-400" data-player-count>0/4</span>
							</div>

							<!-- Description -->
							<p class="pixel-font text-xs text-blue-300/60 text-center mb-8">
								Quick bracket - 2 rounds
							</p>

							<!-- FlÃ¨ches dÃ©coratives symÃ©triques -->
							<div class="absolute bottom-4 left-0 right-0 flex justify-between px-4">
								<span class="text-red-500 text-2xl opacity-50">â†</span>
								<span class="text-red-500 text-2xl opacity-50">â†’</span>
							</div>
						</div>

						<!-- 8 Players -->
						<div 
							class="tournament-card neon-border rounded-lg p-8 relative flex flex-col items-center"
							data-component="joinTournament"
							data-slots="8"
							data-tournament-id=""
							id="tournament-8"
						>
							<!-- Badge de statut -->
							<div class="absolute top-4 right-4 pixel-font text-xs text-green-400 bg-green-500/20 px-3 py-1 rounded border border-green-500/50">
								OPEN
							</div>

							<!-- IcÃ´ne -->
							<div class="text-6xl md:text-7xl mb-6 text-blue-500">
								âš¡
							</div>
							
							<!-- Titre -->
							<h3 class="pixel-font text-4xl text-blue-400 mb-2">
								8
							</h3>
							<p class="pixel-font text-sm text-blue-300 mb-6 opacity-80">
								PLAYERS
							</p>
							
							<!-- Compteur -->
							<div class="mb-6">
								<span class="pixel-font text-3xl text-yellow-400" data-player-count>0/8</span>
							</div>

							<!-- Description -->
							<p class="pixel-font text-xs text-blue-300/60 text-center mb-8">
								Standard bracket - 3 rounds
							</p>

							<!-- FlÃ¨ches dÃ©coratives symÃ©triques -->
							<div class="absolute bottom-4 left-0 right-0 flex justify-between px-4">
								<span class="text-blue-500 text-2xl opacity-80">â†</span>
								<span class="text-blue-500 text-2xl opacity-80">â†’</span>
							</div>
						</div>

						<!-- 16 Players -->
						<div 
							class="tournament-card neon-border rounded-lg p-8 relative flex flex-col items-center"
							data-component="joinTournament"
							data-slots="16"
							data-tournament-id=""
							id="tournament-16"
						>
							<!-- Badge de statut -->
							<div class="absolute top-4 right-4 pixel-font text-xs text-green-400 bg-green-500/20 px-3 py-1 rounded border border-green-500/50">
								OPEN
							</div>

							<!-- IcÃ´ne -->
							<div class="text-6xl md:text-7xl mb-6 text-blue-500">
								âš¡
							</div>
							
							<!-- Titre -->
							<h3 class="pixel-font text-4xl text-blue-400 mb-2">
								16
							</h3>
							<p class="pixel-font text-sm text-blue-300 mb-6 opacity-80">
								PLAYERS
							</p>
							
							<!-- Compteur -->
							<div class="mb-6">
								<span class="pixel-font text-3xl text-yellow-400" data-player-count>0/16</span>
							</div>

							<!-- Description -->
							<p class="pixel-font text-xs text-blue-300/60 text-center mb-8">
								Epic bracket - 4 rounds
							</p>

							<!-- FlÃ¨ches dÃ©coratives symÃ©triques -->
							<div class="absolute bottom-4 left-0 right-0 flex justify-between px-4">
								<span class="text-red-500 text-2xl opacity-50">â†</span>
								<span class="text-red-500 text-2xl opacity-50">â†’</span>
							</div>
						</div>
					</div>


                </div>
            </div>

		<!-- Modal de countdown (cachÃ© par dÃ©faut) -->
        <div id="countdown" class="fixed inset-0 bg-black/80 countdown-modal hidden flex items-center justify-center z-50">
            <div class="neon-border bg-black/90 backdrop-blur-sm rounded-lg p-12 text-center">
                <h2 class="pixel-font text-3xl text-blue-400 mb-6">
                    TOURNAMENT IS STARTING...
                </h2>
                <div id="countdown-text" class="pixel-font text-8xl text-pink-500 mb-4" style="animation: neonPulse 1s ease-in-out infinite;">
                    3
                </div>
                <p class="pixel-font text-sm text-blue-300/60">
                    Get ready for battle!
                </p>
            </div>
        </div>
    `;

    return Layout.render(content, {
        showBackButton: true,
        showSignInButton: true,
        showFooter: true
    });
};

export const tournamentLogic = (): CleanupFunction => {
    console.log('ğŸ® TournamentView: Initializing...');

	const cleanupManager = createCleanupManager();
    const tournamentBtns = document.querySelectorAll('[data-component="joinTournament"]');
    const usernameInput = document.getElementById("usernameInput") as HTMLInputElement;

    let pollInterval: number | null = null;
    let currentTournamentId: string | null = null;
    let countdownInterval: number | null = null;

    // âœ… Forcer les pointer-events sur les cartes IMMÃ‰DIATEMENT
    tournamentBtns.forEach(btn => {
        (btn as HTMLElement).style.pointerEvents = 'auto';
        (btn as HTMLElement).style.cursor = 'pointer';
        (btn as HTMLElement).style.position = 'relative';
        (btn as HTMLElement).style.zIndex = '10';
    });

	// Enregistrer les cibles GSAP pour cleanup
	cleanupManager.registerGsapTarget('#tournament-title');
	cleanupManager.registerGsapTarget('#username-section');
	cleanupManager.registerGsapTarget('.tournament-card');

    // Animations d'entrÃ©e
    gsap.fromTo('#tournament-title',
        { scale: 0.5, opacity: 0 },
        { scale: 1, opacity: 1, duration: 1, ease: 'back.out(1.7)' }
    );

    gsap.fromTo('#username-section',
        { y: 50, opacity: 0 },
        { y: 0, opacity: 1, duration: 0.8, delay: 0.3, ease: 'power2.out' }
    );

    gsap.fromTo('.tournament-card',
        { y: 100, opacity: 0 },
        {
            y: 0,
            opacity: 1,
            duration: 1,
            stagger: 0.2,
            delay: 0.5,
            ease: 'power3.out',
            onComplete: () => {
                // âœ… Re-forcer aprÃ¨s animation
                tournamentBtns.forEach(btn => {
                    (btn as HTMLElement).style.pointerEvents = 'auto';
                    (btn as HTMLElement).style.cursor = 'pointer';
                });
            }
        }
    );

    // âœ… Fonction pour nettoyer tous les intervals
    const cleanupIntervals = () => {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
            console.log('ğŸ§¹ Polling interval cleared');
        }
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            console.log('ğŸ§¹ Countdown interval cleared');
        }
    };

    // Fonction pour rÃ©cupÃ©rer et mettre Ã  jour les tournois
    const fetchTournaments = async () => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/tournamentback/tournaments`);
            const data = await response.json();

            if (data.success) {
                tournamentBtns.forEach(btn => {
                    const countSpan = btn.querySelector("[data-player-count]");
                    const badge = btn.querySelector('.absolute.top-3.right-3');
                    const slots = btn.getAttribute('data-slots');
                    
                    data.registrations.forEach((tournament: any) => {
                        if (tournament.name === slots + 'p') {
                            if (countSpan) {
                                countSpan.textContent = `${tournament.currentPlayerCount}/${slots}`;
                            }
                            btn.setAttribute("data-tournament-id", tournament.id);
                            
                            // DÃ©sactiver si plein
                            if (tournament.currentPlayerCount >= parseInt(slots || '0')) {
                                btn.classList.add('disabled');
                                (btn as HTMLElement).style.cursor = 'not-allowed';
                                if (badge) {
                                    badge.textContent = 'FULL';
                                    badge.classList.remove('bg-green-500/20', 'border-green-500/50', 'text-green-400');
                                    badge.classList.add('bg-red-500/20', 'border-red-500/50', 'text-red-400');
                                }
                            } else {
                                btn.classList.remove('disabled');
                                (btn as HTMLElement).style.cursor = 'pointer';
                                (btn as HTMLElement).style.pointerEvents = 'auto';
                                if (badge) {
                                    badge.textContent = 'OPEN';
                                    badge.classList.remove('bg-red-500/20', 'border-red-500/50', 'text-red-400');
                                    badge.classList.add('bg-green-500/20', 'border-green-500/50', 'text-green-400');
                                }
                            }
                        }
                    });
                });
            }
        } catch (err) {
            console.error('Error fetching tournaments:', err);
        }
    };

    // Polling pour vÃ©rifier si le tournoi a dÃ©marrÃ©
    const startPollingForStart = (tournamentId: string) => {
        // âœ… Nettoyer l'ancien polling avant d'en crÃ©er un nouveau
        if (pollInterval) {
            clearInterval(pollInterval);
        }

        pollInterval = setInterval(async () => {
            try {
                const host = import.meta.env.VITE_HOST || 'localhost:8443';
                const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}`);
                const data = await response.json();

                if (data.success && data.tournament.status === 'in_progress') {
                    cleanupIntervals(); // âœ… Nettoyer avant de continuer
                    startCountdownAndRedirect(tournamentId);
                }
            } catch (err) {
                console.error('Error polling tournament status:', err);
            }
        }, 1000);
        
        console.log('ğŸ”„ Started polling for tournament start');
    };

    // Countdown avant redirection
    const startCountdownAndRedirect = (tournamentId: string): void => {
        const countdownModal = document.getElementById('countdown');
        const countdownText = document.getElementById('countdown-text');
        
        if (!countdownModal || !countdownText) return;

        let count = 3;
        countdownModal.classList.remove('hidden');
        countdownModal.classList.add('flex');
        countdownText.textContent = count.toString();

        // Animation du modal
        gsap.from(countdownModal.querySelector('.neon-border'), {
            scale: 0.5,
            opacity: 0,
            duration: 0.5,
            ease: 'back.out(1.7)'
        });

        // âœ… Nettoyer l'ancien countdown avant d'en crÃ©er un nouveau
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }

        countdownInterval = setInterval(() => {
            count--;
            
            if (count > 0) {
                countdownText.textContent = count.toString();
                // Animation du chiffre
                gsap.fromTo(countdownText, 
                    { scale: 1.5, opacity: 0 },
                    { scale: 1, opacity: 1, duration: 0.5, ease: 'back.out' }
                );
            } else {
                cleanupIntervals(); // âœ… Nettoyer avant redirect
                countdownModal.classList.add('hidden');
                countdownModal.classList.remove('flex');
                window.router.navigate(`/tournament/${tournamentId}`);
            }
        }, 1000);
        
        console.log('â±ï¸ Countdown started');
    };

    // Fonction pour rejoindre un tournoi
    const handleJoinTournament = async (e: Event) => {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('ğŸ¯ Tournament card clicked!');
        
        const target = e.currentTarget as HTMLElement;
        
        // VÃ©rifier si le tournoi est plein
        if (target.classList.contains('disabled')) {
            console.log('âŒ Tournament is full');
            return;
        }

        const username = usernameInput.value.trim() || 'Anon';
        window.simpleAuth.setUsername(username);
        
        const tournamentId = target.getAttribute('data-tournament-id');

        if (!tournamentId) {
            console.error('No tournament ID found');
            return;
        }

        currentTournamentId = tournamentId;

        // Animation du clic
        gsap.to(target, {
            scale: 0.95,
            duration: 0.1,
            yoyo: true,
            repeat: 1
        });

        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const playerId = window.simpleAuth.getPlayerId();
            
            const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}/join`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, playerId })
            });

            const data = await response.json();

            if (data.success) {
                if (data.tournamentStarted) {
                    // Le tournoi dÃ©marre immÃ©diatement
                    startCountdownAndRedirect(data.tournamentId);
                } else {
                    // En attente d'autres joueurs
                    console.log(`âœ… Joined tournament: ${data.currentPlayers}/${data.maxPlayers} players`);
                    startPollingForStart(tournamentId);
                }
            } else {
                alert(data.error || 'Failed to join tournament');
            }
        } catch (err) {
            console.error('Error joining tournament:', err);
            alert('Failed to join tournament');
        }
    };

    // âœ… Stocker les handlers pour pouvoir les retirer
    const handlers = new Map<Element, EventListener>();

    // Attacher les event listeners
    tournamentBtns.forEach(tournamentBtn => {
        const handler = handleJoinTournament as EventListener;
        tournamentBtn.addEventListener("click", handler, { capture: true });
        handlers.set(tournamentBtn, handler);
    });

    // Polling initial et rÃ©gulier pour les stats
    fetchTournaments();
    const updateInterval = setInterval(fetchTournaments, 2000);
    console.log('ğŸ”„ Started tournament stats polling');

	// Enregistrer les cleanups existants
	cleanupManager.onCleanup(() => {
		cleanupIntervals();
		if (updateInterval) {
			clearInterval(updateInterval);
			console.log('ğŸ§¹ Update interval cleared');
		}
		handlers.forEach((handler, element) => {
			element.removeEventListener("click", handler, { capture: true });
		});
		handlers.clear();
	});

    // âœ… FONCTION DE CLEANUP COMPLÃˆTE
    return (): void => {
        console.log('ğŸ§¹ TournamentView: Cleaning up...');
		cleanupManager.cleanup();
        console.log('ğŸ§¹ Event listeners removed');

        // 3. Se dÃ©sinscrire du tournoi si on quitte la page
        if (currentTournamentId) {
            const playerId = window.simpleAuth.getPlayerId();
            if (playerId) {
                const host = import.meta.env.VITE_HOST || 'localhost:8443';
                fetch(`https://${host}/tournamentback/tournaments/leave/${playerId}`, {
                    method: 'DELETE'
                }).catch(err => console.error('Error leaving tournament:', err));
                console.log('ğŸšª Left tournament');
            }
        }

        console.log('âœ… TournamentView: Cleanup complete');
    };
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/HistoryView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction } from "../router/types";
import { BackButton } from "../components/Button";
import { gsap } from "gsap";
import { createCleanupManager } from "../utils/CleanupManager";

interface GameHistory {
    id: string;
    room_id: string;
    game_type: 'quickplay' | 'tournament';
    player_left_username: string;
    player_right_username: string;
    winner_username?: string;
    score_left: number;
    score_right: number;
    end_reason?: 'score' | 'timeout' | 'forfeit';
    created_at: string;
    duration_seconds?: number;
    tournament_id?: string;
}

export const HistoryView: ViewFunction = () => {
    return `
        <!-- Fond Ã©toilÃ© -->
        <div class="fixed inset-0 bg-[#04071A] overflow-hidden">
            ${Array.from({length: 150}, (_, i) => `
                <div 
                    class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
                    style="
                        width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                        height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        opacity: ${0.3 + Math.random() * 0.7};
                        ${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
                    "
                ></div>
            `).join('')}
            
            <!-- Ã‰toiles qui scintillent fort -->
            ${Array.from({length: 50}, (_) => `
                <div 
                    class="absolute"
                    style="
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
                    "
                >
                    <div class="w-[4px] h-[4px] bg-white rounded-full"></div>
                </div>
            `).join('')}
            
            <style>
                @keyframes strong-sparkle {
                    0%, 100% {
                        opacity: 0.3;
                        filter: blur(0px);
                    }
                    50% {
                        opacity: 1;
                        filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
                    }
                }
            </style>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen">
            <!-- Header avec BackButton -->
            <div class="p-8">
                ${BackButton({
                    size: "lg",
                    className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
                })}
            </div>

            <!-- Container principal -->
            <div class="container mx-auto px-8 pb-8">
                <!-- Titre -->
                <div class="text-center mb-8">
                    <h1 class="text-5xl font-bold text-white mb-2">Historique Global</h1>
                    <p class="text-white/60 text-lg">Toutes les parties jouÃ©es</p>
                </div>

                <!-- Filtres -->
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6 mb-6">
                    <div class="flex flex-wrap gap-4 items-center justify-between">
                        <div class="flex gap-4">
                            <button 
                                id="filter-all" 
                                class="filter-btn active px-6 py-2 rounded-lg bg-white/10 border border-white/20 text-white hover:bg-white/20 transition-all"
                                data-filter="all"
                            >
                                Toutes
                            </button>
                            <button 
                                id="filter-quickplay" 
                                class="filter-btn px-6 py-2 rounded-lg bg-white/10 border border-white/20 text-white hover:bg-white/20 transition-all"
                                data-filter="quickplay"
                            >
                                QuickPlay
                            </button>
                            <button 
                                id="filter-tournament" 
                                class="filter-btn px-6 py-2 rounded-lg bg-white/10 border border-white/20 text-white hover:bg-white/20 transition-all"
                                data-filter="tournament"
                            >
                                Tournois
                            </button>
                        </div>
                        
                        <div class="flex gap-4 items-center">
                            <span class="text-white/60">Trier par:</span>
                            <select 
                                id="sort-select" 
                                class="px-4 py-2 rounded-lg bg-[#101C69]/40 border border-white/20 text-white focus:outline-none focus:ring-2 focus:ring-white/50"
                            >
                                <option value="recent">Plus rÃ©cent</option>
                                <option value="oldest">Plus ancien</option>
                                <option value="duration">DurÃ©e</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Stats globales -->
                <div id="global-stats" class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                    <!-- Stats seront injectÃ©es ici -->
                </div>

                <!-- Loading state -->
                <div id="history-loading" class="text-center py-12">
                    <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
                    <p class="text-white/60 mt-4">Chargement de l'historique...</p>
                </div>

                <!-- Liste des parties -->
                <div id="history-list" style="display: none;" class="space-y-4">
                    <!-- Les parties seront injectÃ©es ici -->
                </div>

                <!-- Empty state -->
                <div id="history-empty" style="display: none;" class="text-center py-12">
                    <div class="text-6xl mb-4">ğŸ®</div>
                    <h3 class="text-2xl font-bold text-white mb-2">Aucune partie trouvÃ©e</h3>
                    <p class="text-white/60">Commencez Ã  jouer pour voir votre historique !</p>
                </div>

                <!-- Error state -->
                <div id="history-error" style="display: none;" class="text-center py-12">
                    <div class="text-6xl mb-4">âš ï¸</div>
                    <h3 class="text-2xl font-bold text-red-400 mb-2">Erreur de chargement</h3>
                    <p class="text-white/60">Impossible de charger l'historique</p>
                </div>
            </div>
        </div>
    `;
};

export const historyLogic = (): (() => void) => {
    const cleanupManager = createCleanupManager();
    let allGames: GameHistory[] = [];
    let filteredGames: GameHistory[] = [];
    let currentFilter: 'all' | 'quickplay' | 'tournament' = 'all';
    let currentSort: 'recent' | 'oldest' | 'duration' = 'recent';

    // Enregistrer les cibles GSAP
    cleanupManager.registerGsapTarget('.game-card');
    cleanupManager.registerGsapTarget('.stat-card');

    // Fonction pour rÃ©cupÃ©rer l'historique global
    const fetchHistory = async (): Promise<void> => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/gamedb/games/history`);
            
            if (!response.ok) {
                throw new Error('Failed to fetch history');
            }

            const data = await response.json();
            
            if (data.success) {
                allGames = data.games;
				console.log(allGames)
                applyFiltersAndSort();
                displayGames();
                displayGlobalStats();
                hideLoading();
            } else {
                showError();
            }
        } catch (err) {
            console.error('Error fetching history:', err);
            showError();
        }
    };

    // Appliquer les filtres et le tri
    const applyFiltersAndSort = (): void => {
        // Filtrer
        if (currentFilter === 'all') {
            filteredGames = [...allGames];
        } else {
            filteredGames = allGames.filter(game => game.game_type === currentFilter);
        }

        // Trier
        switch (currentSort) {
            case 'recent':
                filteredGames.sort((a, b) => 
                    new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
                );
                break;
            case 'oldest':
                filteredGames.sort((a, b) => 
                    new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
                );
                break;
            case 'duration':
                filteredGames.sort((a, b) => 
                    (b.duration_seconds || 0) - (a.duration_seconds || 0)
                );
                break;
        }
    };

    // Afficher les parties
    const displayGames = (): void => {
        const listElement = document.getElementById('history-list');
        const emptyElement = document.getElementById('history-empty');
        
        if (!listElement || !emptyElement) return;

        if (filteredGames.length === 0) {
            listElement.style.display = 'none';
            emptyElement.style.display = 'block';
            return;
        }

        listElement.style.display = 'block';
        emptyElement.style.display = 'none';

        listElement.innerHTML = filteredGames.map(game => {
            const isWinner = game.score_left > game.score_right;
            const isDraw = game.score_left === game.score_right;
            const resultIcon = isWinner ? 'ğŸ†' : isDraw ? 'ğŸ¤' : 'ğŸ’€';
            const winnerName = game.winner_username || (isWinner ? game.player_left_username : game.player_right_username);

            const date = new Date(game.created_at);
            const formattedDate = date.toLocaleDateString('fr-FR', {
                day: '2-digit',
                month: 'short',
                year: 'numeric'
            });
            const formattedTime = date.toLocaleTimeString('fr-FR', {
                hour: '2-digit',
                minute: '2-digit'
            });

            const duration = game.duration_seconds 
                ? `${Math.floor(game.duration_seconds / 60)}:${(game.duration_seconds % 60).toString().padStart(2, '0')}`
                : '-';

            const gameTypeLabel = game.game_type === 'tournament' ? 'ğŸ† Tournoi' : 'âš¡ QuickPlay';
            const gameTypeBg = game.game_type === 'tournament' ? 'bg-purple-500/20' : 'bg-blue-500/20';

            return `
                <a href="/history/${game.id}" class="block game-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6 hover:border-white/40 hover:bg-[#0C154D]/40 transition-all cursor-pointer">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center gap-4">
                            <div class="text-4xl">${resultIcon}</div>
                            <div>
                                <div class="text-2xl font-bold text-white">
                                    ${isDraw ? 'Ã‰GALITÃ‰' : `Victoire de ${winnerName}`}
                                </div>
                                <div class="text-white/60 text-sm">${formattedDate} Ã  ${formattedTime}</div>
                            </div>
                        </div>
                        <div class="text-right">
                            <div class="${gameTypeBg} px-4 py-2 rounded-lg text-white text-sm mb-2">
                                ${gameTypeLabel}
                            </div>
                            ${game.end_reason ? `
                                <div class="text-white/60 text-xs">
                                    ${game.end_reason === 'score' ? 'ğŸ¯ Score' : 
                                      game.end_reason === 'timeout' ? 'â±ï¸ Timeout' : 
                                      'ğŸš« Forfait'}
                                </div>
                            ` : ''}
                        </div>
                    </div>

                    <div class="grid grid-cols-3 gap-4 items-center">
                        <!-- Joueur gauche -->
                        <div class="text-center">
                            <div class="text-white font-semibold text-lg mb-2">
                                ${game.player_left_username}
                            </div>
                            <div class="text-4xl font-bold ${game.score_left > game.score_right ? 'text-green-400' : 'text-white/60'}">
                                ${game.score_left}
                            </div>
                        </div>

                        <!-- VS -->
                        <div class="text-center">
                            <div class="text-white/40 text-2xl font-bold">VS</div>
                            ${duration !== '-' ? `
                                <div class="text-white/60 text-sm mt-2">
                                    â±ï¸ ${duration}
                                </div>
                            ` : ''}
                        </div>

                        <!-- Joueur droit -->
                        <div class="text-center">
                            <div class="text-white font-semibold text-lg mb-2">
                                ${game.player_right_username}
                            </div>
                            <div class="text-4xl font-bold ${game.score_right > game.score_left ? 'text-green-400' : 'text-white/60'}">
                                ${game.score_right}
                            </div>
                        </div>
                    </div>

                    <div class="mt-4 pt-4 border-t border-white/10 text-center">
                        <span class="text-blue-400 hover:text-blue-300 text-sm">
                            â†’ Voir les dÃ©tails
                        </span>
                    </div>
                </a>
            `;
        }).join('');

        // Animation d'entrÃ©e
        gsap.fromTo('.game-card', 
            { opacity: 0, y: 20 },
            { 
                opacity: 1, 
                y: 0, 
                duration: 0.5, 
                stagger: 0.1,
                ease: 'power2.out'
            }
        );
    };

    // Afficher les stats globales
    const displayGlobalStats = (): void => {
        const statsElement = document.getElementById('global-stats');
        if (!statsElement) return;

        const totalGames = allGames.length;
        const quickplayGames = allGames.filter(g => g.game_type === 'quickplay').length;
        const tournamentGames = allGames.filter(g => g.game_type === 'tournament').length;

        const totalDuration = allGames.reduce((sum, game) => sum + (game.duration_seconds || 0), 0);
        let avgDuration = '0:00';
        if (totalGames > 0) {
            const avgSeconds = totalDuration / totalGames;
            const minutes = Math.floor(avgSeconds / 60);
            const seconds = Math.floor(avgSeconds % 60);
            avgDuration = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        statsElement.innerHTML = `
            <div class="stat-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                <div class="text-white/60 text-sm mb-2">Total Parties</div>
                <div class="text-4xl font-bold text-white">${totalGames}</div>
            </div>
            
            <div class="stat-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                <div class="text-white/60 text-sm mb-2">QuickPlay</div>
                <div class="text-4xl font-bold text-blue-400">${quickplayGames}</div>
            </div>
            
            <div class="stat-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                <div class="text-white/60 text-sm mb-2">Tournois</div>
                <div class="text-4xl font-bold text-purple-400">${tournamentGames}</div>
            </div>
            
            <div class="stat-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                <div class="text-white/60 text-sm mb-2">DurÃ©e Moyenne</div>
                <div class="text-4xl font-bold text-green-400">${avgDuration}</div>
            </div>
        `;

        // Animation des stats
        gsap.fromTo('.stat-card', 
            { scale: 0.8, opacity: 0 },
            { 
                scale: 1, 
                opacity: 1, 
                duration: 0.5, 
                stagger: 0.1,
                ease: 'back.out(1.7)'
            }
        );
    };

    // Gestion des filtres
    const handleFilterClick = (e: Event): void => {
        const target = e.target as HTMLElement;
        const filter = target.dataset.filter as 'all' | 'quickplay' | 'tournament';
        
        if (!filter) return;

        currentFilter = filter;

        // Mettre Ã  jour l'UI des boutons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.remove('active', 'bg-white/30');
        });
        target.classList.add('active', 'bg-white/30');

        applyFiltersAndSort();
        displayGames();
    };

    // Gestion du tri
    const handleSortChange = (e: Event): void => {
        const target = e.target as HTMLSelectElement;
        currentSort = target.value as 'recent' | 'oldest' | 'duration';
        
        applyFiltersAndSort();
        displayGames();
    };

    // Utilitaires d'affichage
    const hideLoading = (): void => {
        const loading = document.getElementById('history-loading');
        if (loading) loading.style.display = 'none';
    };

    const showError = (): void => {
        hideLoading();
        const error = document.getElementById('history-error');
        if (error) error.style.display = 'block';
    };

    // Attacher les event listeners
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', handleFilterClick);
    });

    const sortSelect = document.getElementById('sort-select');
    if (sortSelect) {
        sortSelect.addEventListener('change', handleSortChange);
    }

    // Charger l'historique
    fetchHistory();

    // Enregistrer le cleanup
    cleanupManager.onCleanup(() => {
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.removeEventListener('click', handleFilterClick);
        });

        if (sortSelect) {
            sortSelect.removeEventListener('change', handleSortChange);
        }
    });

    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/CreateAccountView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction } from "../router/types";
import { gsap } from "gsap";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

export const CreateAccountView: ViewFunction = () => {
    const content = `
            <div class="flex-1 flex items-center justify-center px-4 py-12">
                <div class="w-full max-w-6xl grid grid-cols-1 md:grid-cols-2 gap-8">
                    
                    <!-- CÃ´tÃ© gauche - Animation/Image -->
                    <div class="flex items-center justify-center p-8" id="left-panel">
                        <div class="relative w-full h-full min-h-[500px] neon-border bg-black/50 backdrop-blur-sm rounded-lg overflow-hidden flex items-center justify-center">
                            <!-- GIF ou animation -->
                            <img 
                                src="/sprites/dancing-cat.gif" 
                                alt="Animation"
                                class="w-full h-full object-contain"
                                style="image-rendering: pixelated;"
                            />
                            
                            <!-- Overlay avec effet nÃ©on -->
                            <div class="absolute inset-0 pointer-events-none" style="
                                background: radial-gradient(circle at center, transparent 40%, rgba(59, 130, 246, 0.1) 100%);
                            "></div>
                        </div>
                    </div>

                    <!-- CÃ´tÃ© droit - Formulaire -->
                    <div class="flex flex-col justify-center p-8 neon-border bg-black/50 backdrop-blur-sm rounded-lg relative" id="right-panel">
                        <!-- Titre -->
                        <div class="text-center mb-8">
                            <h1 class="pixel-font text-4xl md:text-5xl text-blue-400 mb-2" 
                                style="animation: neonPulse 2s ease-in-out infinite;"
                                id="create-title">
                                HELLO!
                            </h1>
                            <h2 class="pixel-font text-xl md:text-2xl text-blue-300 opacity-80">
                                Create your account
                            </h2>
                        </div>

                        <!-- Message d'erreur -->
                        <div id="error-message" class="hidden mb-4 p-3 neon-border bg-red-500/10 rounded">
                            <p class="pixel-font text-xs text-red-400 text-center"></p>
                        </div>

                        <!-- Formulaire -->
                        <form action="/create" method="POST" id="createForm" class="space-y-6">
                            <!-- Username -->
                            <div>
                                <label for="username" class="block mb-2 pixel-font text-sm text-blue-300">
                                    USERNAME:
                                </label>
                                <input 
                                    type="text" 
                                    id="username" 
                                    name="username"
                                    placeholder="Enter username"
                                    required
                                    minlength="3"
                                    maxlength="20"
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Password -->
                            <div>
                                <label for="password" class="block mb-2 pixel-font text-sm text-blue-300">
                                    PASSWORD:
                                </label>
                                <input 
                                    type="password" 
                                    id="password" 
                                    name="password"
                                    placeholder="Enter password"
                                    required
                                    minlength="6"
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Confirm Password -->
                            <div>
                                <label for="confirmpassword" class="block mb-2 pixel-font text-sm text-blue-300">
                                    CONFIRM PASSWORD:
                                </label>
                                <input 
                                    type="password" 
                                    id="confirmpassword" 
                                    name="confirmpassword"
                                    placeholder="Confirm your password"
                                    required
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Bouton Submit -->
                            <button 
                                type="submit" 
                                class="w-full py-3 pixel-font text-sm neon-border bg-blue-500/20 text-blue-400 hover:bg-blue-500/40 hover:text-white transition-all"
                                id="submit-btn"
                            >
                                >>> CREATE ACCOUNT <<<
                            </button>
                        </form>

                        <!-- Lien vers login -->
                        <div class="mt-6 text-center">
                            <p class="pixel-font text-xs text-blue-300/60 mb-3">
                                Already have an account?
                            </p>
                            <a 
                                href="/login" 
                                class="pixel-font text-sm text-blue-400 hover:text-blue-300 transition-colors inline-block"
                            >
                                >>> LOGIN <<<
                            </a>
                        </div>
                    </div>
                </div>
            </div>
    `;

    return Layout.render(content, {
        showBackButton: true,
        showFooter: true
    });
};

export const createAccountLogic = (): (() => void) => {
    const cleanupManager = createCleanupManager();

    // Enregistrer les cibles GSAP
    cleanupManager.registerGsapTarget('#create-title');
    cleanupManager.registerGsapTarget('#left-panel');
    cleanupManager.registerGsapTarget('#right-panel');
    cleanupManager.registerGsapTarget('#error-message');

    gsap.from('#create-title', {
        scale: 0.5,
        opacity: 0,
        duration: 1,
        ease: 'back.out(1.7)'
    });

    gsap.from('#left-panel', {
        x: -100,
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
    });

    gsap.from('#right-panel', {
        x: 100,
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
    });

    // Gestion du formulaire
    const form = document.getElementById('createForm') as HTMLFormElement;
    const errorMessage = document.getElementById('error-message');
    const errorText = errorMessage?.querySelector('p');
    
    const showError = (message: string) => {
        if (errorMessage && errorText) {
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
            
            // Animation de l'erreur
            gsap.fromTo(errorMessage, 
                { scale: 0.8, opacity: 0 },
                { scale: 1, opacity: 1, duration: 0.3, ease: 'back.out' }
            );
        }
    };

    const hideError = () => {
        if (errorMessage) {
            errorMessage.classList.add('hidden');
        }
    };

    const handleSubmit = (e: Event) => {
        e.preventDefault();
        hideError();
        
        const username = (document.getElementById('username') as HTMLInputElement).value;
        const password = (document.getElementById('password') as HTMLInputElement).value;
        const confirmPassword = (document.getElementById('confirmpassword') as HTMLInputElement).value;

        // Validation
        if (username.length < 3 || username.length > 20) {
            showError('âš ï¸ Username must be between 3 and 20 characters');
            return;
        }

        if (password.length < 6) {
            showError('âš ï¸ Password must be at least 6 characters');
            return;
        }

        if (password !== confirmPassword) {
            showError('âš ï¸ Passwords do not match');
            
            // Ajouter classe error aux champs password
            const passwordInput = document.getElementById('password') as HTMLInputElement;
            const confirmInput = document.getElementById('confirmpassword') as HTMLInputElement;
            passwordInput?.classList.add('error');
            confirmInput?.classList.add('error');

            // Retirer aprÃ¨s 2 secondes
            cleanupManager.setTimeout(() => {
                passwordInput?.classList.remove('error');
                confirmInput?.classList.remove('error');
            }, 2000);
            
            return;
        }

        // Animation du bouton
        const submitBtn = document.getElementById('submit-btn');
        if (submitBtn) {
            gsap.to(submitBtn, {
                scale: 0.95,
                duration: 0.1,
                yoyo: true,
                repeat: 1
            });
        }

        // TODO: Logique de crÃ©ation de compte rÃ©elle
        console.log('Create account attempt:', { username, password });
        
        // Animation de succÃ¨s
        gsap.to('#right-panel', {
            scale: 1.05,
            duration: 0.2,
            yoyo: true,
            repeat: 1,
            onComplete: () => {
                // Exemple de redirection aprÃ¨s succÃ¨s
                // window.router.navigate('/login');
            }
        });
    };

    if (form) {
        form.addEventListener('submit', handleSubmit);
    }

    // Enregistrer le cleanup
    cleanupManager.onCleanup(() => {
        if (form) {
            form.removeEventListener('submit', handleSubmit);
        }
    });

    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/LocalTournamentSetupView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { LocalTournamentManager, type LocalPlayer } from "../utils/localTournamentManager";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

export const LocalTournamentSetupView: ViewFunction = () => {
	const content = `
			<style>
				.size-selector {
					cursor: pointer;
					transition: all 0.3s ease;
				}

				.size-selector.active {
					background: rgba(59, 130, 246, 0.3);
					border-color: #60A5FA;
					transform: scale(1.05);
				}
			</style>

			<div class="flex-1 flex items-center justify-center px-4 py-12">
				<div class="w-full max-w-6xl">

					<!-- Titre principal -->
					<div class="text-center mb-8">
						<h1 class="pixel-font text-4xl md:text-6xl text-blue-400 mb-4"
							style="animation: neonPulse 2s ease-in-out infinite;"
							id="tournament-title">
							ğŸ† LOCAL TOURNAMENT ğŸ†
						</h1>
						<p class="pixel-font text-lg text-blue-300 opacity-80">
							>>> MULTIPLAYER CHAMPIONSHIP <<<
						</p>
					</div>

					<!-- SÃ©lection de la taille -->
					<div id="size-selection" class="mb-8">
						<div class="text-center mb-4">
							<p class="pixel-font text-sm text-blue-300">SELECT TOURNAMENT SIZE:</p>
						</div>
						<div class="flex justify-center gap-4">
							<div
								class="size-selector neon-border rounded-lg p-6 text-center active"
								data-size="4"
							>
								<div class="pixel-font text-3xl text-blue-400 mb-2">4</div>
								<div class="pixel-font text-xs text-blue-300">PLAYERS</div>
							</div>
							<div
								class="size-selector neon-border rounded-lg p-6 text-center"
								data-size="8"
							>
								<div class="pixel-font text-3xl text-blue-400 mb-2">8</div>
								<div class="pixel-font text-xs text-blue-300">PLAYERS</div>
							</div>
						</div>
					</div>

					<!-- Formulaire des joueurs -->
					<form id="tournament-setup-form" class="space-y-6">
						<div id="players-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
							<!-- Players will be generated dynamically -->
						</div>

						<!-- Bouton START -->
						<div class="flex justify-center mt-8">
							<button
								type="submit"
								class="pixel-font px-12 py-4 text-xl neon-border bg-blue-500/20 text-blue-400 hover:bg-blue-500/40 transition-all"
								id="start-tournament-btn"
							>
								START TOURNAMENT
							</button>
						</div>
					</form>

				</div>
			</div>
	`;

	return Layout.render(content, {
		showBackButton: true,
		showFooter: false
	});
};

const generateId = (): string => {
	if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
		return crypto.randomUUID();
	}
	return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
};

const generatePlayerCards = (count: number): string => {
	const colors = [
		'blue', 'red', 'green', 'yellow',
		'purple', 'pink', 'cyan', 'orange'
	];

	let html = '';
	for (let i = 0; i < count; i++) {
		const color = colors[i % colors.length];
		html += `
			<div class="player-card neon-border rounded-lg p-4" data-player-index="${i}">
				<div class="mb-3">
					<h3 class="pixel-font text-lg text-${color}-400 mb-2">PLAYER ${i + 1}</h3>
				</div>

				<div class="mb-3">
					<label class="block mb-1 pixel-font text-xs text-${color}-300">
						USERNAME:
					</label>
					<input
						type="text"
						name="player-${i}-name"
						placeholder="Player ${i + 1}"
						maxlength="24"
						required
						class="w-full p-2 rounded pixel-font text-sm neon-input"
					/>
				</div>

				<div>
					<label class="block mb-1 pixel-font text-xs text-${color}-300">
						SKILL:
					</label>
					<select
						name="player-${i}-skill"
						class="w-full p-2 rounded pixel-font text-xs neon-input cursor-pointer"
					>
						<option value="smash">ğŸ’¥ Smash</option>
						<option value="dash">âš¡ Dash</option>
					</select>
				</div>
			</div>
		`;
	}
	return html;
};

export const localTournamentSetupLogic = (): CleanupFunction => {
	const cleanupManager = createCleanupManager();
	let currentSize = 4;

	// Enregistrer les cibles GSAP
	cleanupManager.registerGsapTarget('#tournament-title');
	cleanupManager.registerGsapTarget('.player-card');

	// Fonction pour mettre Ã  jour les cartes de joueurs
	const updatePlayerCards = (size: number) => {
		const container = document.getElementById('players-container');
		if (container) {
			container.innerHTML = generatePlayerCards(size);

			// Animer l'apparition des cartes
			gsap.fromTo(
				'.player-card',
				{ opacity: 0, y: 20 },
				{ opacity: 1, y: 0, duration: 0.3, stagger: 0.05 }
			);
		}
	};

	// Initialiser avec 4 joueurs
	updatePlayerCards(currentSize);

	// GÃ©rer la sÃ©lection de la taille
	const sizeSelectors = document.querySelectorAll('.size-selector');
	sizeSelectors.forEach(selector => {
		selector.addEventListener('click', () => {
			const size = parseInt(selector.getAttribute('data-size') || '4');
			currentSize = size;

			// Mettre Ã  jour l'Ã©tat actif
			sizeSelectors.forEach(s => s.classList.remove('active'));
			selector.classList.add('active');

			// Mettre Ã  jour les cartes de joueurs
			updatePlayerCards(size);
		});
	});

	// Animer le titre
	const title = document.getElementById('tournament-title');
	if (title) {
		gsap.fromTo(
			title,
			{ opacity: 0, scale: 0.5 },
			{ opacity: 1, scale: 1, duration: 0.8, ease: 'back.out(1.7)' }
		);
	}

	// GÃ©rer la soumission du formulaire
	const form = document.getElementById('tournament-setup-form') as HTMLFormElement;
	const handleSubmit = (e: Event) => {
		e.preventDefault();

		const formData = new FormData(form);
		const players: Omit<LocalPlayer, 'eliminated'>[] = [];

		// Collecter les donnÃ©es des joueurs
		for (let i = 0; i < currentSize; i++) {
			const username = formData.get(`player-${i}-name`) as string;
			const selectedSkill = formData.get(`player-${i}-skill`) as 'smash' | 'dash';

			if (!username || username.trim() === '') {
				alert(`Please enter a name for Player ${i + 1}`);
				return;
			}

			players.push({
				id: generateId(),
				username: username.trim(),
				selectedSkill,
			});
		}

		// VÃ©rifier les noms en double
		const usernames = players.map(p => p.username.toLowerCase());
		const hasDuplicates = usernames.some((name, index) => usernames.indexOf(name) !== index);
		if (hasDuplicates) {
			alert('Player names must be unique!');
			return;
		}

		try {
			// CrÃ©er le tournoi
			const tournament = LocalTournamentManager.createTournament(
				currentSize as 4 | 8,
				players
			);

			console.log('Tournament created:', tournament);

			// Rediriger vers la vue du bracket
			window.router.navigate('/local-tournament-bracket');
		} catch (error) {
			console.error('Error creating tournament:', error);
			alert('Failed to create tournament. Please try again.');
		}
	};

	form?.addEventListener('submit', handleSubmit);

	// Enregistrer le cleanup
	cleanupManager.onCleanup(() => {
		form?.removeEventListener('submit', handleSubmit);
		sizeSelectors.forEach(selector => {
			selector.removeEventListener('click', () => {});
		});
	});

	return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/QuickPlayView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

export const QuickPlayView: ViewFunction = () => {
	const content = `
			<div class="flex-1 flex items-center justify-center px-4 py-12">
				<div class="w-full max-w-4xl">
					
					<!-- Titre principal -->
					<div class="text-center mb-12">
						<h1 class="pixel-font text-5xl md:text-6xl text-blue-400 mb-4" 
							style="animation: neonPulse 2s ease-in-out infinite;"
							id="quickplay-title">
							âš¡ QUICKPLAY âš¡
						</h1>
						<p class="pixel-font text-lg text-blue-300 opacity-80">
							>>> SELECT YOUR SKILL <<<
						</p>
					</div>
					<!-- 2d-3d toggle -->
					<div id="view-mode-toggle-container" class="switch-button mx-auto mb-8 neon-border rounded-lg pixel-font text-blue-400 overflow-hidden w-60 text-center text-lg tracking-[1px] relative pl-[5px] pr-[125px] py-[5px]">
						<input id="view-mode-toggle" class="switch-button-checkbox cursor-pointer absolute w-full h-full opacity-0 z-[2] left-0 inset-y-0" type="checkbox" />
						<label class="switch-button-label relative block select-none pointer-events-none px-0 py-[15px]" for="view-mode-toggle"><span class="switch-button-label-span relative">2D</span></label>
					</div>
					<!-- Section Skills -->
					<div class="mb-12 neon-border bg-black/50 backdrop-blur-sm rounded-lg p-8" id="skills-section">
						<h2 class="pixel-font text-2xl text-blue-400 mb-6 text-center">
							CHOOSE YOUR ABILITY
						</h2>
						
						<div class="grid grid-cols-1 md:grid-cols-2 gap-6" data-skill-options>
							<!-- Smash Card -->
							<div 
								class="skill-card neon-border rounded-lg p-6 relative selected" 
								data-skill-option="smash"
								id="skill-smash"
							>
								<!-- Badge sÃ©lectionnÃ© -->
								<div class="absolute top-3 right-3 pixel-font text-xs text-green-400 bg-green-500/20 px-2 py-1 rounded border border-green-500/50">
									âœ“ SELECTED
								</div>
							
								<!-- IcÃ´ne -->
								<div class="text-5xl mb-4 text-center">ğŸ’¥</div>
								
								<!-- Titre -->
								<h3 class="pixel-font text-xl text-blue-400 mb-3 text-center uppercase">
									Smash
								</h3>
								
								<!-- Description -->
								<p class="pixel-font text-sm text-blue-300 opacity-80 text-center leading-relaxed flex-grow">
									Charge a powerful strike that sends the ball back faster and can surprise your opponent
								</p>
							
								<!-- Stats -->
								<div class="mt-4 pt-4 border-t border-blue-500/30 space-y-2">
									<div class="flex justify-between pixel-font text-xs text-blue-300">
										<span>Cooldown:</span>
										<span class="text-yellow-400">3s</span>
									</div>
									<div class="flex justify-between pixel-font text-xs text-blue-300">
										<span>Power:</span>
										<span class="text-green-400">â˜…â˜…â˜…â˜…â˜†</span>
									</div>
								</div>
							
								<!-- FlÃ¨ches dÃ©coratives MIEUX POSITIONNÃ‰ES -->
								<div class="absolute bottom-2 left-0 right-0 flex justify-between px-3 pointer-events-none">
									<div class="text-red-500 text-sm opacity-80">â†</div>
									<div class="text-red-500 text-sm opacity-80">â†’</div>
								</div>
							</div>
							
							<!-- Dash Card -->
							<div 
								class="skill-card neon-border rounded-lg p-6 relative" 
								data-skill-option="dash"
								id="skill-dash"
							>
								<!-- Badge sÃ©lectionnÃ© (cachÃ© par dÃ©faut) -->
								<div class="absolute top-3 right-3 pixel-font text-xs text-green-400 bg-green-500/20 px-2 py-1 rounded border border-green-500/50 hidden">
									âœ“ SELECTED
								</div>
							
								<!-- IcÃ´ne -->
								<div class="text-5xl mb-4 text-center text-blue-500">âš¡</div>
								
								<!-- Titre -->
								<h3 class="pixel-font text-xl text-blue-400 mb-3 text-center uppercase">
									Dash
								</h3>
								
								<!-- Description -->
								<p class="pixel-font text-sm text-blue-300 opacity-80 text-center leading-relaxed flex-grow">
									Make a quick move with your paddle to catch difficult balls
								</p>
							
								<!-- Stats -->
								<div class="mt-4 pt-4 border-t border-blue-500/30 space-y-2">
									<div class="flex justify-between pixel-font text-xs text-blue-300">
										<span>Cooldown:</span>
										<span class="text-yellow-400">5s</span>
									</div>
									<div class="flex justify-between pixel-font text-xs text-blue-300">
										<span>Speed:</span>
										<span class="text-green-400">â˜…â˜…â˜…â˜…â˜…</span>
									</div>
								</div>
							
								<!-- FlÃ¨ches dÃ©coratives MIEUX POSITIONNÃ‰ES -->
								<div class="absolute bottom-2 left-0 right-0 flex justify-between px-3 pointer-events-none">
									<div class="text-blue-500 text-sm opacity-80">â†</div>
									<div class="text-blue-500 text-sm opacity-80">â†’</div>
								</div>
							</div>
						</div>

						<!-- Skill sÃ©lectionnÃ© -->
						<div class="mt-6 text-center">
							<p id="selected-skill-label" class="pixel-font text-sm text-blue-300">
								Selected skill: <span class="text-blue-400 font-bold">SMASH</span>
							</p>
						</div>
					</div>

					<!-- Section Modes de jeu -->
					<div class="space-y-4" id="modes-section">
						<!-- Play Online -->
						<button 
							id="play-online" 
							class="mode-button w-full p-6 neon-border rounded-lg pixel-font text-lg text-blue-400 hover:text-white transition-all relative group"
						>
							<div class="flex items-center justify-between">
								<div class="flex items-center gap-4">
									<span class="text-3xl">ğŸŒ</span>
									<div class="text-left">
										<div class="text-xl">PLAY ONLINE</div>
										<div class="text-xs opacity-60 font-normal">Find an opponent and start playing</div>
									</div>
								</div>
								<span class="text-2xl group-hover:translate-x-2 transition-transform">â†’</span>
							</div>
						</button>

						<!-- Play Local -->
						<button
							id="play-local"
							class="mode-button w-full p-6 neon-border rounded-lg pixel-font text-lg text-blue-400 hover:text-white transition-all relative group"
						>
							<div class="flex items-center justify-between">
								<div class="flex items-center gap-4">
									<span class="text-3xl">ğŸ®</span>
									<div class="text-left">
										<div class="text-xl">PLAY LOCAL</div>
										<div class="text-xs opacity-60 font-normal">Two players, one screen</div>
									</div>
								</div>
								<span class="text-2xl group-hover:translate-x-2 transition-transform">â†’</span>
							</div>
						</button>

						<!-- Local Tournament -->
						<button
							id="play-local-tournament"
							class="mode-button w-full p-6 neon-border rounded-lg pixel-font text-lg text-blue-400 hover:text-white transition-all relative group"
						>
							<div class="flex items-center justify-between">
								<div class="flex items-center gap-4">
									<span class="text-3xl">ğŸ†</span>
									<div class="text-left">
										<div class="text-xl">LOCAL TOURNAMENT</div>
										<div class="text-xs opacity-60 font-normal">4 or 8 players championship</div>
									</div>
								</div>
								<span class="text-2xl group-hover:translate-x-2 transition-transform">â†’</span>
							</div>
						</button>

						<!-- Play vs AI -->
						<button
							id="play-vs-ai"
							class="mode-button w-full p-6 neon-border rounded-lg pixel-font text-lg text-blue-400 hover:text-white transition-all relative group"
						>
							<div class="flex items-center justify-between">
								<div class="flex items-center gap-4">
									<span class="text-3xl">ğŸ¤–</span>
									<div class="text-left">
										<div class="text-xl">PLAY VS AI</div>
										<div class="text-xs opacity-60 font-normal">Let the AI control your paddle</div>
									</div>
								</div>
								<span class="text-2xl group-hover:translate-x-2 transition-transform">â†’</span>
							</div>
						</button>
					</div>

				</div>
			</div>
	`;

	return Layout.render(content, {
		showBackButton: true,
		showSignInButton: true,
		showFooter: true
	});
};

export const quickPlayLogic = (): CleanupFunction => {
	const cleanupManager = createCleanupManager();

	// Enregistrer les cibles GSAP
	cleanupManager.registerGsapTarget('#quickplay-title');
	cleanupManager.registerGsapTarget('#skills-section');
	cleanupManager.registerGsapTarget('#modes-section');

	// Animations d'entrÃ©e
	gsap.from('#quickplay-title', {
		scale: 0.5,
		opacity: 0,
		duration: 1,
		ease: 'back.out(1.7)'
	});

	gsap.from('#skills-section', {
		y: 50,
		opacity: 0,
		duration: 0.8,
		delay: 0.3,
		ease: 'power2.out'
	});

	gsap.from('#modes-section', {
		y: 50,
		opacity: 0,
		duration: 0.8,
		delay: 0.5,
		ease: 'power2.out'
	});

	const skillButtons = Array.from(
		document.querySelectorAll<HTMLButtonElement>('[data-skill-option]')
	);
	const playButton = document.getElementById('play-online') as HTMLButtonElement | null;
	const playVsAIButton = document.getElementById('play-vs-ai') as HTMLButtonElement | null;
	const localButton = document.getElementById('play-local') as HTMLButtonElement | null;
	const localTournamentButton = document.getElementById('play-local-tournament') as HTMLButtonElement | null;
	const label = document.getElementById('selected-skill-label');

	let selectedSkill = (sessionStorage.getItem('selectedSkill') as 'smash' | 'dash' | null) || 'smash';
	sessionStorage.setItem('selectedSkill', selectedSkill);

	const updateUI = () => {
		skillButtons.forEach(btn => {
			const isActive = btn.dataset.skillOption === selectedSkill;
			const badge = btn.querySelector('.absolute.top-3.right-3');
			
			if (isActive) {
				btn.classList.add('selected');
				badge?.classList.remove('hidden');
			} else {
				btn.classList.remove('selected');
				badge?.classList.add('hidden');
			}
			
			btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
		});

		if (label) {
			const skillName = selectedSkill === 'smash' ? 'SMASH' : 'DASH';
			label.innerHTML = `Selected skill: <span class="text-blue-400 font-bold">${skillName}</span>`;
		}
	};

	const handleSkillClick = (event: Event) => {
		event.preventDefault();
		const target = event.currentTarget as HTMLButtonElement | null;
		const skill = target?.dataset.skillOption;
		if (!skill || (skill !== 'smash' && skill !== 'dash')) {
			return;
		}
		
		// Animation de sÃ©lection
		gsap.to(target, {
			scale: 0.95,
			duration: 0.1,
			yoyo: true,
			repeat: 1
		});

		selectedSkill = skill;
		sessionStorage.setItem('selectedSkill', selectedSkill);
		updateUI();
	};

	const listeners: Array<{ element: HTMLElement; handler: (event: Event) => void }> = [];

	skillButtons.forEach(btn => {
		const handler = handleSkillClick.bind(btn);
		btn.addEventListener('click', handler);
		listeners.push({ element: btn, handler });
	});

	if (playButton) {
		const playHandler = (event: MouseEvent) => {
			event.preventDefault();
			if (!selectedSkill) {
				selectedSkill = 'smash';
				sessionStorage.setItem('selectedSkill', selectedSkill);
			}
			// which view mode selected
			const viewModeToggle = document.getElementById('view-mode-toggle') as HTMLInputElement | null;
			const is3D = viewModeToggle?.checked || false;
			sessionStorage.setItem('viewMode', is3D ? '3d' : '2d');
			// Animation du bouton
			gsap.to(playButton, {
				scale: 0.95,
				duration: 0.1,
				yoyo: true,
				repeat: 1,
				onComplete: () => {
					window.router.navigate('/play/waiting');
				}
			});
		};
		playButton.addEventListener('click', playHandler);
		listeners.push({ element: playButton, handler: playHandler as unknown as (e: Event) => void });
	}

	if (playVsAIButton) {
		const playAIHandler = async (event: MouseEvent) => {
			event.preventDefault();
			if (!selectedSkill) {
				selectedSkill = 'smash';
				sessionStorage.setItem('selectedSkill', selectedSkill);
			}

			const host = import.meta.env.VITE_HOST || 'localhost:8443';
			const createEndpoint = import.meta.env.VITE_CREATEGAME_ENDPOINT || '/gameback/create';
			const gameEndpoint = import.meta.env.VITE_GAME_ENDPOINT || '/gameback/game';
			const makeId = () => {
				if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
					return crypto.randomUUID();
				}
				return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
			};

			const roomId = makeId();
			const aiId = `ai-${makeId()}`;
			const username = window.simpleAuth.getUsername?.() || 'Player';
			const playerId = window.simpleAuth.getPlayerId?.();
			if (!playerId) {
				console.warn('QuickPlay: no playerId, redirecting to login');
				window.router.navigate('/login');
				return;
			}

			try {
				const response = await fetch(`https://${host}${createEndpoint}`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						roomId,
						player1: { id: playerId, username, selectedSkill },
						player2: { id: aiId, username: 'AI', selectedSkill: 'smash' }
					})
				});
				if (!response.ok) {
					throw new Error(`Server error (${response.status})`);
				}

				const wsUrl = `wss://${host}${gameEndpoint}/${roomId}`;
				sessionStorage.setItem('gameWsURL', wsUrl);
				sessionStorage.setItem('aiPlayerId', aiId);
				sessionStorage.setItem('aiSide', 'right');

				gsap.to(playVsAIButton, {
					scale: 0.95,
					duration: 0.1,
					yoyo: true,
					repeat: 1,
					onComplete: () => {
						window.router.navigate(`/game/${roomId}`);
					}
				});
			} catch (err) {
				console.error('QuickPlay: failed to create AI match', err);
			}
		};
		playVsAIButton.addEventListener('click', playAIHandler);
		listeners.push({ element: playVsAIButton, handler: playAIHandler as unknown as (e: Event) => void });
	}

	if (localButton) {
		const localHandler = (event: MouseEvent) => {
			event.preventDefault();
			gsap.to(localButton, {
				scale: 0.95,
				duration: 0.1,
				yoyo: true,
				repeat: 1,
				onComplete: () => {
					window.router?.navigateTo('/local');
				}
			});
		};
		localButton.addEventListener('click', localHandler);
		listeners.push({ element: localButton, handler: localHandler as unknown as (e: Event) => void });
	}

	if (localTournamentButton) {
		const localTournamentHandler = (event: MouseEvent) => {
			event.preventDefault();
			gsap.to(localTournamentButton, {
				scale: 0.95,
				duration: 0.1,
				yoyo: true,
				repeat: 1,
				onComplete: () => {
					window.router?.navigateTo('/local-tournament-setup');
				}
			});
		};
		localTournamentButton.addEventListener('click', localTournamentHandler);
		listeners.push({ element: localTournamentButton, handler: localTournamentHandler as unknown as (e: Event) => void });
	}

	updateUI();

	// Enregistrer le cleanup des event listeners
	cleanupManager.onCleanup(() => {
		listeners.forEach(({ element, handler }) => {
			element.removeEventListener('click', handler);
		});
	});

	return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/LoginView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction } from "../router/types";
import { gsap } from "gsap";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

export const LoginView: ViewFunction = () => {
    const content = `
            <div class="flex-1 flex items-center justify-center px-4 py-12">
                <div class="w-full max-w-6xl grid grid-cols-1 md:grid-cols-2 gap-8">
                    
                    <!-- CÃ´tÃ© gauche - Animation/Image -->
                    <div class="flex items-center justify-center p-8" id="left-panel">
                        <div class="relative w-full h-full min-h-[400px] neon-border bg-black/50 backdrop-blur-sm rounded-lg overflow-hidden flex items-center justify-center">
                            <!-- GIF ou animation -->
                            <img 
                                src="/sprites/cat.gif" 
                                alt="Animation"
                                class="w-full h-full object-contain"
                                style="image-rendering: pixelated;"
                            />
                            
                            <!-- Overlay avec effet nÃ©on -->
                            <div class="absolute inset-0 pointer-events-none" style="
                                background: radial-gradient(circle at center, transparent 40%, rgba(59, 130, 246, 0.1) 100%);
                            "></div>
                        </div>
                    </div>

                    <!-- CÃ´tÃ© droit - Formulaire -->
                    <div class="flex flex-col justify-center p-8 neon-border bg-black/50 backdrop-blur-sm rounded-lg" id="right-panel">
                        <!-- Titre -->
                        <div class="text-center mb-8">
                            <h1 class="pixel-font text-4xl md:text-5xl text-blue-400 mb-2" 
                                style="animation: neonPulse 2s ease-in-out infinite;"
                                id="login-title">
                                HELLO!
                            </h1>
                            <h2 class="pixel-font text-xl md:text-2xl text-blue-300 opacity-80">
                                Login your account
                            </h2>
                        </div>

                        <!-- Formulaire -->
                        <form action="/login" method="POST" id="loginForm" class="space-y-6">
                            <!-- Username -->
                            <div>
                                <label for="username" class="block mb-2 pixel-font text-sm text-blue-300">
                                    USERNAME:
                                </label>
                                <input 
                                    type="text" 
                                    id="username" 
                                    name="username"
                                    placeholder="Enter your username"
                                    required
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Password -->
                            <div>
                                <label for="password" class="block mb-2 pixel-font text-sm text-blue-300">
                                    PASSWORD:
                                </label>
                                <input 
                                    type="password" 
                                    id="password" 
                                    name="password"
                                    placeholder="Enter your password"
                                    required
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Bouton Submit -->
                            <button 
                                type="submit" 
                                class="w-full py-3 pixel-font text-sm neon-border bg-blue-500/20 text-blue-400 hover:bg-blue-500/40 hover:text-white transition-all"
                                id="submit-btn"
                            >
                                >>> SUBMIT <<<
                            </button>
                        </form>

                        <!-- Lien vers crÃ©ation de compte -->
                        <div class="mt-6 text-center">
                            <p class="pixel-font text-xs text-blue-300/60 mb-3">
                                Don't have an account?
                            </p>
                            <a 
                                href="/create" 
                                class="pixel-font text-sm text-blue-400 hover:text-blue-300 transition-colors inline-block"
                            >
                                >>> CREATE ACCOUNT <<<
                            </a>
                        </div>c
                    </div>
                </div>
            </div>
    `;

    return Layout.render(content, {
        showBackButton: true,
        showFooter: true
    });
};

export const loginLogic = (): (() => void) => {
    const cleanupManager = createCleanupManager();

    // Enregistrer les cibles GSAP
    cleanupManager.registerGsapTarget('#login-title');
    cleanupManager.registerGsapTarget('#left-panel');
    cleanupManager.registerGsapTarget('#right-panel');

    // Animations d'entrÃ©e avec GSAP
    gsap.from('#login-title', {
        scale: 0.5,
        opacity: 0,
        duration: 1,
        ease: 'back.out(1.7)'
    });

    gsap.from('#left-panel', {
        x: -100,
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
    });

    gsap.from('#right-panel', {
        x: 100,
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
    });

    // Gestion du formulaire
    const form = document.getElementById('loginForm') as HTMLFormElement;
    
    const handleSubmit = (e: Event) => {
        e.preventDefault();
        
        const username = (document.getElementById('username') as HTMLInputElement).value;
        const password = (document.getElementById('password') as HTMLInputElement).value;

        // Animation du bouton
        const submitBtn = document.getElementById('submit-btn');
        if (submitBtn) {
            gsap.to(submitBtn, {
                scale: 0.95,
                duration: 0.1,
                yoyo: true,
                repeat: 1
            });
        }

        // TODO: Logique de connexion rÃ©elle
        console.log('Login attempt:', { username, password });
        
        // Exemple de redirection aprÃ¨s succÃ¨s
        // window.router.navigate('/');
    };

    if (form) {
        form.addEventListener('submit', handleSubmit);
    }

    // Enregistrer le cleanup
    cleanupManager.onCleanup(() => {
        if (form) {
            form.removeEventListener('submit', handleSubmit);
        }
    });

    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/HomeView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

export const HomeView: ViewFunction = () => {
    const content = `
            <div class="flex-1 flex flex-col items-center justify-center px-4 py-12">
                <!-- Titre principal -->
                <div class="text-center mb-8">
                    <h1 class="pixel-font text-6xl md:text-8xl text-blue-400 mb-4" 
                        style="animation: neonPulse 2s ease-in-out infinite;"
                        id="main-title">
                        PONG
                    </h1>
                    <p class="pixel-font text-lg md:text-xl text-blue-300 tracking-wider">
                        >>> SKILL ISSUE <<<
                    </p>
                </div>

                <!-- Stats en temps rÃ©el -->
                <div class="flex gap-8 md:gap-16 mb-16" id="stats-display">
                    <div class="text-center">
                        <div class="pixel-font text-5xl md:text-6xl text-blue-400" id="players-count">0</div>
                        <div class="pixel-font text-xs md:text-sm text-blue-300 mt-2">PLAYER</div>
                    </div>
                    <div class="text-center">
                        <div class="pixel-font text-5xl md:text-6xl text-blue-400" id="games-count">0</div>
                        <div class="pixel-font text-xs md:text-sm text-blue-300 mt-2">IN GAME</div>
                    </div>
                    <div class="text-center">
                        <div class="pixel-font text-5xl md:text-6xl text-blue-400" id="online-count">0</div>
                        <div class="pixel-font text-xs md:text-sm text-blue-300 mt-2">ONLINE</div>
                    </div>
                </div>

                <!-- Cartes de jeu -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 w-full max-w-4xl mb-12">
                    <!-- QuickPlay Card -->
                    <a href="/play" 
                       class="game-card group relative p-8 md:p-12 neon-border hover:cursor-pointer"
                       id="quickplay-card"
                       style="opacity: 0; transform: translateY(100px);">
                        <!-- IcÃ´ne -->
                        <div class="text-6xl md:text-7xl mb-6 text-center text-blue-500">
                            âš¡
                        </div>
                        
                        <!-- Titre -->
                        <h2 class="pixel-font text-2xl md:text-3xl text-blue-400 text-center opacity-80 mb-4">
                            QUICKPLAY
                        </h2>
                        
                        <!-- Description -->
                        <p class="pixel-font text-sm text-blue-300 text-center opacity-80">
                            Time to train
                        </p>
                        
                        <!-- FlÃ¨ches dÃ©coratives -->
                        <div class="absolute top-4 left-4 text-red-500 text-2xl opacity-80">â†</div>
                        <div class="absolute bottom-4 right-4 text-red-500 text-2xl opacity-80">â†’</div>
                    </a>

                    <!-- Tournois Card -->
                    <a href="/tournament" 
                       class="game-card group relative p-8 md:p-12 neon-border hover:cursor-pointer"
                       id="tournament-card"
                       style="opacity: 0; transform: translateY(100px);">
                        <!-- IcÃ´ne -->
                        <div class="text-6xl md:text-7xl mb-6 text-center">
                            ğŸ†
                        </div>
                        
                        <!-- Titre -->
                        <h2 class="pixel-font text-2xl md:text-3xl text-red-500 text-center opacity-80 mb-4">
                            TOURNAMENT
                        </h2>
                        
                        <!-- Description -->
                        <p class="pixel-font text-sm text-blue-300 text-center opacity-80">
							Compete against the best players
                        </p>
                        
                        <!-- FlÃ¨ches dÃ©coratives -->
                        <div class="absolute top-4 left-4 text-blue-500 text-2xl opacity-80">â†</div>
                        <div class="absolute bottom-4 right-4 text-blue-500 text-2xl opacity-80">â†’</div>
                    </a>
                </div>

                <!-- Leaderboard -->
                <div class="w-full max-w-4xl neon-border p-6" style="background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(10px);">
                    <h3 class="pixel-font text-xl md:text-2xl text-blue-400 mb-6 flex items-center gap-2">
                        <span>ğŸ‘‘</span>
                        <span>RANKING</span>
                    </h3>
                    
                    <div id="leaderboard-container" class="overflow-hidden">
                        <p class="pixel-font text-sm text-blue-300 text-center py-4">Loading...</p>
                    </div>
                </div>
				<div class="mt-8">
					<a href="/blockchain" class="pixel-font text-purple-400 hover:text-purple-300 text-sm flex items-center justify-center gap-2 transition-colors">
						<span>VIEW BLOCKCHAIN REGISTRY</span>
					</a>
				</div>
            </div>
    `;

    return Layout.render(content, {
        customHeader: Layout.renderHomeHeader(),
        showFooter: true,
        showBackButton: false
    });
};

export const homeLogic = (): CleanupFunction => {
	const cleanupManager = createCleanupManager();
	cleanupManager.registerGsapTarget('#main-title');
	cleanupManager.registerGsapTarget('#play-card');
	cleanupManager.registerGsapTarget('#tournament-card');
	cleanupManager.registerGsapTarget('#history-card');

    // Animation d'entrÃ©e du titre
    gsap.to('#main-title', {
        scale: 1,
        opacity: 1,
        duration: 1,
        ease: 'back.out(1.7)'
    });

    // Animation des stats (depuis l'Ã©tat initial dans le HTML)
    gsap.to('#stats-display > div', {
        y: 0,
        opacity: 1,
        duration: 0.8,
        stagger: 0.2,
        ease: 'power2.out'
    });

    // Animation des cartes de jeu - UNE SEULE FOIS
    gsap.to('#quickplay-card', {
        y: 0,
        opacity: 1,
        duration: 1,
        delay: 0.5,
        ease: 'power3.out'
    });

    gsap.to('#tournament-card', {
        y: 0,
        opacity: 1,
        duration: 1,
        delay: 0.8,
        ease: 'power3.out'
    });

    // Animation des chiffres (compteur)
    const animateCounter = (id: string, target: number) => {
        const element = document.getElementById(id);
        if (!element) return;

        gsap.to({ val: 0 }, {
            val: target,
            duration: 2,
            ease: 'power1.inOut',
            onUpdate: function() {
                element.textContent = Math.floor(this.targets()[0].val).toString();
            }
        });
    };

    // Charger les stats globales
    const loadGlobalStats = async () => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/gamedb/stats/global`);
            const data = await response.json();
            
            if (data.success && data.stats) {
                animateCounter('players-count', data.stats.total_users);
                animateCounter('games-count', data.stats.active_games);
                animateCounter('online-count', data.stats.online_players);
            }
        } catch (err) {
            console.error('Error loading global stats:', err);
            // Valeurs par dÃ©faut en cas d'erreur
            animateCounter('players-count', 0);
            animateCounter('games-count', 0);
            animateCounter('online-count', 0);
        }
    };

    // Charger les stats du leaderboard
    const loadLeaderboard = async () => {
        try {
            const response = await fetch('/gamedb/users/leaderboard');
            const data = await response.json();
            
            if (data.success && data.leaderboard) {
                const container = document.getElementById('leaderboard-container');
                if (container) {
                    const topPlayers = data.leaderboard.slice(0, 5);
                    
                    container.innerHTML = `
                        <div class="space-y-2">
                            ${topPlayers.map((user: any, index: number) => `
                                <div class="flex items-center justify-between p-3 ${index % 2 === 0 ? 'bg-blue-950/20' : 'bg-transparent'} hover:bg-blue-900/30 transition-colors">
                                    <div class="flex items-center gap-4">
                                        <span class="pixel-font text-xl ${index === 0 ? 'text-yellow-400' : index === 1 ? 'text-gray-300' : index === 2 ? 'text-orange-600' : 'text-blue-400'}">
                                            ${index + 1}
                                        </span>
                                        <span class="pixel-font text-sm text-blue-300">${user.username}</span>
                                    </div>
                                    <div class="flex gap-6 text-xs pixel-font">
                                        <span class="text-blue-400">${user.total_games || 0} parties</span>
                                        <span class="text-green-400">${user.total_wins || 0} victoires</span>
                                        <span class="text-pink-400">${user.win_rate || 0}%</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <a href="/history" class="block mt-4 text-center pixel-font text-sm text-blue-400 hover:text-blue-300 transition-colors">
                            >>> View the complete history <<<
                        </a>
                    `;
                }
            }
        } catch (err) {
            console.error('Error loading leaderboard:', err);
            const container = document.getElementById('leaderboard-container');
            if (container) {
                container.innerHTML = `
                    <p class="pixel-font text-sm text-pink-500 text-center py-4">
                        âš ï¸ Loading error
                    </p>
                `;
            }
        }
    };

    // Charger les donnÃ©es au dÃ©marrage
    loadGlobalStats();
    loadLeaderboard();

    // RafraÃ®chir les stats toutes les 30 secondes
    const statsInterval = cleanupManager.setInterval(loadGlobalStats, 30000);

    // ArrÃªter le polling si l'utilisateur quitte l'onglet
    const handleVisibilityChange = () => {
        if (document.hidden) {
            clearInterval(statsInterval);
        } else {
            loadGlobalStats(); // Refresh immÃ©diat au retour
        }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
	cleanupManager.onCleanup(() => {
		document.removeEventListener('visibilitychange', handleVisibilityChange);
	});

    // Cleanup
    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/WaitingRoomView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

export const WaitingRoomView: ViewFunction = () => {
    const content = `
            <div class="flex-1 flex items-center justify-center px-4 py-12">
                <div class="w-full max-w-4xl">
                    
                    <!-- Titre principal -->
                    <div class="text-center mb-12">
                        <h1 class="pixel-font text-5xl md:text-7xl text-blue-400 mb-4" 
                            style="animation: neonPulse 2s ease-in-out infinite;"
                            id="waiting-title">
                            SEARCHING FOR OPPONENT
                        </h1>
                        <p class="pixel-font text-lg text-blue-300 opacity-80" id="waiting-subtitle">
                            >>> PREPARING YOUR MATCH <<<
                        </p>
                    </div>

                    <!-- Animation de recherche -->
                    <div class="flex justify-center mb-12" id="search-animation">
                        <div class="relative">
                            <!-- Spinner principal -->
                            <div class="spinner"></div>
                            
                            <!-- Anneaux de pulse -->
                            <div class="pulse-ring" style="width: 120px; height: 120px; animation-delay: 0s;"></div>
                            <div class="pulse-ring" style="width: 120px; height: 120px; animation-delay: 0.5s;"></div>
                            <div class="pulse-ring" style="width: 120px; height: 120px; animation-delay: 1s;"></div>
                        </div>
                    </div>

                    <!-- Informations du joueur -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                        <!-- Votre carte -->
                        <div class="player-card neon-border rounded-lg p-6" id="your-card">
                            <div class="flex items-center gap-4 mb-4">
                                <div class="w-16 h-16 rounded-full bg-blue-500/20 flex items-center justify-center border-2 border-blue-500/50">
                                    <span class="text-3xl">ğŸ‘¤</span>
                                </div>
                                <div class="flex-1">
                                    <div class="pixel-font text-xs text-blue-300/60 mb-1">YOU</div>
                                    <div class="pixel-font text-xl text-blue-400" id="your-username">Player</div>
                                </div>
                                <div class="status-indicator"></div>
                            </div>
                            
                            <!-- Skill sÃ©lectionnÃ© -->
                            <div class="mt-4 pt-4 border-t border-blue-500/30">
                                <div class="pixel-font text-xs text-blue-300/60 mb-2">SELECTED SKILL:</div>
                                <div class="flex items-center gap-2" id="your-skill">
                                    <span class="text-2xl">ğŸ’¥</span>
                                    <span class="pixel-font text-lg text-blue-300">SMASH</span>
                                </div>
                            </div>
                        </div>

                        <!-- Carte adversaire (en attente) -->
                        <div class="player-card neon-border rounded-lg p-6 opacity-50" id="opponent-card">
                            <div class="flex items-center gap-4 mb-4">
                                <div class="w-16 h-16 rounded-full bg-gray-500/20 flex items-center justify-center border-2 border-gray-500/50">
                                    <span class="text-3xl">â“</span>
                                </div>
                                <div class="flex-1">
                                    <div class="pixel-font text-xs text-gray-400 mb-1">OPPONENT</div>
                                    <div class="pixel-font text-xl text-gray-400">Waiting...</div>
                                </div>
                                <div class="w-3 h-3 rounded-full bg-gray-500"></div>
                            </div>
                            
                            <div class="mt-4 pt-4 border-t border-gray-500/30">
                                <div class="pixel-font text-xs text-gray-400 mb-2">SKILL:</div>
                                <div class="pixel-font text-lg text-gray-400">???</div>
                            </div>
                        </div>
                    </div>

                    <!-- Status message -->
                    <div class="neon-border bg-black/50 backdrop-blur-sm rounded-lg p-6 mb-6" id="status-container">
                        <div class="flex items-center justify-center gap-3">
                            <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                            <p class="pixel-font text-sm text-blue-300 text-center" id="status-message">
                                Looking for available players...
                            </p>
                            <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                        </div>
                    </div>

                    <!-- Bouton Cancel -->
                    <div class="text-center">
                        <button 
                            id="cancel-btn"
                            class="pixel-font px-8 py-4 neon-border bg-red-500/20 text-red-400 hover:bg-red-500/40 hover:text-white transition-all relative group"
                        >
                            <span class="relative z-10">>>> CANCEL SEARCH <<<</span>
                            <div class="absolute inset-0 bg-red-500/0 group-hover:bg-red-500/10 transition-all rounded"></div>
                        </button>
                    </div>

                    <!-- Tips -->
                    <div class="mt-8 text-center">
                        <div class="inline-block neon-border bg-blue-500/10 rounded-lg px-6 py-3">
                            <p class="pixel-font text-xs text-blue-300/60">
                                ğŸ’¡ TIP: Use SPACE to activate your skill at the right moment!
                            </p>
                        </div>
                    </div>
                </div>
            </div>
    `;

    return Layout.render(content, {
        customHeader: Layout.renderWaitingRoomHeader(),
        showFooter: true,
        showParticles: true,
        particleCount: 30
    });
};

export const waitingRoomLogic = (): CleanupFunction => {
    console.log('ğŸ® WaitingRoomView: Initializing...');

	const cleanupManager = createCleanupManager();
    let pollInterval: number | null = null;
    let roomId: string | null = null;
    const skill = (sessionStorage.getItem('selectedSkill') as 'smash' | 'dash' | null) || 'smash';

    // âœ… DÃ‰FINIR l'Ã©tat initial AVANT d'animer
    gsap.set('#waiting-title', { scale: 0.5, opacity: 0 });
    gsap.set('#waiting-subtitle', { y: 20, opacity: 0 });
    gsap.set('#search-animation', { scale: 0, opacity: 0 });
    gsap.set('#your-card', { x: -100, opacity: 0 });
    gsap.set('#opponent-card', { x: 100, opacity: 0 });
    gsap.set('#status-container', { y: 50, opacity: 0 });
    gsap.set('#cancel-btn', { y: 50, opacity: 0 });

	// Enregistrer les cibles GSAP pour cleanup
	cleanupManager.registerGsapTarget('#waiting-title');
	cleanupManager.registerGsapTarget('#waiting-subtitle');
	cleanupManager.registerGsapTarget('#search-animation');
	cleanupManager.registerGsapTarget('#your-card');
	cleanupManager.registerGsapTarget('#opponent-card');
	cleanupManager.registerGsapTarget('#status-container');
	cleanupManager.registerGsapTarget('#cancel-btn');

    // âœ… PUIS animer vers l'Ã©tat final
    cleanupManager.setTimeout(() => {
        gsap.to('#waiting-title', {
            scale: 1,
            opacity: 1,
            duration: 1,
            ease: 'back.out(1.7)'
        });

        gsap.to('#waiting-subtitle', {
            y: 0,
            opacity: 1,
            duration: 0.8,
            delay: 0.3,
            ease: 'power2.out'
        });

        gsap.to('#search-animation', {
            scale: 1,
            opacity: 1,
            duration: 0.8,
            delay: 0.5,
            ease: 'back.out(1.7)'
        });

        gsap.to('#your-card', {
            x: 0,
            opacity: 1,
            duration: 0.8,
            delay: 0.7,
            ease: 'power2.out'
        });

        gsap.to('#opponent-card', {
            x: 0,
            opacity: 1,
            duration: 0.8,
            delay: 0.7,
            ease: 'power2.out'
        });

        gsap.to('#status-container', {
            y: 0,
            opacity: 1,
            duration: 0.8,
            delay: 0.9,
            ease: 'power2.out'
        });

        gsap.to('#cancel-btn', {
            y: 0,
            opacity: 1,
            duration: 0.8,
            delay: 1.1,
            ease: 'power2.out'
        });
    }, 50);

    // Mettre Ã  jour l'affichage du username et du skill
    const updatePlayerInfo = (): void => {
        const username = window.simpleAuth.getUsername() || 'Player';
        const usernameElement = document.getElementById('your-username');
        if (usernameElement) {
            usernameElement.textContent = username;
        }

        const skillElement = document.getElementById('your-skill');
        if (skillElement) {
            const skillIcon = skill === 'dash' ? 'âš¡' : 'ğŸ’¥';
            const skillName = skill === 'dash' ? 'DASH' : 'SMASH';
            skillElement.innerHTML = `
                <span class="text-2xl">${skillIcon}</span>
                <span class="pixel-font text-lg text-blue-300">${skillName}</span>
            `;
        }
    };

    const updateStatus = (message: string): void => {
        const statusMessage = document.getElementById('status-message');
        if (statusMessage) {
            statusMessage.textContent = message;
        }
    };

    const handleJoin = async (): Promise<void> => {
        const username = window.simpleAuth.getUsername() || 'Player';
        const playerId = window.simpleAuth.getPlayerId();

        updateStatus('Connecting to matchmaking...');

        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/quickplay/join`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, playerId, selectedSkill: skill })
            });
            const data = await response.json();
            
            if (data.success) {
                roomId = data.roomId;
                updateStatus('Waiting for opponent...');
                startPolling();
            } else {
                updateStatus('Error: ' + (data.error || 'Failed to join'));
            }
        } catch (err) {
            console.error(err);
            updateStatus('Connection error');
        }
    };

    const startPolling = (): void => {
        pollInterval = setInterval(async () => {
            if (!roomId) return;
            
            try {
                const host = import.meta.env.VITE_HOST || 'localhost:8443';
                const response = await fetch(`https://${host}/quickplay/status/${roomId}`);
                const data = await response.json();
                
                if (data.status === 'ready') {
                    updateStatus('Opponent found! Preparing game...');
                    
                    // Animation de transition
                    const opponentCard = document.getElementById('opponent-card');
                    if (opponentCard) {
                        gsap.to(opponentCard, {
                            opacity: 1,
                            duration: 0.5,
                            ease: 'power2.out'
                        });
                    }
                    
                    stopPolling();
                    sessionStorage.setItem('gameWsURL', data.gameServerURL);

                    cleanupManager.setTimeout(() => {
						// set "game3d/" path or "game/"
						const viewMode = sessionStorage.getItem('viewMode') || '2d';
						const viewPath = viewMode === '3d' ? 'game3d' : 'game';
                        window.router.navigate(`/${viewPath}/${roomId}`);
                    }, 1000);
                }
            } catch (err) {
                console.error('Polling error:', err);
            }
        }, 2000);
        
        console.log('ğŸ”„ Started polling for opponent');
    };

    const stopPolling = (): void => {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
            console.log('ğŸ›‘ Stopped polling');
        }
    };

    const handleCancel = (): void => {
        stopPolling();
        
        // Animation de sortie
        gsap.to('#waiting-title, #search-animation, #your-card, #opponent-card, #status-container', {
            opacity: 0,
            y: -50,
            duration: 0.5,
            ease: 'power2.in',
            onComplete: () => {
                window.router.navigate('/play');
            }
        });
    };

    // DÃ©marrer aprÃ¨s un court dÃ©lai
    cleanupManager.setTimeout(() => {
        updatePlayerInfo();
        handleJoin();
    }, 100);

    // Attacher le handler du bouton Cancel
    const cancelBtn = document.getElementById('cancel-btn');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', handleCancel);
		cleanupManager.onCleanup(() => {
			cancelBtn.removeEventListener('click', handleCancel);
		});
    }

	// Enregistrer le cleanup du polling
	cleanupManager.onCleanup(() => {
		stopPolling();
	});

    // Cleanup
    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/BlockchainView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// apps/frontend/src/views/BlockchainView.ts
import type { ViewFunction, CleanupFunction } from "../router/types";
import { BackButton } from "../components/Button";
import { gsap } from "gsap";
import { createCleanupManager } from "../utils/CleanupManager";

interface BlockchainTournament {
    tournamentName: string;
    maxPlayers: number;
    winnerId: string;
    winnerUsername: string;
    timestamp: string; // BigInt serialisÃ©
}

interface LocalGame {
    tournament_id?: string;
    game_type: string;
    created_at: string;
}

export const BlockchainView: ViewFunction = () => {
    return `
        <!-- Fond "Blockchain" -->
        <div class="fixed inset-0 bg-[#02040a] overflow-hidden">
            <!-- Grille Hexagonale ou Digitale -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(139, 92, 246, 0.05) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(139, 92, 246, 0.05) 1px, transparent 1px);
                background-size: 30px 30px;
                transform: perspective(500px) rotateX(60deg);
                transform-origin: center 80%;
                animation: gridFlow 20s linear infinite;
            "></div>

            <!-- Flux de donnÃ©es binaire en arriÃ¨re plan -->
            ${Array.from({length: 20}, () => `
                <div class="absolute text-[#3b82f6] opacity-10 font-mono text-xs select-none" 
                     style="
                        left: ${Math.random() * 100}%; 
                        top: -20px; 
                        animation: binaryRain ${5 + Math.random() * 10}s linear infinite;
                        animation-delay: ${Math.random() * 5}s;
                     ">
                    ${Math.random().toString(2).substring(2, 10)}
                </div>
            `).join('')}

            <style>
                @keyframes gridFlow {
                    0% { background-position: 0 0; }
                    100% { background-position: 0 60px; }
                }
                @keyframes binaryRain {
                    0% { transform: translateY(-100%); opacity: 0; }
                    10% { opacity: 0.2; }
                    90% { opacity: 0.2; }
                    100% { transform: translateY(110vh); opacity: 0; }
                }
                @keyframes pulse-purple {
                    0%, 100% { box-shadow: 0 0 10px rgba(139, 92, 246, 0.3); border-color: rgba(139, 92, 246, 0.5); }
                    50% { box-shadow: 0 0 20px rgba(139, 92, 246, 0.6); border-color: rgba(139, 92, 246, 0.8); }
                }
                
                .crypto-card {
                    background: rgba(10, 10, 25, 0.7);
                    backdrop-filter: blur(12px);
                    border: 1px solid rgba(139, 92, 246, 0.3);
                    transition: all 0.3s ease;
                }
                .crypto-card:hover {
                    transform: translateY(-5px);
                    border-color: #8b5cf6;
                    box-shadow: 0 0 30px rgba(139, 92, 246, 0.2);
                }
                
                .hash-text {
                    font-family: 'Courier New', monospace;
                    letter-spacing: -0.5px;
                }
            </style>
        </div>

        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header -->
            <div class="p-8 flex justify-between items-start">
                ${BackButton({
                    size: "lg",
                    className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
                })}
                
                <!-- Badge Avalanche -->
                <div class="flex flex-col items-center gap-2">
                    <div class="flex items-center gap-2 px-4 py-2 rounded-full bg-red-500/10 border border-red-500/30">
                        <div class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
                        <span class="pixel-font text-xs text-red-400">AVALANCHE C-CHAIN</span>
                    </div>
                    <div class="text-xs text-white/30 mt-1 font-mono">CONTRACT: REGISTERED</div>
                </div>
            </div>

            <!-- Contenu -->
            <div class="container mx-auto px-8 pb-12">
                <div class="text-center mb-12">
                    <h1 class="pixel-font text-5xl font-bold md:text-6xl text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 mb-4 filter drop-shadow-lg">
                        BLOCKCHAIN REGISTRY
                    </h1>
                    <p class="pixel-font text-blue-300/60 tracking-widest">
                        IMMUTABLE TOURNAMENT RECORDS
                    </p>
                </div>

                <!-- Stats Bar -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12 max-w-4xl mx-auto">
                    <div class="crypto-card rounded-xl p-6 text-center">
                        <div class="text-purple-400 text-xs pixel-font mb-2">TOTAL VERIFIED</div>
                        <div id="total-tournaments" class="text-4xl font-bold text-white font-mono">0</div>
                    </div>
                    <div class="crypto-card rounded-xl p-6 text-center">
                        <div class="text-blue-400 text-xs pixel-font mb-2">NETWORK STATUS</div>
                        <div class="text-xl font-bold text-green-400 pixel-font mt-2">ONLINE</div>
                    </div>
                    <div class="crypto-card rounded-xl p-6 text-center">
                        <div class="text-pink-400 text-xs pixel-font mb-2">LATEST BLOCK</div>
                        <div id="block-height" class="text-xl font-bold text-white font-mono mt-2 animate-pulse">SYNCING...</div>
                    </div>
                </div>

                <!-- Loading -->
                <div id="blockchain-loading" class="flex flex-col items-center justify-center py-20">
                    <div class="relative w-24 h-24 mb-8">
                        <div class="absolute inset-0 border-4 border-purple-500/30 rounded-full"></div>
                        <div class="absolute inset-0 border-4 border-t-purple-500 rounded-full animate-spin"></div>
                        <div class="absolute inset-4 border-4 border-blue-500/30 rounded-full"></div>
                        <div class="absolute inset-4 border-4 border-b-blue-500 rounded-full animate-spin" style="animation-direction: reverse;"></div>
                    </div>
                    <p class="pixel-font text-purple-300 animate-pulse">CONNECTING TO NODE...</p>
                </div>

                <!-- Liste des Tournois -->
                <div id="blockchain-list" class="grid grid-cols-1 gap-6 max-w-5xl mx-auto hidden">
                    <!-- Les cartes seront injectÃ©es ici -->
                </div>

                <!-- Empty State -->
                <div id="blockchain-empty" class="hidden text-center py-20">
                    <div class="text-6xl mb-4 opacity-50">â›“ï¸</div>
                    <h3 class="pixel-font text-2xl text-white mb-2">NO RECORDS FOUND</h3>
                    <p class="text-white/40 font-mono text-sm">The ledger is empty.</p>
                </div>
            </div>
        </div>
    `;
};

export const blockchainLogic = (): CleanupFunction => {
    const cleanupManager = createCleanupManager();
    const host = import.meta.env.VITE_HOST || 'localhost:8443';
    let isComponentMounted = true;

    // Enregistrer les cibles GSAP
    cleanupManager.registerGsapTarget('h1');
    cleanupManager.registerGsapTarget('.crypto-card');
    cleanupManager.registerGsapTarget('.tournament-item');

    gsap.from("h1", { y: -50, opacity: 0, duration: 1, ease: "power3.out" });
    gsap.from(".crypto-card", {
        y: 50, opacity: 0, duration: 0.8, stagger: 0.1, delay: 0.3, ease: "back.out(1.7)"
    });

    const blockInterval = cleanupManager.setInterval(() => {
        const blockEl = document.getElementById('block-height');
        if (blockEl) {
            const height = Math.floor(Math.random() * 1000000) + 12000000;
            blockEl.textContent = `#${height}`;
        }
    }, 3000);

    const fetchBlockchainData = async () => {
        try {
            const response = await fetch(`https://${host}/blockchainback/tournaments/all`);
            
            if (!response.ok) throw new Error("Network response was not ok");
            
            const data = await response.json();

            if (isComponentMounted) {
                if (data.success) {
                    updateUI(data.tournaments);
                } else {
                    throw new Error(data.error || "Unknown error");
                }
            }

        } catch (err) {
            console.error("Blockchain fetch error:", err);
            if (isComponentMounted) {
                const loading = document.getElementById('blockchain-loading');
                if (loading) loading.innerHTML = `<p class="text-red-500 pixel-font">CONNECTION ERROR</p>`;
            }
        }
    };

    const updateUI = (tournaments: Array<{id: string, data: BlockchainTournament}>) => {
        const loading = document.getElementById('blockchain-loading');
        const list = document.getElementById('blockchain-list');
        const empty = document.getElementById('blockchain-empty');
        const countEl = document.getElementById('total-tournaments');

        if (loading) loading.style.display = 'none';
        if (countEl) countEl.textContent = tournaments.length.toString();

        if (tournaments.length === 0) {
            if (empty) empty.style.display = 'block';
            return;
        }

        if (list) {
            list.style.display = 'grid';
            list.innerHTML = tournaments.map((t) => {
                const date = new Date(Number(t.data.timestamp) * 1000).toLocaleString();
                const visualHash = '0x' + btoa(t.id).substring(0, 40).toLowerCase() + '...';

                return `
                <div class="crypto-card rounded-xl p-6 relative overflow-hidden group opacity-0 translate-y-4 tournament-item">
                    <!-- Effet shimmer -->
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent -translate-x-full group-hover:animate-[shimmer_1.5s_infinite]"></div>
                    
                    <div class="flex flex-col md:flex-row justify-between items-center gap-6">
                        <!-- Info Gauche -->
                        <div class="flex items-center gap-6">
                            <div class="w-16 h-16 rounded-lg bg-purple-900/30 border border-purple-500/30 flex items-center justify-center text-3xl">
                                ğŸ†
                            </div>
                            <div>
                                <div class="flex items-center gap-3 mb-1">
                                    <h3 class="text-2xl font-bold text-white pixel-font">${t.data.tournamentName}</h3>
                                    <span class="px-2 py-0.5 rounded text-[10px] font-bold bg-green-500/20 text-green-400 border border-green-500/30">
                                        VERIFIED
                                    </span>
                                </div>
                                <div class="flex items-center gap-4 text-sm text-blue-200/60 font-mono">
                                    <span>Players: ${t.data.maxPlayers}</span>
                                    <span>â€¢</span>
                                    <span>${date}</span>
                                </div>
                            </div>
                        </div>

                        <!-- Info Droite (Winner) -->
                        <div class="text-right">
                            <div class="text-xs text-purple-400 mb-1 pixel-font">WINNER</div>
                            <div class="text-xl text-white font-bold flex items-center justify-end gap-2">
                                <span>${t.data.winnerUsername}</span>
                                <span class="text-yellow-400">ğŸ‘‘</span>
                            </div>
                            <div class="mt-2 p-2 bg-black/40 rounded border border-white/10 flex items-center gap-2 cursor-help" title="Transaction Hash">
                                <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                                <span class="text-[10px] text-white/40 hash-text">${visualHash}</span>
                            </div>
                        </div>
                    </div>
                </div>
                `;
            }).join('');

            gsap.to(".tournament-item", {
                opacity: 1,
                y: 0,
                duration: 0.5,
                stagger: 0.1,
                ease: "power2.out"
            });
        }
    };

    fetchBlockchainData();

    // Enregistrer le cleanup
    cleanupManager.onCleanup(() => {
        isComponentMounted = false;
    });

    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/LocalTournamentBracketView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { LocalTournamentManager, type LocalTournament, type LocalMatch } from "../utils/localTournamentManager";
import { Layout } from "../components/Layout";
import { createCleanupManager } from "../utils/CleanupManager";

export const LocalTournamentBracketView: ViewFunction = () => {
	const content = `
			<style>
				.match-card {
					transition: all 0.3s ease;
					background: rgba(15, 23, 42, 0.8);
					backdrop-filter: blur(10px);
					position: relative;
					min-width: 200px;
				}

				.match-card.finished {
					border-color: rgba(34, 197, 94, 0.8);
				}

				.match-card.ready {
					border-color: rgba(234, 179, 8, 0.8);
					animation: matchPulse 2s ease-in-out infinite;
				}

				.match-card.in_progress {
					border-color: rgba(239, 68, 68, 0.8);
					animation: matchPulse 2s ease-in-out infinite;
				}

				@keyframes matchPulse {
					0%, 100% {
						box-shadow: 0 0 10px currentColor;
					}
					50% {
						box-shadow: 0 0 20px currentColor;
					}
				}

				.player-slot {
					transition: all 0.2s ease;
				}

				.player-slot.winner {
					background: rgba(34, 197, 94, 0.2);
					border-color: rgba(34, 197, 94, 0.5);
				}

				.player-slot.loser {
					opacity: 0.5;
				}

				.bracket-tree {
					display: flex;
					gap: 80px;
					padding: 40px;
					overflow-x: auto;
					min-height: 600px;
				}

				.round-column {
					display: flex;
					flex-direction: column;
					justify-content: space-around;
					min-width: 220px;
					position: relative;
				}

				.round-header {
					text-align: center;
					margin-bottom: 20px;
					position: sticky;
					top: 0;
					background: rgba(4, 7, 26, 0.9);
					padding: 10px;
					border-radius: 8px;
					z-index: 10;
				}

				.winner-modal {
					position: fixed;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					background: rgba(0, 0, 0, 0.9);
					display: flex;
					align-items: center;
					justify-content: center;
					z-index: 1000;
				}

				.winner-modal.hidden {
					display: none;
				}
			</style>

			<header class="flex justify-between items-center px-8 py-6">
				<button
					id="exit-tournament-btn"
					class="pixel-font px-6 py-3 neon-border bg-transparent text-red-400 hover:bg-red-500/10 transition-all"
				>
					EXIT TOURNAMENT
				</button>

				<div class="pixel-font text-blue-400 text-sm">
					<span id="tournament-status">Round 1</span>
				</div>
			</header>

			<div class="flex-1 overflow-y-auto">
				<!-- Titre -->
				<div class="text-center py-6">
					<h1 class="pixel-font text-4xl md:text-5xl text-blue-400"
						style="animation: neonPulse 2s ease-in-out infinite;">
						ğŸ† TOURNAMENT BRACKET ğŸ†
					</h1>
				</div>

				<!-- Bracket Tree -->
				<div id="bracket-container" class="bracket-tree">
					<!-- Rounds will be generated here -->
				</div>

				<!-- Next Match Panel -->
				<div id="next-match-panel" class="fixed bottom-8 left-1/2 transform -translate-x-1/2 hidden">
					<div class="neon-border rounded-lg p-6 bg-black/90 backdrop-blur-lg">
						<div class="pixel-font text-center">
							<div class="text-blue-400 text-sm mb-2">NEXT MATCH</div>
							<div class="text-white text-lg mb-4" id="next-match-text">
								Player 1 vs Player 2
							</div>
							<button
								id="play-match-btn"
								class="pixel-font px-8 py-3 neon-border bg-green-500/20 text-green-400 hover:bg-green-500/40 transition-all"
							>
								PLAY MATCH
							</button>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Winner Modal -->
		<div id="winner-modal" class="winner-modal hidden">
			<div class="neon-border rounded-lg p-12 bg-black/90 backdrop-blur-lg text-center">
				<div class="pixel-font text-6xl text-yellow-400 mb-6" style="animation: neonPulse 2s ease-in-out infinite;">
					ğŸ† CHAMPION ğŸ†
				</div>
				<div class="pixel-font text-4xl text-blue-400 mb-8" id="winner-name">
					Player Name
				</div>
				<div class="flex gap-4 justify-center">
					<button
						id="new-tournament-btn"
						class="pixel-font px-8 py-3 neon-border bg-blue-500/20 text-blue-400 hover:bg-blue-500/40 transition-all"
					>
						NEW TOURNAMENT
					</button>
					<button
						id="exit-to-menu-btn"
						class="pixel-font px-8 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
					>
						MAIN MENU
					</button>
				</div>
			</div>
	`;

	return Layout.render(content, {
		showBackButton: true,
		showFooter: false
	});
};

const generateMatchCard = (match: LocalMatch): string => {
	const statusClass = match.status;
	const isFinished = match.status === 'finished';

	const player1Class = isFinished
		? (match.winner?.id === match.player1?.id ? 'winner' : 'loser')
		: '';
	const player2Class = isFinished
		? (match.winner?.id === match.player2?.id ? 'winner' : 'loser')
		: '';

	return `
		<div class="match-card neon-border rounded-lg p-4 mb-4 ${statusClass}" data-match-id="${match.id}">
			<div class="space-y-2">
				<!-- Player 1 -->
				<div class="player-slot neon-border rounded p-2 ${player1Class}">
					<div class="pixel-font text-sm text-blue-300">
						${match.player1?.username || 'TBD'}
						${isFinished && match.winner?.id === match.player1?.id ? ' ğŸ‘‘' : ''}
					</div>
				</div>

				<div class="text-center pixel-font text-xs text-blue-400">VS</div>

				<!-- Player 2 -->
				<div class="player-slot neon-border rounded p-2 ${player2Class}">
					<div class="pixel-font text-sm text-blue-300">
						${match.player2?.username || 'TBD'}
						${isFinished && match.winner?.id === match.player2?.id ? ' ğŸ‘‘' : ''}
					</div>
				</div>
			</div>

			${match.status === 'ready' ? `
				<div class="text-center mt-3">
					<div class="pixel-font text-xs text-yellow-400">READY TO PLAY</div>
				</div>
			` : ''}

			${match.status === 'in_progress' ? `
				<div class="text-center mt-3">
					<div class="pixel-font text-xs text-red-400">IN PROGRESS...</div>
				</div>
			` : ''}
		</div>
	`;
};

const generateRoundColumn = (tournament: LocalTournament, round: number): string => {
	const matches = LocalTournamentManager.getMatchesForRound(tournament, round);
	const totalRounds = LocalTournamentManager.getTotalRounds(tournament.size);
	const roundName = LocalTournamentManager.getRoundName(round, totalRounds);

	const matchesHtml = matches.map(match => generateMatchCard(match)).join('');

	return `
		<div class="round-column">
			<div class="round-header">
				<div class="pixel-font text-lg text-blue-400">${roundName}</div>
				<div class="pixel-font text-xs text-blue-300">Round ${round}</div>
			</div>
			<div class="matches-container">
				${matchesHtml}
			</div>
		</div>
	`;
};

const renderBracket = (tournament: LocalTournament): void => {
	const container = document.getElementById('bracket-container');
	if (!container) return;

	const totalRounds = LocalTournamentManager.getTotalRounds(tournament.size);
	let html = '';

	for (let round = 1; round <= totalRounds; round++) {
		const matches = LocalTournamentManager.getMatchesForRound(tournament, round);
		if (matches.length > 0) {
			html += generateRoundColumn(tournament, round);
		}
	}

	container.innerHTML = html;

	// Animer l'apparition
	gsap.fromTo(
		'.round-column',
		{ opacity: 0, x: -50 },
		{ opacity: 1, x: 0, duration: 0.5, stagger: 0.2 }
	);
};

const updateNextMatchPanel = (tournament: LocalTournament): void => {
	const panel = document.getElementById('next-match-panel');
	const textEl = document.getElementById('next-match-text');

	if (!panel || !textEl) return;

	const nextMatch = LocalTournamentManager.getNextMatch(tournament);

	if (nextMatch && nextMatch.player1 && nextMatch.player2) {
		textEl.textContent = `${nextMatch.player1.username} vs ${nextMatch.player2.username}`;
		panel.classList.remove('hidden');

		// Animer l'apparition
		gsap.fromTo(
			panel,
			{ y: 100, opacity: 0 },
			{ y: 0, opacity: 1, duration: 0.5 }
		);
	} else {
		panel.classList.add('hidden');
	}
};

const updateTournamentStatus = (tournament: LocalTournament): void => {
	const statusEl = document.getElementById('tournament-status');
	if (!statusEl) return;

	const totalRounds = LocalTournamentManager.getTotalRounds(tournament.size);
	const roundName = LocalTournamentManager.getRoundName(tournament.currentRound, totalRounds);

	statusEl.textContent = `${roundName} (Round ${tournament.currentRound}/${totalRounds})`;
};

const showWinnerModal = (winner: { username: string }): void => {
	const modal = document.getElementById('winner-modal');
	const nameEl = document.getElementById('winner-name');

	if (!modal || !nameEl) return;

	nameEl.textContent = winner.username;
	modal.classList.remove('hidden');

	// Animer l'apparition
	gsap.fromTo(
		modal,
		{ opacity: 0, scale: 0.8 },
		{ opacity: 1, scale: 1, duration: 0.8, ease: 'back.out(1.7)' }
	);
};

export const localTournamentBracketLogic = (): CleanupFunction => {
	const cleanupManager = createCleanupManager();
	const tournament = LocalTournamentManager.getCurrentTournament();

	if (!tournament) {
		console.error('No tournament found');
		window.router.navigate('/local-tournament-setup');
		return () => {};
	}

	// Enregistrer les cibles GSAP
	cleanupManager.registerGsapTarget('.round-column');
	cleanupManager.registerGsapTarget('#next-match-panel');
	cleanupManager.registerGsapTarget('#winner-modal');

	// Rendu initial
	renderBracket(tournament);
	updateNextMatchPanel(tournament);
	updateTournamentStatus(tournament);

	// VÃ©rifier si le tournoi est terminÃ©
	if (tournament.status === 'finished' && tournament.winner) {
		showWinnerModal(tournament.winner);
	}

	// Handler pour jouer le prochain match
	const playMatchBtn = document.getElementById('play-match-btn');
	const handlePlayMatch = () => {
		const nextMatch = LocalTournamentManager.getNextMatch(tournament);
		if (!nextMatch || !nextMatch.player1 || !nextMatch.player2) return;

		// Marquer le match comme en cours
		LocalTournamentManager.markMatchInProgress(nextMatch.id);

		// CrÃ©er la config pour le mode local
		const roomId = `local-tournament-${Date.now()}`;
		const localGameConfig = {
			roomId,
			left: {
				id: nextMatch.player1.id,
				username: nextMatch.player1.username,
				selectedSkill: nextMatch.player1.selectedSkill,
			},
			right: {
				id: nextMatch.player2.id,
				username: nextMatch.player2.username,
				selectedSkill: nextMatch.player2.selectedSkill,
			},
		};

		// Stocker les infos du match de tournoi
		sessionStorage.setItem('localGameConfig', JSON.stringify(localGameConfig));
		sessionStorage.setItem('localTournamentMatch', nextMatch.id);
		sessionStorage.setItem('gameWsURL', `wss://${window.location.hostname}:8443/gameback/game/${roomId}`);

		// CrÃ©er la config pour le backend (qui attend player1/player2)
		const backendConfig = {
			roomId,
			player1: localGameConfig.left,
			player2: localGameConfig.right,
		};

		// CrÃ©er la partie sur le backend
		fetch(`https://${window.location.hostname}:8443/gameback/create`, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(backendConfig),
		})
			.then(response => {
				if (!response.ok) throw new Error('Failed to create game');
				return response.json();
			})
			.then(() => {
				// Rediriger vers le jeu
				window.router.navigate(`/game/${roomId}`);
			})
			.catch(error => {
				console.error('Error creating game:', error);
				alert('Failed to create game. Please try again.');
			});
	};

	playMatchBtn?.addEventListener('click', handlePlayMatch);

	// Handler pour quitter le tournoi
	const exitBtn = document.getElementById('exit-tournament-btn');
	const handleExit = () => {
		if (confirm('Are you sure you want to exit the tournament? All progress will be lost.')) {
			LocalTournamentManager.clearTournament();
			window.router.navigate('/play');
		}
	};

	exitBtn?.addEventListener('click', handleExit);

	// Handlers pour le modal de victoire
	const newTournamentBtn = document.getElementById('new-tournament-btn');
	const exitToMenuBtn = document.getElementById('exit-to-menu-btn');

	const handleNewTournament = () => {
		LocalTournamentManager.clearTournament();
		window.router.navigate('/local-tournament-setup');
	};

	const handleExitToMenu = () => {
		LocalTournamentManager.clearTournament();
		window.router.navigate('/play');
	};

	newTournamentBtn?.addEventListener('click', handleNewTournament);
	exitToMenuBtn?.addEventListener('click', handleExitToMenu);

	// Enregistrer le cleanup
	cleanupManager.onCleanup(() => {
		playMatchBtn?.removeEventListener('click', handlePlayMatch);
		exitBtn?.removeEventListener('click', handleExit);
		newTournamentBtn?.removeEventListener('click', handleNewTournament);
		exitToMenuBtn?.removeEventListener('click', handleExitToMenu);
	});

	return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/views/BracketView.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { ViewFunction, CleanupFunction, RouteParams } from "../router/types";
import { gsap } from "gsap";
import { createCleanupManager } from "../utils/CleanupManager";

interface Player {
    id: string;
    username: string;
    currentTournament?: string;
    isEleminated: boolean;
}

interface Match {
    id: string;
    tournamentId: string;
    round: number;
    position: number;
    player1?: Player;
    player2?: Player;
    winner?: Player;
    roomId?: string;
    status: 'pending' | 'ready' | 'in_progress' | 'finished';
    scheduledAt?: Date;
    finishedAt?: Date;
}

interface Tournament {
    id: string;
    name: string;
    status: 'registration' | 'in_progress' | 'finished';
    maxPlayers: number;
    currentPlayers: Player[];
    bracket: Match[];
    currentRound: number;
    winner?: Player;
    createdAt: Date;
    StartedAt?: Date;
    finishedAt?: Date;
}

export const BracketView: ViewFunction = () => {
    return `
        <!-- Fond avec grille animÃ©e -->
        <div class="fixed inset-0 bg-black overflow-hidden">
            <!-- Grille de fond -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
                background-size: 50px 50px;
                animation: gridMove 20s linear infinite;
            "></div>
            
            <style>
                .match-card {
                    transition: all 0.3s ease;
                    background: rgba(15, 23, 42, 0.8);
                    backdrop-filter: blur(10px);
                    position: relative;
                    min-width: 200px;
                }

                .match-card.finished {
                    border-color: rgba(34, 197, 94, 0.8);
                }

                .match-card.in_progress {
                    border-color: rgba(234, 179, 8, 0.8);
                    animation: matchPulse 2s ease-in-out infinite;
                }

                @keyframes matchPulse {
                    0%, 100% { 
                        box-shadow: 0 0 10px rgba(234, 179, 8, 0.5);
                    }
                    50% { 
                        box-shadow: 0 0 20px rgba(234, 179, 8, 0.8);
                    }
                }

                .player-slot {
                    transition: all 0.2s ease;
                }

                .player-slot.winner {
                    background: rgba(34, 197, 94, 0.2);
                    border-color: rgba(34, 197, 94, 0.5);
                }

                .player-slot.loser {
                    opacity: 0.5;
                }

                /* Tree connections */
                .bracket-tree {
                    display: flex;
                    gap: 80px;
                    padding: 40px;
                    overflow-x: auto;
                    min-height: 600px;
                }

                .round-column {
                    display: flex;
                    flex-direction: column;
                    justify-content: space-around;
                    min-width: 220px;
                    position: relative;
                }

                .round-header {
                    text-align: center;
                    margin-bottom: 20px;
                    position: sticky;
                    top: 0;
                    background: rgba(4, 7, 26, 0.9);
                    padding: 10px;
                    border-radius: 8px;
                    z-index: 10;
                }

                /* Lignes de connexion */
                .connector-line {
                    position: absolute;
                    background: rgba(59, 130, 246, 0.4);
                    z-index: 0;
                }

                .connector-horizontal {
                    height: 2px;
                }

                .connector-vertical {
                    width: 2px;
                }

                /* Animation des connexions */
                @keyframes flowRight {
                    0% { transform: translateX(-100%); }
                    100% { transform: translateX(100%); }
                }

                .connector-line.active::after {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 20px;
                    height: 100%;
                    background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.8), transparent);
                    animation: flowRight 2s ease-in-out infinite;
                }
            </style>
            
            <!-- Scanline effect -->
            <div class="absolute inset-0 pointer-events-none opacity-10">
                <div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
            </div>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header avec BackButton -->
            <header class="flex justify-between items-center px-8 py-6">
                <button
                    onclick="window.router.goBack()"
                    class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
                    id="back-button"
                >
                    â† BACK
                </button>
                
                <!-- Bouton Sign in -->
                <a href="/login" 
                   class="pixel-font bg-blue-500 text-black px-6 py-3 text-sm md:text-base hover:bg-blue-400 transition-all neon-border flex items-center gap-2">
                    <span>SIGN IN</span>
                </a>
            </header>

            <!-- Container principal -->
            <div class="flex-1 px-4 py-8">
                <!-- Loading state -->
                <div id="tournament-loading" class="text-center py-12">
                    <div class="inline-block animate-spin rounded-full h-16 w-16 border-4 border-blue-400 border-t-transparent"></div>
                    <p class="pixel-font text-blue-300 mt-4">Loading tournament...</p>
                </div>

                <!-- Content -->
                <div id="tournament-content" style="display: none;">
                    <!-- Header du tournoi -->
                    <div id="tournament-header" class="mb-8"></div>
                    
                    <!-- Brackets en arbre -->
                    <div id="tournament-brackets" class="bracket-tree"></div>
                </div>

                <!-- Error state -->
                <div id="tournament-error" style="display: none;" class="text-center py-12">
                    <div class="text-6xl mb-4">âš ï¸</div>
                    <h3 class="pixel-font text-2xl text-red-400 mb-2">Tournament not found</h3>
                    <p class="pixel-font text-sm text-blue-300/60">Unable to load tournament data</p>
                </div>
            </div>

            <!-- Footer -->
            <footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
                <p>Â© 2025 PONG - SKILL ISSUE</p>
            </footer>
        </div>
    `;
};

export const bracketLogic = (params: RouteParams | undefined): CleanupFunction => {
    console.log('ğŸ® BracketView: Initializing...');

    const cleanupManager = createCleanupManager();
    const tournamentId = params?.id;
    const myPlayerId = window.simpleAuth.getPlayerId();

    let pollInterval: number | null = null;
    let isFirstRender = true;
    let displayedMatchIds = new Set<string>();
    let currentTournamentState: Tournament | null = null;

    // Enregistrer les cibles GSAP
    cleanupManager.registerGsapTarget('.neon-border');
    cleanupManager.registerGsapTarget('.round-column');

    const cleanupIntervals = () => {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
            console.log('ğŸ§¹ Polling interval cleared');
        }
    };

    const fetchTournamentData = async (): Promise<void> => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const tournament = data.tournament;
            
            displayTournament(tournament);
            checkIfMyTurn(tournament);
        } catch (error) {
            console.error('Erreur lors de la rÃ©cupÃ©ration du tournoi:', error);
            showError();
        }
    };

    const checkIfMyTurn = (tournament: Tournament): void => {
        const myMatch = tournament.bracket.find(match => 
            match.status === 'in_progress' &&
            (match.player1?.id === myPlayerId || match.player2?.id === myPlayerId)
        );

        if (myMatch && myMatch.roomId) {
            console.log('Mon match est prÃªt ! Redirection...');
            
            cleanupIntervals();
            
            const host = import.meta.env.VITE_HOST;
            const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
            const wsUrl = `wss://${host}${endpoint}/${myMatch.roomId}`;
            sessionStorage.setItem('gameWsURL', wsUrl);
            
            window.router.navigate(`/game/${myMatch.roomId}`);
        }
    };

    const displayTournament = (tournament: Tournament): void => {
        hideLoading();
        showContent();

        const headerNeedsUpdate = !currentTournamentState || 
            currentTournamentState.status !== tournament.status ||
            currentTournamentState.currentRound !== tournament.currentRound ||
            currentTournamentState.winner?.id !== tournament.winner?.id;

        if (headerNeedsUpdate) {
            updateHeader(tournament);
        }

        updateBrackets(tournament);

        currentTournamentState = tournament;
    };

    const updateHeader = (tournament: Tournament): void => {
        const headerElement = document.getElementById('tournament-header');
        if (headerElement) {
            headerElement.innerHTML = `
                <div class="neon-border bg-black/50 backdrop-blur-sm rounded-lg p-6 mb-6">
                    <div class="text-center">
                        <h2 class="pixel-font text-4xl text-red-500 mb-4" style="animation: neonPulse 2s ease-in-out infinite;">
                            ğŸ† TOURNAMENT ${tournament.name.toUpperCase()} ğŸ†
                        </h2>
                        <div class="flex justify-center gap-8 pixel-font text-sm text-blue-300">
                            <span>Status: <span class="text-yellow-400">${getStatusText(tournament.status)}</span></span>
                            <span>Round: <span class="text-green-400">${tournament.currentRound}</span></span>
                            ${tournament.winner ? `<span>Winner: <span class="text-yellow-400">ğŸ‘‘ ${tournament.winner.username}</span></span>` : ''}
                        </div>
                    </div>
                </div>
            `;

            if (isFirstRender) {
                gsap.from(headerElement.querySelector('.neon-border'), {
                    scale: 0.9,
                    opacity: 0,
                    duration: 0.8,
                    ease: 'back.out'
                });
            }
        }
    };

    const updateBrackets = (tournament: Tournament): void => {
        const bracketsElement = document.getElementById('tournament-brackets');
        if (!bracketsElement) return;

        if (isFirstRender) {
            bracketsElement.innerHTML = generateTreeBrackets(tournament.bracket);
            tournament.bracket.forEach(match => displayedMatchIds.add(match.id));

            gsap.from('.round-column', {
                x: -50,
                opacity: 0,
                duration: 0.8,
                stagger: 0.2,
                ease: 'power2.out'
            });

            cleanupManager.setTimeout(() => drawConnections(tournament.bracket), 1000);

            isFirstRender = false;
        } else {
            const newMatches = tournament.bracket.filter(match => !displayedMatchIds.has(match.id));
            
            if (newMatches.length > 0) {
                newMatches.forEach(match => {
                    displayedMatchIds.add(match.id);
                });
                
                bracketsElement.innerHTML = generateTreeBrackets(tournament.bracket);
                drawConnections(tournament.bracket);
            }

            tournament.bracket.forEach(match => {
                updateMatchElement(match);
            });
        }
    };

    const generateTreeBrackets = (matches: Match[]): string => {
        if (matches.length === 0) {
            return '<div class="text-center p-8 pixel-font text-blue-300/60">No matches available</div>';
        }

        const matchesByRound = matches.reduce((acc, match) => {
            if (!acc[match.round]) {
                acc[match.round] = [];
            }
            acc[match.round].push(match);
            return acc;
        }, {} as Record<number, Match[]>);

        const maxRound = Math.max(...Object.keys(matchesByRound).map(Number));

        let html = '';
        
        for (let round = 1; round <= maxRound; round++) {
            const roundMatches = matchesByRound[round] || [];
            html += generateRoundColumn(round, roundMatches, round === maxRound);
        }
        
        return html;
    };

    const generateRoundColumn = (round: number, matches: Match[], isFinal: boolean): string => {
        const roundTitle = isFinal ? 'FINAL' : `ROUND ${round}`;
        
        return `
            <div class="round-column" data-round="${round}">
                <div class="round-header">
                    <h3 class="pixel-font text-xl text-blue-400">
                        ${roundTitle}
                    </h3>
                </div>
                <div class="matches-container flex flex-col justify-around gap-8 flex-1">
                    ${matches.map(match => generateMatchCard(match)).join('')}
                </div>
            </div>
        `;
    };

    const generateMatchCard = (match: Match): string => {
        const getStatusColor = (status: string): string => {
            switch (status) {
                case 'ready': return 'bg-blue-500/20 border-blue-500/50 text-blue-400';
                case 'in_progress': return 'bg-yellow-500/20 border-yellow-500/50 text-yellow-400';
                case 'finished': return 'bg-green-500/20 border-green-500/50 text-green-400';
                default: return 'bg-gray-500/20 border-gray-500/50 text-gray-400';
            }
        };

        const isMyMatch = match.player1?.id === myPlayerId || match.player2?.id === myPlayerId;

        return `
            <div class="match-card neon-border rounded-lg p-4 ${match.status} ${isMyMatch ? 'ring-2 ring-red-500/50' : ''}" 
                 data-match-id="${match.id}"
                 data-round="${match.round}"
                 data-position="${match.position}">
                
                <!-- Header du match -->
                <div class="flex justify-between items-center mb-3">
                    <span class="match-status pixel-font text-xs ${getStatusColor(match.status)} px-2 py-1 rounded border">
                        ${getStatusText(match.status)}
                    </span>
                    ${isMyMatch ? '<span class="pixel-font text-xs text-red-400">â† YOU</span>' : ''}
                </div>

                <!-- Players -->
                <div class="space-y-2">
                    <!-- Player 1 -->
                    <div class="player-slot player-1 neon-border p-3 rounded ${match.winner?.id === match.player1?.id ? 'winner' : match.winner ? 'loser' : ''}" 
                         data-player-id="${match.player1?.id || ''}">
                        <div class="flex items-center justify-between">
                            <span class="pixel-font text-sm text-blue-300">
                                ${match.player1?.username || 'TBD'}
                            </span>
                            ${match.winner?.id === match.player1?.id ? '<span class="text-xl winner-crown">ğŸ‘‘</span>' : ''}
                        </div>
                    </div>

                    <!-- VS -->
                    <div class="text-center pixel-font text-xs text-blue-400/40">VS</div>

                    <!-- Player 2 -->
                    <div class="player-slot player-2 neon-border p-3 rounded ${match.winner?.id === match.player2?.id ? 'winner' : match.winner ? 'loser' : ''}" 
                         data-player-id="${match.player2?.id || ''}">
                        <div class="flex items-center justify-between">
                            <span class="pixel-font text-sm text-blue-300">
                                ${match.player2?.username || 'TBD'}
                            </span>
                            ${match.winner?.id === match.player2?.id ? '<span class="text-xl winner-crown">ğŸ‘‘</span>' : ''}
                        </div>
                    </div>
                </div>
            </div>
        `;
    };

    const drawConnections = (matches: Match[]): void => {
        document.querySelectorAll('.connector-line').forEach(el => el.remove());

        const matchesByRound = matches.reduce((acc, match) => {
            if (!acc[match.round]) {
                acc[match.round] = [];
            }
            acc[match.round].push(match);
            return acc;
        }, {} as Record<number, Match[]>);

        const maxRound = Math.max(...Object.keys(matchesByRound).map(Number));

        for (let round = 1; round < maxRound; round++) {
            const currentRoundMatches = matchesByRound[round] || [];
            const nextRoundMatches = matchesByRound[round + 1] || [];

            currentRoundMatches.forEach((match, index) => {
                const nextMatchIndex = Math.floor(index / 2);
                const nextMatch = nextRoundMatches[nextMatchIndex];

                if (nextMatch) {
                    const currentCard = document.querySelector(`[data-match-id="${match.id}"]`) as HTMLElement;
                    const nextCard = document.querySelector(`[data-match-id="${nextMatch.id}"]`) as HTMLElement;

                    if (currentCard && nextCard) {
                        const currentRect = currentCard.getBoundingClientRect();
                        const nextRect = nextCard.getBoundingClientRect();
                        const container = document.getElementById('tournament-brackets');
                        
                        if (container) {
                            const containerRect = container.getBoundingClientRect();

                            const horizontalLine = document.createElement('div');
                            horizontalLine.className = 'connector-line connector-horizontal';
                            if (match.status === 'finished') {
                                horizontalLine.classList.add('active');
                            }
                            horizontalLine.style.left = `${currentRect.right - containerRect.left}px`;
                            horizontalLine.style.top = `${currentRect.top + currentRect.height / 2 - containerRect.top}px`;
                            horizontalLine.style.width = '40px';
                            container.appendChild(horizontalLine);

                            const junctionX = currentRect.right - containerRect.left + 40;
                            const junctionY = currentRect.top + currentRect.height / 2 - containerRect.top;
                            const nextJunctionY = nextRect.top + nextRect.height / 2 - containerRect.top;

                            if (index % 2 === 1) {
                                const verticalLine = document.createElement('div');
                                verticalLine.className = 'connector-line connector-vertical';
                                const prevMatch = currentRoundMatches[index - 1];
                                const prevCard = document.querySelector(`[data-match-id="${prevMatch.id}"]`) as HTMLElement;
                                
                                if (prevCard) {
                                    const prevRect = prevCard.getBoundingClientRect();
                                    const prevY = prevRect.top + prevRect.height / 2 - containerRect.top;
                                    
                                    verticalLine.style.left = `${junctionX}px`;
                                    verticalLine.style.top = `${Math.min(prevY, junctionY)}px`;
                                    verticalLine.style.height = `${Math.abs(junctionY - prevY)}px`;
                                    container.appendChild(verticalLine);
                                }

                                const finalHorizontal = document.createElement('div');
                                finalHorizontal.className = 'connector-line connector-horizontal';
                                finalHorizontal.style.left = `${junctionX}px`;
                                finalHorizontal.style.top = `${nextJunctionY}px`;
                                finalHorizontal.style.width = `${nextRect.left - containerRect.left - junctionX}px`;
                                container.appendChild(finalHorizontal);
                            }
                        }
                    }
                }
            });
        }
    };

    const updateMatchElement = (match: Match): void => {
        const matchElement = document.querySelector(`[data-match-id="${match.id}"]`);
        if (!matchElement) return;

        const statusEl = matchElement.querySelector('.match-status');
        if (statusEl) {
            const newStatus = getStatusText(match.status);
            if (statusEl.textContent !== newStatus) {
                statusEl.textContent = newStatus;
                
                const getStatusColor = (status: string): string => {
                    switch (status) {
                        case 'ready': return 'bg-blue-500/20 border-blue-500/50 text-blue-400';
                        case 'in_progress': return 'bg-yellow-500/20 border-yellow-500/50 text-yellow-400';
                        case 'finished': return 'bg-green-500/20 border-green-500/50 text-green-400';
                        default: return 'bg-gray-500/20 border-gray-500/50 text-gray-400';
                    }
                };
                
                statusEl.className = `match-status pixel-font text-xs px-2 py-1 rounded border ${getStatusColor(match.status)}`;
                
                matchElement.className = `match-card neon-border rounded-lg p-4 ${match.status} ${
                    match.player1?.id === myPlayerId || match.player2?.id === myPlayerId ? 'ring-2 ring-red-500/50' : ''
                }`;
            }
        }

        if (match.winner) {
            const player1Slot = matchElement.querySelector('.player-1');
            const player2Slot = matchElement.querySelector('.player-2');

            if (player1Slot && player2Slot) {
                const isPlayer1Winner = match.winner.id === match.player1?.id;
                const isPlayer2Winner = match.winner.id === match.player2?.id;

                const p1Classes = `player-slot player-1 neon-border p-3 rounded ${isPlayer1Winner ? 'winner' : 'loser'}`;
                if (player1Slot.className !== p1Classes) {
                    player1Slot.className = p1Classes;
                    if (isPlayer1Winner && !player1Slot.querySelector('.winner-crown')) {
                        const crownEl = document.createElement('span');
                        crownEl.className = 'text-xl winner-crown';
                        crownEl.textContent = 'ğŸ‘‘';
                        player1Slot.querySelector('div')?.appendChild(crownEl);
                    }
                }

                const p2Classes = `player-slot player-2 neon-border p-3 rounded ${isPlayer2Winner ? 'winner' : 'loser'}`;
                if (player2Slot.className !== p2Classes) {
                    player2Slot.className = p2Classes;
                    if (isPlayer2Winner && !player2Slot.querySelector('.winner-crown')) {
                        const crownEl = document.createElement('span');
                        crownEl.className = 'text-xl winner-crown';
                        crownEl.textContent = 'ğŸ‘‘';
                        player2Slot.querySelector('div')?.appendChild(crownEl);
                    }
                }
            }
        }
    };

    const getStatusText = (status: string): string => {
        switch (status) {
            case 'registration': return 'REGISTRATION';
            case 'in_progress': return 'IN PROGRESS';
            case 'finished': return 'FINISHED';
            case 'ready': return 'READY';
            case 'pending': return 'PENDING';
            default: return status.toUpperCase();
        }
    };

    const hideLoading = (): void => {
        const loading = document.getElementById('tournament-loading');
        if (loading) loading.style.display = 'none';
    };

    const showContent = (): void => {
        const content = document.getElementById('tournament-content');
        if (content) content.style.display = 'block';
    };

    const showError = (): void => {
        hideLoading();
        const error = document.getElementById('tournament-error');
        if (error) error.style.display = 'block';
    };

    fetchTournamentData();

    pollInterval = cleanupManager.setInterval(() => {
        fetchTournamentData();
        if (currentTournamentState) {
            cleanupManager.setTimeout(() => drawConnections(currentTournamentState!.bracket), 100);
        }
    }, 2000);
    console.log('ğŸ”„ Started bracket polling');

    // Enregistrer le cleanup du polling
    cleanupManager.onCleanup(() => {
        cleanupIntervals();
    });

    return cleanupManager.getCleanupFunction();
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/router/Router.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Route, CleanupFunction, RouteParams, ViewModule, ViewFunction } from './types';
import { ComponentManager } from '../components/ComponantManager'
import { LoadingView } from '../components/LoadingView';
import type { NavigationGuard } from './types';
import {
    logGuard,
    tournamentExistsGuard,
    roomExistsGuard
} from './Guards'

export class Router {
    private routes: Route[];
	private currentCleanup: CleanupFunction | null = null;
    private componentManager: ComponentManager;
    private currentRoute?: Route;
    private globalBeforeEach?: NavigationGuard;
	private navigationHistory: string[] = [];
    private readonly MAX_HISTORY = 10;

	// Cache pour les modules lazy-loaded
	private moduleCache: Map<string, ViewModule> = new Map();
	private loadingPromises: Map<string, Promise<ViewModule>> = new Map();
    
    constructor()
    {
        this.routes = [];
        this.componentManager = new ComponentManager();
        this.setupRoutes();
		this.setupLinkInterception();
		this.setupHistoryNavigation();

        this.globalBeforeEach = logGuard;

		// PrÃ©charger les routes critiques aprÃ¨s le chargement initial
		this.prefetchCriticalRoutes();
    }

	/**
	 * Charge un module de vue de maniÃ¨re lazy avec mise en cache
	 */
	private async loadView(route: Route): Promise<{ view: ViewFunction; onMount?: (params?: RouteParams) => CleanupFunction | void }> {
		// Si la vue est synchrone, retourner directement
		if (route.view) {
			return { view: route.view, onMount: route.onMount };
		}

		// Si pas de lazyView, erreur
		if (!route.lazyView) {
			throw new Error(`Route ${route.path} has no view or lazyView`);
		}

		const cacheKey = route.path;

		// VÃ©rifier le cache
		if (this.moduleCache.has(cacheKey)) {
			const module = this.moduleCache.get(cacheKey)!;
			return this.extractViewFromModule(module);
		}

		// VÃ©rifier si un chargement est dÃ©jÃ  en cours
		if (this.loadingPromises.has(cacheKey)) {
			const module = await this.loadingPromises.get(cacheKey)!;
			return this.extractViewFromModule(module);
		}

		// Charger le module
		const loadingPromise = route.lazyView();
		this.loadingPromises.set(cacheKey, loadingPromise);

		try {
			const module = await loadingPromise;
			this.moduleCache.set(cacheKey, module);
			this.loadingPromises.delete(cacheKey);
			return this.extractViewFromModule(module);
		} catch (error) {
			this.loadingPromises.delete(cacheKey);
			console.error(`Failed to load view for ${route.path}:`, error);
			throw error;
		}
	}

	/**
	 * Extrait la fonction de vue et onMount du module chargÃ©
	 */
	private extractViewFromModule(module: ViewModule): { view: ViewFunction; onMount?: (params?: RouteParams) => CleanupFunction | void } {
		// Chercher la fonction de vue selon les conventions de nommage
		// 1. Exports standards: HomeView, QuickPlayView, etc.
		// 2. Export default
		// 3. Export nommÃ© 'view'
		// 4. Premier export fonction trouvÃ©
		let viewFunction: ViewFunction | undefined;

		// Essayer de trouver un export avec pattern *View
		const viewExport = Object.entries(module).find(([key]) =>
			key.endsWith('View') && typeof module[key] === 'function'
		);

		if (viewExport) {
			viewFunction = viewExport[1] as ViewFunction;
		} else {
			// Fallback sur default ou view
			viewFunction = (module.default ||
						   module.view ||
						   Object.values(module).find(exp => typeof exp === 'function' && exp.length <= 1)) as ViewFunction;
		}

		if (!viewFunction || typeof viewFunction !== 'function') {
			throw new Error('No valid view function found in module');
		}

		// Chercher onMount/logic selon les conventions
		// homeLogic, quickPlayLogic, etc. ou onMount
		let onMount: ((params?: RouteParams) => CleanupFunction | void) | undefined;

		const logicExport = Object.entries(module).find(([key]) =>
			key.endsWith('Logic') && typeof module[key] === 'function'
		);

		if (logicExport) {
			onMount = logicExport[1] as (params?: RouteParams) => CleanupFunction | void;
		} else {
			onMount = module.onMount || module.logic;
		}

		return {
			view: viewFunction,
			onMount: onMount as ((params?: RouteParams) => CleanupFunction | void) | undefined
		};
	}

	/**
	 * PrÃ©charge une route en arriÃ¨re-plan
	 */
	public prefetch(path: string): void {
		const matchResult = this.findRoute(path);
		if (matchResult?.route.lazyView && !this.moduleCache.has(matchResult.route.path)) {
			this.loadView(matchResult.route).catch(err => {
				console.warn(`Failed to prefetch ${path}:`, err);
			});
		}
	}

	/**
	 * PrÃ©charge les routes critiques dÃ©finies avec prefetch: true
	 */
	private prefetchCriticalRoutes(): void {
		// Attendre que la page soit chargÃ©e avant de prÃ©charger
		if (document.readyState === 'complete') {
			this.doPrefetch();
		} else {
			window.addEventListener('load', () => {
				// Attendre un peu pour ne pas ralentir le chargement initial
				setTimeout(() => this.doPrefetch(), 500);
			});
		}
	}

	private doPrefetch(): void {
		this.routes
			.filter(route => route.prefetch)
			.forEach(route => {
				if (route.lazyView) {
					this.loadView(route).catch(err => {
						console.warn(`Failed to prefetch ${route.path}:`, err);
					});
				}
			});
	}

	public getPreviousRoute(): string {
        if (this.navigationHistory.length >= 2) {
            return this.navigationHistory[this.navigationHistory.length - 2];
        }
        return this.getDefaultBackRoute(this.currentRoute?.path || '/');
    }

	private getDefaultBackRoute(currentPath: string): string {
        // Routes de jeu â†’ retour au mode de jeu sÃ©lectionnÃ©
        if (currentPath.startsWith('/game/') || currentPath.startsWith('/game3d/')) {
            return '/play';
        }

        // Waiting room â†’ retour Ã  la sÃ©lection du mode
        if (currentPath === '/play/waiting') {
            return '/play';
        }

        // Jeu local â†’ retour Ã  la sÃ©lection du mode
        if (currentPath === '/local') {
            return '/play';
        }

        // Tournoi local - bracket â†’ retour au setup
        if (currentPath === '/local-tournament-bracket') {
            return '/local-tournament-setup';
        }

        // Tournoi local - setup â†’ retour Ã  la sÃ©lection du mode
        if (currentPath === '/local-tournament-setup') {
            return '/play';
        }

        // Tournoi en ligne - bracket â†’ retour Ã  la liste des tournois
        if (currentPath.startsWith('/tournament/') && currentPath !== '/tournament') {
            return '/tournament';
        }

        // DÃ©tail d'une partie â†’ retour Ã  l'historique
        if (currentPath.startsWith('/history/')) {
            return '/history';
        }

        // Blockchain â†’ retour Ã  l'accueil
        if (currentPath === '/blockchain') {
            return '/';
        }

        // Pages principales â†’ retour Ã  l'accueil
        if (['/play', '/tournament', '/history', '/login', '/create'].includes(currentPath)) {
            return '/';
        }

        // Fallback â†’ accueil
        return '/';
    }
    
    private setupRoutes(): void
    {
        // Page d'accueil - Eager loading (chargÃ©e immÃ©diatement)
		// C'est la premiÃ¨re page donc on la charge directement
        this.routes.push({
            path: '/',
            lazyView: () => import('../views/HomeView'),
			prefetch: false,  // DÃ©jÃ  chargÃ©e
            title: 'Accueil'
        });

		// QuickPlay - Lazy avec prefetch (page trÃ¨s visitÃ©e)
		this.routes.push({
            path: '/play',
            lazyView: () => import('../views/QuickPlayView'),
			prefetch: true,  // PrÃ©charger en arriÃ¨re-plan
            title: 'QuickPlay'
        });

		// Waiting Room - Lazy
		this.routes.push({
            path: '/play/waiting',
            lazyView: () => import('../views/WaitingRoomView'),
            title: 'Waiting Room'
        });

		// Local Game - Lazy
		this.routes.push({
            path: '/local',
            lazyView: () => import('../views/LocalGameView'),
            title: 'Local Game'
        });

		// Local Tournament Setup - Lazy
		this.routes.push({
            path: '/local-tournament-setup',
            lazyView: () => import('../views/LocalTournamentSetupView'),
            title: 'Local Tournament Setup'
        });

		// Local Tournament Bracket - Lazy
		this.routes.push({
            path: '/local-tournament-bracket',
            lazyView: () => import('../views/LocalTournamentBracketView'),
            title: 'Local Tournament Bracket'
        });

		// Game View - Lazy
		this.routes.push({
            path: '/game/:roomId',
            lazyView: () => import('../views/GameView'),
            title: 'Pong gaming',
            beforeEnter: async (to, from, params) => {
                return await roomExistsGuard(to, from, params);
            },
        });

		// Game 3D View - Lazy
		this.routes.push({
            path: '/game3d/:roomId',
            lazyView: () => import('../views/Game3dView'),
            title: 'Pong 3D gaming',
            beforeEnter: async (to, from, params) => {
                return await roomExistsGuard(to, from, params);
            },
        });

		// Tournament - Lazy avec prefetch
        this.routes.push({
            path: '/tournament',
            lazyView: () => import('../views/TournamentView'),
			prefetch: true,  // PrÃ©charger en arriÃ¨re-plan
            title: 'Tournament'
        });

		// Tournament Bracket - Lazy
        this.routes.push({
            path: '/tournament/:id',
            lazyView: () => import('../views/BracketView'),
            title: 'Tounament brackets',
            beforeEnter: async (to, from, params) => {
                return await tournamentExistsGuard(to, from, params);
            }
        });

		// DB User - Lazy
        this.routes.push({
            path: '/dbuser',
            lazyView: () => import('../views/DbUserView'),
            title: 'dbUser',
        });

		// History - Lazy
        this.routes.push({
            path: '/history',
            lazyView: () => import('../views/HistoryView'),
            title: 'Historique des Parties'
        });

		// Game Detail - Lazy
        this.routes.push({
            path: '/history/:id',
            lazyView: () => import('../views/GameDetailView'),
            title: 'DÃ©tails de la Partie'
        });

		// Login - Lazy
		this.routes.push({
            path: '/login',
            lazyView: () => import('../views/LoginView'),
            title: 'Login'
        });

		// Create Account - Lazy
		this.routes.push({
            path: '/create',
            lazyView: () => import('../views/CreateAccountView'),
            title: 'Create Account'
        });

		// Dev 3D - Lazy
		this.routes.push({
			path: '/dev3d',
            lazyView: () => import('../views/Game3dView'),
			title: 'game 3D'
		});

		// Blockchain - Lazy
		this.routes.push({
			path: '/blockchain',
            lazyView: () => import('../views/BlockchainView'),
			title: 'Blockchain Registry'
		});

        this.compileRoutes();
    }

    private compileRoutes(): void {
        this.routes.forEach(route => {
            if (route.path.includes(':'))
            {
                const paramNames: string[] = [];
                
                const regexPattern = route.path.replace(/:([^/]+)/g, (match, paramName) => {
                    paramNames.push(paramName);
                    return '([^/]+)';
                });

                route.regex = new RegExp(`^${regexPattern}$`);
                route.paramNames = paramNames;
            }
        });
    }

	private setupLinkInterception(): void
    {
		document.addEventListener('click', (e: MouseEvent) => {
			const target = e.target as HTMLElement;
			const link = target.closest('a');
			
			if (link && link instanceof HTMLAnchorElement)
            {
				const href = link.getAttribute('href');
				
				if (!href) return;
				
				if (this.isExternalLink(href))
                {
					return;
				}
				
				e.preventDefault();
				this.navigateTo(href);
			}
		});
	}

	private isExternalLink(href: string): boolean
    {
		return /^(https?:\/\/|mailto:|tel:|ftp:)/.test(href);
	}

	private setupHistoryNavigation(): void
    {
        window.addEventListener('popstate', () => {
            this.navigate(window.location.pathname, false);
        });
    }

	public navigateTo(path: string): void
    {
        if (window.location.pathname !== path)
        {
            window.history.pushState({}, '', path);
            this.navigate(path);
        }
    }
    
    public async navigate(path: string, updateHistory: boolean = true): Promise<void> {
        this.cleanup();
        
        const matchResult = this.findRoute(path);
        if (matchResult) {
            const { route, params } = matchResult;

            if (this.globalBeforeEach)
            {
                const globalResult = await this.globalBeforeEach(
                    route, 
                    this.currentRoute, 
                    params
                );
                
                if (globalResult === false)
                {
                    console.log('Navigation unauthorized by global guard');
                    return;
                }
                
                if (typeof globalResult === 'string')
                {
                    console.log(`Global redirection to ${globalResult}`);
                    this.navigateTo(globalResult);
                    return;
                }
            }

            if (route.beforeEnter)
            {
                const guardResult = await route.beforeEnter(
                    route, 
                    this.currentRoute, 
                    params
                );
                
                if (guardResult === false)
                {
                    console.log('Navigation unauthorized by local path guard');
                    return;
                }
                
                if (typeof guardResult === 'string')
                {
                    console.log(`Redirection by local path guard to ${guardResult}`);
                    this.navigateTo(guardResult);
                    return;
                }
            }

			this.navigationHistory.push(path);
            if (this.navigationHistory.length > this.MAX_HISTORY) {
                this.navigationHistory.shift();
            }

			// Afficher le loading si vue lazy et non cachÃ©e
			const app = document.getElementById('app');
			if (route.lazyView && !this.moduleCache.has(route.path)) {
				if (app) {
					app.innerHTML = LoadingView();
				}
			}

			try {
				// Charger la vue (lazy ou synchrone)
				const { view, onMount } = await this.loadView(route);
				const htmlContent = view(params);

				if (app) {
					app.innerHTML = htmlContent;
				}

				document.title = route.title || 'Transcendence';

				if (updateHistory && window.location.pathname !== path) {
					window.history.pushState({}, '', path);
				}

				this.componentManager.scanAndMount();

				// Utiliser onMount du module chargÃ© ou de la route
				const mountFunction = onMount || route.onMount;
				if (mountFunction) {
					const cleanup = mountFunction(params);
					if (cleanup && typeof cleanup === 'function') {
						this.currentCleanup = cleanup;
					}
				}

				this.currentRoute = route;
			} catch (error) {
				console.error('Failed to load view:', error);
				this.show404();
			}

        } else {
            this.show404();
        }
    }

	public goBack(): void {
        const previousRoute = this.getPreviousRoute();
        this.navigateTo(previousRoute);
    }

	private cleanup(): void
    {
		// Tuer toutes les animations GSAP en cours
		if (typeof window !== 'undefined' && (window as any).gsap) {
			const gsap = (window as any).gsap;
			gsap.killTweensOf('*');  // Tue toutes les animations
		}

		// Nettoyer les composants
        this.componentManager.cleanupAll();

		// Appeler le cleanup spÃ©cifique de la vue
        if (this.currentCleanup)
        {
            this.currentCleanup();
            this.currentCleanup = null;
        }
    }
    
    private findRoute(path: string): { route: Route; params: RouteParams } | undefined {
        for (const route of this.routes)
        {
            if (!route.regex && route.path === path)
            {
                return { route, params: {} };
            }
            
            if (route.regex && route.paramNames)
            {
                const match = path.match(route.regex);
                if (match)
                {
                    const params: RouteParams = {};
                    
                    route.paramNames.forEach((paramName, index) => {
                        params[paramName] = match[index + 1];
                    });
                    
                    return { route, params };
                }
            }
        }
        
        return undefined;
    }
    
    private show404(): void
    {
        document.getElementById('app')!.innerHTML = '<h1>Erm... This page does not exist.</h1>';
    }

    public setGlobalGuard(guard: NavigationGuard): void {
        this.globalBeforeEach = guard;
    }
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/router/Guards.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { NavigationGuard } from './types';

export const roomExistsGuard: NavigationGuard = async (to, from, params) => {
    const roomId = params?.roomId;

    if (!roomId)
	{
        console.log('No room id provided');
        return '/';
    }

	// Check if this is a local tournament match
	const isLocalTournament = sessionStorage.getItem('localTournamentMatch');
	const localGameConfig = sessionStorage.getItem('localGameConfig');
	if (isLocalTournament && localGameConfig && roomId.startsWith('local-tournament-')) {
		console.log('Local tournament match detected, allowing navigation');
		return true;
	}

	const cachedWsUrl = sessionStorage.getItem('gameWsURL');
    if (cachedWsUrl && cachedWsUrl.includes(roomId)) {
        console.log('Room URL found in cache, allowing navigation');
        return true;
    }
    
    try {
        const host = import.meta.env.VITE_HOST || 'localhost:8443';
        const response = await fetch(
            `https://${host}/quickplay/status/${roomId}`,
            {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }
        );
        
        if (!response.ok) {
            console.log('Invalid room');
            return '/';
        }
        
        const data = await response.json();
        
        if (data.status === 'ready' && data.gameServerURL) {
            console.log('Room exists, statut ready');
            sessionStorage.setItem('gameWsURL', data.gameServerURL);
            return true;
        } else if (data.status === 'waiting') {
            console.log('Room is waiting for players, redirection');
            return '/play';
        } else if (data.status === 'finished') {
            console.log('Room is finished, redirection');
            return '/play';
        } else {
            console.log('Invalid room status:', data.status);
            return '/play';
        }
    } catch (err) {
        console.error('Error while guard checking the room', err);
        return '/';
    }
};

export const tournamentExistsGuard: NavigationGuard = async (to, from, params) => {
    if (!params?.id) {
        console.log('No tournament id provided');
        return '/tournament';
    }
    
    try {
        const host = import.meta.env.VITE_HOST || 'localhost:8443';
        const response = await fetch(
            `https://${host}/tournamentback/tournaments/${params.id}`
        );
        
        if (!response.ok) {
            console.log('Tournament not found');
            return '/tournament';
        }
        
        return true;
    } catch (err) {
        console.error('Error while fetching tournament:', err);
        return '/tournament';
    }
};

export const logGuard: NavigationGuard = (to, from, params) => {
    console.log('ğŸ“ Navigation:', {
        from: from?.path || 'initial',
        to: to.path,
        params
    });
    return true;
};



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/router/types.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Type pour les modules de vue chargÃ©s dynamiquement
export interface ViewModule {
	[key: string]: ViewFunction | ((params?: RouteParams) => CleanupFunction | void);
}

// Type pour le lazy loading - fonction qui retourne une Promise du module
export type LazyViewLoader = () => Promise<ViewModule>;

export interface Route
{
	path: string;
	view?: ViewFunction;  // Vue synchrone (optionnel maintenant)
	lazyView?: LazyViewLoader;  // Vue lazy-loaded (optionnel)
	onMount?: (params?: RouteParams) => CleanupFunction | void;
	title?: string;
	regex?: RegExp;
    paramNames?: string[];

	beforeEnter?: NavigationGuard;
    meta?: Record<string, any>;

	// Options de performance
	prefetch?: boolean;  // PrÃ©charger cette route en arriÃ¨re-plan
}

export type GuardResult = boolean | string | Promise<boolean | string>;

export type NavigationGuard = (
	to: Route,
    from?: Route,
    params?: RouteParams
) => GuardResult;

export type ViewFunction = (params?: RouteParams) => string;
export type CleanupFunction = () => void;
export type RouteParams = Record<string, string>;



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/main.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import './style.css'
import './global.css'
import { Router } from './router/Router';
import { registerComponents } from './components';
import { SimpleAuth } from './simpleAuth/SimpleAuth'

declare global {
    interface Window {
        router: Router;
        simpleAuth: SimpleAuth;
    }
}

registerComponents(); 

const auth = new SimpleAuth()
window.simpleAuth = auth;

const router = new Router();

const currentPath = window.location.pathname;
router.navigate(currentPath);

window.router = router;

document.addEventListener('click', (e: MouseEvent) => {
    const target = e.target as HTMLElement;
    const backButton = target.closest('[data-smart-back]');
    
    if (backButton) {
        e.preventDefault();
        const fallback = backButton.getAttribute('data-smart-back');
        
        if (window.router) {
            window.router.goBack();
        } else if (fallback) {
            window.location.href = fallback;
        } else {
            window.location.href = '/';
        }
    }
});



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/frontend/src/net/wsClient.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export type PublicState = {
	leftPaddle: {y: number; speed: number; intention: number};
	rightPaddle: {y: number; speed: number; intention: number};
	balls: {x: number; y: number; vx: number; vy: number; radius: number}[];
	score: {left: number; right: number};
	isPaused: boolean;
	isGameOver: boolean;
	winner: '' | 'left' | 'right';
	countdownValue: number;
	powerUps: {x: number, y: number, radius: number, type: string}[];
	splitActive: boolean;
	clock: number;
	blackoutLeft: boolean;
	blackoutRight: boolean;
	blackoutLeftIntensity: number;
	blackoutRightIntensity: number;
	blackholeActive: boolean;
	blackholeProgress: number;
	blackholeCenterX: number;
	blackholeCenterY: number;
	selectedSkills: {
		left: 'smash' | 'dash';
		right: 'smash' | 'dash';
	};
	skillStates: {
		left: {cooldownRemaining: number; lastActivationAt: number};
		right: {cooldownRemaining: number; lastActivationAt: number};
	};
};

type ServerMsg = 
	| {type: 'welcome'; side: 'left' | 'right'; isTournament?: boolean; tournamentId?: string; players?: {left?: string; right?: string}}
	| {type: 'state'; state: PublicState; serverTime: number}
	| {type: 'countdown'; value: number}
	| {type: 'paused' | 'resumed'}
    | {type: 'timeout_status'; left: {active: boolean; remainingMs: number};
                               right: {active: boolean; remainingMs: number};}
	| {type: 'gameover'; winner: 'left' | 'right'; isTournament?: boolean; tournamentId?: string}
	| {type: 'pong'; t: number};

// apps/frontend/src/net/wsClient.ts
export class WSClient {
	private ws?: WebSocket;
	side: 'left' | 'right' = 'left';

	isTournament: boolean = false;
	tournamentId?: string;
	playerNames: {left?: string; right?: string} = {};
	private playerIdOverride?: string;

	onState?: (s: PublicState) => void;
	onCountdown?: (v: number) => void;
	onGameOver?: (w: 'left' | 'right', isTournament?: boolean, tournamentId?: string) => void;
	onPaused?: () => void;
	onResumed?: () => void;
	onTimeoutStatus?: (status: {
		left: {active: boolean; remainingMs: number};
		right: {active: boolean; remainingMs: number}
	}) => void;
	onWelcome?: (side: 'left' | 'right' | 'spectator', playerNames?: {left?: string; right?: string}) => void;
	onPong?: (serverTime: number) => void;

	connect(url?: string, options?: { playerId?: string }) {
		const host = import.meta.env.VITE_HOST
		const endpoint = import.meta.env.VITE_GAME_ENDPOINT
		const defaultUrl = (host && endpoint) ? `wss://${host}${endpoint}`
					: undefined;
		const finalUrl = url ?? defaultUrl;
		this.playerIdOverride = options?.playerId;
		if (!finalUrl)
		{
			console.warn('WSClient: no URL provided and no defaultUrl');
			return;
		}
		console.log('WSClient: connecting to', finalUrl);
		this.ws = new WebSocket(finalUrl);
		this.ws.onopen = () => {
			const playerId = this.playerIdOverride ?? window.simpleAuth.getPlayerId();
			console.log('WebSocket opened, sending logIn with ID:', playerId);
			if (!playerId) {
				console.warn('WSClient: no playerId available, closing connection');
				this.ws?.close();
				return;
			}
			this.ws?.send(JSON.stringify({
				type: 'logIn', 
				id: playerId
			}));
		};
		this.ws.onmessage = (ev) => {
			const msg = JSON.parse(ev.data) as ServerMsg;
			switch (msg.type) {
				case 'welcome':
					console.log('Welcome from server');
					this.side = msg.side;
					this.playerNames = msg.players || {};
					this.onWelcome?.(msg.side, msg.players);
					break;
				case 'state':
					this.onState?.(msg.state);
					break;
				case 'countdown':
					this.onCountdown?.(msg.value);
					break;
				case 'paused':
					this.onPaused?.();
					break;
				case 'resumed':
					this.onResumed?.();
					break;
				case 'timeout_status':
					this.onTimeoutStatus?.(msg);
					break;
				case 'gameover':
					this.onGameOver?.(msg.winner, msg.isTournament, msg.tournamentId);
					break;
				case 'pong':
					this.onPong?.(msg.t);
					break;
			}
		};
	}

	sendInput(up: boolean, down: boolean) {
		this.ws?.send(JSON.stringify({ type: 'input', up, down }));
	}

	pause() {
		this.ws?.send(JSON.stringify({ type: 'pause' }));
	}

	resume() {
		this.ws?.send(JSON.stringify({ type: 'resume' }));
	}

	useSkill() {
		this.ws?.send(JSON.stringify({ type: 'skill' }));
	}

	forfeit() {
		this.ws?.send(JSON.stringify({ type: 'forfeit' }));
	}

	sendPing() {
		this.ws?.send(JSON.stringify({ type: 'ping', t: Date.now() }));
	}

	debugActivatePowerUp(kind: 'split' | 'blackout' | 'blackhole') {
		this.ws?.send(JSON.stringify({ 
			type: 'debug', 
			action: 'activate_powerup', 
			payload: { kind } 
		}));
	}

	debugClearPowerUps() {
		this.ws?.send(JSON.stringify({ type: 'debug', action: 'clear_powerups' }));
	}

	debugScoreChange(side: 'left' | 'right', amount: number) {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'score_change', payload: { side, amount }
		}));
	}

	debugResetScore() {
		this.ws?.send(JSON.stringify({ type: 'debug', action: 'reset_score' }));
	}

	debugSetScore(left: number, right: number) {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'set_score', payload: { left, right }
		}));
	}

	debugBallControl(mode: 'add' | 'remove' | 'reset') {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'ball_control', payload: { mode }
		}));
	}

	debugBallSpeed(mode: 'multiply' | 'divide' | 'freeze') {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'ball_speed', payload: { mode }
		}));
	}

	debugTimeScale(scale: number) {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'time_scale', payload: { scale }
		}));
	}

	debugChangeSkill(side: 'left' | 'right', skill: 'smash' | 'dash') {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'change_skill', payload: { side, skill }
		}));
	}

	disconnect(): void {
		if (this.ws) {
			console.log('WSClient: disconnecting...');
	
			this.ws.onopen = null;
			this.ws.onmessage = null;
			this.ws.onerror = null;
			this.ws.onclose = null;
			
			if (this.ws.readyState === WebSocket.OPEN || 
				this.ws.readyState === WebSocket.CONNECTING) {
				this.ws.close();
			}
			
			this.ws = undefined;
		}
	}

	cleanup(): void {
		console.log('WSClient: cleaning up...');
		
		this.onState = undefined;
		this.onCountdown = undefined;
		this.onGameOver = undefined;
		this.onPaused = undefined;
		this.onResumed = undefined;
		this.onTimeoutStatus = undefined;
		this.onWelcome = undefined;
		this.onPong = undefined;
		
		this.disconnect();
		
		this.side = 'left';
		this.isTournament = false;
		this.tournamentId = undefined;
		this.playerNames = {};
		this.playerIdOverride = undefined;
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/userback/server.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify from 'fastify'

const fastify = Fastify({
	logger: true
})


fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

fastify.get('/health', async (request, reply) => {
    return { status: 'ok', service: 'chat-backend' };
});

fastify.listen({ port: 3060, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/blockchainback/BlockchainService.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import { ethers } from 'ethers'
import { readFileSync } from 'fs'
import path from 'path'

interface TournamentResult {
	tournamentName: string
	maxPlayers: number
	winnerId: string
	winnerUsername: string
	timestamp: bigint
}

export class BlockchainService {
	private provider: ethers.JsonRpcProvider | null = null
	private contract: ethers.Contract | null = null
	private wallet: ethers.Wallet | null = null
	private contractAddress: string = ''
	private connected: boolean = false

	async initialize(): Promise<void> {
		try {
			const rpcUrl = process.env.FUJI_RPC_URL || process.env.AVALANCHE_RPC_URL || 'http://localhost:8545'
			const privateKey = process.env.BLOCKCHAIN_PRIVATE_KEY
			const contractAddr = process.env.BLOCKCHAIN_CONTRACT_ADDRESS

			if (!privateKey) {
				console.warn('BLOCKCHAIN_PRIVATE_KEY not set, blockchain service will run in read-only mode')
			}

			if (!contractAddr) {
				console.warn('BLOCKCHAIN_CONTRACT_ADDRESS not set, using default deployment')
			}

			this.provider = new ethers.JsonRpcProvider(rpcUrl)

			const contractPath = path.join('/blockchain/build/TournamentRegistry.json')
			let contractData: any

			try {
				const contractJson = readFileSync(contractPath, 'utf-8')
				contractData = JSON.parse(contractJson)
			} catch (error) {
				console.error('Could not load contract ABI from build folder')
				throw new Error('Contract ABI not found. Please compile the contract first.')
			}

			const abi = contractData.abi

			if (contractAddr) {
				this.contractAddress = contractAddr
			} else {
				this.contractAddress = contractData.contractAddress || ''
			}

			if (!this.contractAddress) {
				throw new Error('Contract address not found in environment or build file')
			}

			if (privateKey) {
				this.wallet = new ethers.Wallet(privateKey, this.provider)
				this.contract = new ethers.Contract(this.contractAddress, abi, this.wallet)
				console.log('Blockchain service initialized with wallet:', this.wallet.address)
			} else {
				this.contract = new ethers.Contract(this.contractAddress, abi, this.provider)
				console.log('Blockchain service initialized in read-only mode')
			}

			await this.provider.getNetwork()
			this.connected = true
			console.log('Successfully connected to blockchain at:', rpcUrl)
		} catch (error) {
			console.error('Failed to initialize blockchain service:', error)
			this.connected = false
		}
	}

	isConnected(): boolean {
		return this.connected
	}

	async registerTournament(
		tournamentId: string,
		tournamentName: string,
		maxPlayers: number,
		winnerId: string,
		winnerUsername: string
	): Promise<string> {
		if (!this.contract || !this.wallet) {
			throw new Error('Contract or wallet not initialized')
		}

		if (!this.connected) {
			throw new Error('Not connected to blockchain')
		}

		try {
			const tx = await this.contract.registerTournament(
				tournamentId,
				tournamentName,
				maxPlayers,
				winnerId,
				winnerUsername
			)

			console.log('Transaction sent:', tx.hash)
			const receipt = await tx.wait()
			console.log('Transaction confirmed in block:', receipt.blockNumber)

			return tx.hash
		} catch (error) {
			console.error('Error registering tournament on blockchain:', error)
			throw error
		}
	}

	async getTournament(tournamentId: string): Promise<TournamentResult | null> {
		if (!this.contract) {
			throw new Error('Contract not initialized')
		}

		try {
			const result = await this.contract.getTournament(tournamentId)
			
			return {
				tournamentName: result[0],
				maxPlayers: Number(result[1]),
				winnerId: result[2],
				winnerUsername: result[3],
				timestamp: result[4]
			}
		} catch (error) {
			console.error('Error fetching tournament from blockchain:', error)
			return null
		}
	}

	async getManyTournaments(tournamentIds: string[]): Promise<Array<{id: string, data: TournamentResult}>> {
        if (!this.contract) {
            throw new Error('Contract not initialized');
        }

        const promises = tournamentIds.map(async (id) => {
            try {
                const result = await this.contract!.getTournament(id);
                if (!result || result[0] === '') return null;

                return {
                    id,
                    data: {
                        tournamentName: result[0],
                        maxPlayers: Number(result[1]),
                        winnerId: result[2],
                        winnerUsername: result[3],
                        timestamp: result[4]
                    }
                };
            } catch (error) {
                return null;
            }
        });

        const results = await Promise.all(promises);
        return results.filter((item): item is {id: string, data: TournamentResult} => item !== null);
    }

	async getTournamentCount(): Promise<number> {
		if (!this.contract) {
			throw new Error('Contract not initialized')
		}

		try {
			const count = await this.contract.getTournamentCount()
			return Number(count)
		} catch (error) {
			console.error('Error fetching tournament count:', error)
			throw error
		}
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/blockchainback/server.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify from 'fastify'
import { BlockchainService } from './BlockchainService'

const fastify = Fastify({
	logger: true
})

const blockchainService = new BlockchainService()

const initServer = async () => {
	await blockchainService.initialize()

	fastify.post('/register-tournament', async (request, reply) => {
		const { tournamentId, tournamentName, maxPlayers, winnerId, winnerUsername } = request.body as {
			tournamentId: string
			tournamentName: string
			maxPlayers: number
			winnerId: string
			winnerUsername: string
		}

		if (!tournamentId || !tournamentName || !maxPlayers || !winnerId || !winnerUsername) {
			return reply.status(400).send({
				success: false,
				error: 'Missing required fields: tournamentId, tournamentName, maxPlayers, winnerId, winnerUsername'
			})
		}

		try {
			const txHash = await blockchainService.registerTournament(
				tournamentId,
				tournamentName,
				maxPlayers,
				winnerId,
				winnerUsername
			)

			fastify.log.info(`Tournament ${tournamentId} registered on blockchain: ${txHash}`)

			return {
				success: true,
				transactionHash: txHash,
				message: 'Tournament registered on blockchain'
			}
		} catch (error) {
			fastify.log.error('Error registering tournament:', error)
			return reply.status(500).send({
				success: false,
				error: error instanceof Error ? error.message : 'Unknown error'
			})
		}
	})

	fastify.get('/tournament/:tournamentId', async (request, reply) => {
		const { tournamentId } = request.params as { tournamentId: string }

		try {
			const tournament = await blockchainService.getTournament(tournamentId)

			if (!tournament) {
				return reply.status(404).send({
					success: false,
					error: 'Tournament not found on blockchain'
				})
			}

			return {
				success: true,
				tournament
			}
		} catch (error) {
			fastify.log.error('Error fetching tournament:', error)
			return reply.status(500).send({
				success: false,
				error: error instanceof Error ? error.message : 'Unknown error'
			})
		}
	})

	fastify.get('/tournaments/count', async (request, reply) => {
		try {
			const count = await blockchainService.getTournamentCount()
			return {
				success: true,
				count
			}
		} catch (error) {
			fastify.log.error('Error fetching tournament count:', error)
			return reply.status(500).send({
				success: false,
				error: error instanceof Error ? error.message : 'Unknown error'
			})
		}
	})

	fastify.get('/tournaments/all', async (request, reply) => {
        try {
            const dbResponse = await fetch('http://database:3020/tournaments');
            const dbData = await dbResponse.json();

            if (!dbData.success || !Array.isArray(dbData.tournaments)) {
                throw new Error('Failed to fetch tournaments from DB');
            }

            const finishedTournamentIds = dbData.tournaments
                .filter((t: any) => t.status === 'finished')
                .map((t: any) => t.id);

            if (finishedTournamentIds.length === 0) {
                return { success: true, tournaments: [] };
            }

            const blockchainTournaments = await blockchainService.getManyTournaments(finishedTournamentIds);

            blockchainTournaments.sort((a, b) => {
                return Number(b.data.timestamp) - Number(a.data.timestamp);
            });

            return {
                success: true,
                tournaments: blockchainTournaments
            };

        } catch (error) {
            fastify.log.error('Error fetching all tournaments:', error);
            return reply.status(500).send({
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    });

	fastify.get('/health', async (request, reply) => {
		const isConnected = blockchainService.isConnected()
		return {
			status: isConnected ? 'ok' : 'degraded',
			service: 'blockchain-backend',
			blockchain: isConnected ? 'connected' : 'disconnected'
		}
	})

	fastify.listen({ port: 3070, host: '0.0.0.0' }, function (err, address) {
		if (err) {
			fastify.log.error(err)
			process.exit(1)
		}
		fastify.log.info(`Blockchain service listening on ${address}`)
	})
}

initServer()



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/tournamentback/server.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify from 'fastify'
import { TournamentManager } from './TournamentManager'
import type { Player } from './types'

const fastify = Fastify({
	logger: true
})

const tournamentManager = new TournamentManager()

const initServer = async () => {
	await tournamentManager.initTournaments()

    fastify.post('/match-finished', async (request, reply) => {
        const { matchId, winnerId } = request.body as { 
            matchId: string; 
            winnerId: string;
        };

        if (!matchId || !winnerId)
        {
            return reply.status(400).send({ 
                success: false, 
                error: 'matchId and winnerId are required' 
            });
        }

        console.log(`Match ${matchId} finished, winner: ${winnerId}`);

        tournamentManager.onMatchFinished(matchId, winnerId);

        return { success: true };
    });

    fastify.get('/tournaments', async (request, reply) => {
        const registrations = tournamentManager.getCurrentRegistrations()
        return { success: true, registrations }
    })

    fastify.post('/tournaments/:tournamentId/join', async (request, reply) => {
        const { tournamentId } = request.params as { tournamentId: string }
        const { username, playerId } = request.body as { username: string; playerId: string }

        if (!username || !playerId)
        {
            return reply.status(400).send({ 
                success: false, 
                error: 'Username and playerId are required' 
            })
        }

        const newPlayer: Player = {
            id: playerId,
            username,
            currentTournament: tournamentId,
            isEleminated: false,
        }

        const success = tournamentManager.registerPlayer(tournamentId, newPlayer)
        
        if (!success)
        {
            return reply.status(400).send({ 
                success: false, 
                error: 'Cannot join tournament: tournament full or unavailable' 
            })
        }

        const tournament = tournamentManager.getTournamentDetails(tournamentId)
        if (tournament?.status === 'in_progress')
        {
            return { 
                success: true, 
                tournamentStarted: true,
                tournamentId: tournament.id,
                message: 'Tournament is starting!' 
            }
        }

        return { 
            success: true, 
            tournamentStarted: false,
            currentPlayers: tournament?.currentPlayers.length || 0,
            maxPlayers: tournament?.maxPlayers || 0
        }
    })

    fastify.delete('/tournaments/leave/:playerId', async (request, reply) => {
        const { playerId } = request.params as { playerId: string }
        
        const removed = tournamentManager.removePlayerFromAllRegistrations(playerId)
        
        return { success: removed }
    })

    fastify.get('/tournaments/:id', async (request, reply) => {
        const { id } = request.params as { id: string }
        
        const tournament = tournamentManager.getTournamentDetails(id)
        
        if (!tournament)
        {
            return reply.status(404).send({ error: 'Tournament not found' })
        }
        
        return { success: true, tournament }
    })

    fastify.get('/tournaments/:id/brackets', async (request, reply) => {
        const { id } = request.params as { id: string }
        
        const brackets = tournamentManager.getTournamentBrackets(id)
        
        if (!brackets)
        {
            return reply.status(404).send({ error: 'Tournament not found' })
        }
        
        return { success: true, tournamentId: id, brackets }
    })


    fastify.get('/', function (request, reply)
        {
            reply.send({ hello: 'world' })
        }
    )

    fastify.get('/health', async (request, reply) => {
        return { status: 'ok', service: 'tournament-backend' }
    })

    fastify.listen({ port: 3040, host: '0.0.0.0'}, function (err, address)
        {
            if (err)
            {
                fastify.log.error(err)
                process.exit(1)
            }	
            fastify.log.info(`server listening on ${address}`)
        }
    )
}

initServer();



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/tournamentback/types.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export interface Player
{
	id: string;
	username: string;
	currentTournament?: string;
	isEleminated: boolean;
}

export interface Match
{
	id: string;
	tournamentId: string;
	round: number;
	position: number;
	player1?: Player;
	player2?: Player;
	winner?: Player;
	roomId?: string;
	status: 'pending' | 'ready' | 'in_progress' | 'finished';
	scheduledAt?: Date;
	finishedAt?: Date;
}

export interface Tournament
{
	id: string;
	name: string;
	status: 'registration' | 'in_progress' | 'finished';
	maxPlayers: number;
	currentPlayers: Player[];
	bracket: Match[];
	currentRound: number;
	winner?: Player;
	createdAt: Date;
	StartedAt?: Date;
	finishedAt?: Date;
}

export interface registration
{
	id: string;
	name: string;
	currentPlayerCount: number;
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/tournamentback/TournamentManager.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import type { Match, Player, registration, Tournament } from "./types";
import { v4 as uuidv4 } from 'uuid'

async function callDatabase(endpoint: string, method: string = 'GET', body?: any)
{
	const url = `http://database:3020${endpoint}`;
	
	const options: RequestInit = {
		method,
	};

	if (body && method !== 'GET') {
		options.headers = { 'Content-Type': 'application/json' };
		options.body = JSON.stringify(body);
	}
	
	if (body && method !== 'GET')
	{
		options.body = JSON.stringify(body);
	}
	
	const response = await fetch(url, options);
	return response.json();
}

export class TournamentManager
{
	private tournaments = new Map<string, Tournament>()

	initTournaments(): void
	{
		this.createTournament("4p", 4);
		this.createTournament("8p", 8);
		this.createTournament("16p", 16);
	}

	getCurrentRegistrations(): registration[]
	{
		let currentRegistrations: registration[] = []

		this.tournaments.forEach(tournament => {
			if ('registration' === tournament.status)
			{
				const registration: registration = {
					id: tournament.id,
					name: tournament.name,
					currentPlayerCount: tournament.currentPlayers.length
				}
				currentRegistrations.push(registration)
			}
		})

		return currentRegistrations;
	}

	async createTournament(name: string, maxPlayers: number): Promise<Tournament>
	{
		const tournament: Tournament = {
			id: uuidv4(),
			name,
			status: 'registration',
			maxPlayers,
			currentPlayers: [],
			bracket: [],
			currentRound: 0,
			createdAt: new Date()
		}

		try
		{
			await callDatabase('/tournaments', 'POST', {
				id: tournament.id,
				name: tournament.name,
				max_players: tournament.maxPlayers
			});
		}
		catch (err)
		{
			console.error('Failed to create tournament in DB:', err);
		}

		this.tournaments.set(tournament.id, tournament);
		return tournament;
	}

	async registerPlayer(tournamentId: string, newPlayer: Player): Promise<boolean>
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament || tournament.status !== 'registration') return false;
		if (tournament.currentPlayers.length >= tournament.maxPlayers) return false;

		try
		{
			await callDatabase('/users', 'POST', {
				id: newPlayer.id,
				username: newPlayer.username
			});
		}
		catch (err)
		{
			console.log('User already exists or DB error:', err);
		}

		try
		{
			await callDatabase(`/users/${newPlayer.id}/last-seen`, 'PATCH');
		}
		catch (err)
		{
			console.log('Failed to update last_seen:', err);
		}

		this.removePlayerFromOtherRegistrations(newPlayer.id, tournamentId);

		const isPlayerInTournament = tournament.currentPlayers.some(
			player => player.id === newPlayer.id
		);
		
		if (!isPlayerInTournament)
		{
			tournament.currentPlayers.push(newPlayer);

			try
			{
				await callDatabase('/tournament-registrations', 'POST', {
					tournament_id: tournamentId,
					player_id: newPlayer.id
				});
			}
			catch (err)
			{
				console.error('Failed to register player in DB:', err);
			}
		}

		if (tournament.currentPlayers.length === tournament.maxPlayers)
		{
			await this.startTournament(tournamentId);
		}

		return true;
	}

	removePlayerFromOtherRegistrations(playerId: string, excludeTournamentId: string): void
	{
		for (const [tournamentId, tournament] of this.tournaments)
		{
			if (tournament.status === 'registration' && tournamentId !== excludeTournamentId)
			{
				const playerIndex = tournament.currentPlayers.findIndex(p => p.id === playerId);
				if (playerIndex !== -1)
				{
					tournament.currentPlayers.splice(playerIndex, 1);
					console.log(`Player ${playerId} removed from tournament ${tournament.name} (switching tournaments)`);

					callDatabase(`/tournament-registrations/tournament/${tournamentId}/player/${playerId}`, 'DELETE')
						.catch(err => console.error('Failed to remove registration from DB:', err));
				}
			}
		}
	}

	removePlayerFromAllRegistrations(playerId: string): boolean
	{
		let removed = false;
		for (const [_, tournament] of this.tournaments)
		{
			if (tournament.status === 'registration')
			{
				const playerIndex = tournament.currentPlayers.findIndex(p => p.id === playerId);
				if (playerIndex !== -1)
				{
					tournament.currentPlayers.splice(playerIndex, 1);
					console.log(`Player ${playerId} removed from tournament ${tournament.name}`);
					removed = true;

					callDatabase(`/tournament-registrations/tournament/${tournamentId}/player/${playerId}`, 'DELETE')
						.catch(err => console.error('Failed to remove registration from DB:', err));
				}
			}
		}
		return removed;
	}

	async startTournament(tournamentId: string): Promise<void>
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return;

		const shuffledPlayers = this.shuffleArray([... tournament.currentPlayers])

		const firstRoundMatches: Match[] = [];
		for (var i = 0; i < shuffledPlayers.length; i += 2)
		{
			const match: Match = {
				id: uuidv4(),
				tournamentId,
				round: 1,
				position: Math.floor(i / 2),
				player1: shuffledPlayers[i],
				player2: shuffledPlayers[i + 1],
				status: 'ready'
			};
			firstRoundMatches.push(match);
		}

		tournament.bracket = firstRoundMatches;
		tournament.status = 'in_progress';
		tournament.currentRound = 1;
		tournament.StartedAt = new Date();

		try
		{
			await callDatabase(`/tournaments/${tournamentId}/start`, 'PATCH');
		}
		catch (err)
		{
			console.error('Failed to start tournament in DB:', err);
		}

		await this.createTournament(tournament.name, tournament.maxPlayers)
		console.log(`Tournament ${tournament.name} started with ${tournament.currentPlayers.length} players`);

		await this.startNextMatch(tournamentId);
	}

	async startNextMatch(tournamentId: string): Promise<void>
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return;

		const nextMatch = tournament.bracket.find(m => 
			m.status === 'ready' &&
			m.round === tournament.currentRound &&
			m.player1 && m.player2
		);

		if (!nextMatch)
		{
			console.log(`No more matches ready in round ${tournament.currentRound}`);
			this.checkRoundCompletion(tournamentId);
			return;
		}

		try
		{
			const url = `http://quickplayback:3030/tournament-match`;

			console.log(`Creating tournament match: ${nextMatch.player1?.username} vs ${nextMatch.player2?.username}`);

			const gameId = uuidv4();
			await callDatabase('/games', 'POST', {
				id: gameId,
				room_id: `tournament-${nextMatch.id}`,
				game_type: 'tournament',
				tournament_id: tournament.id,
				tournament_round: tournament.currentRound,
				match_position: nextMatch.position,
				player_left_id: nextMatch.player1!.id,
				player_right_id: nextMatch.player2!.id
			});

			const response = await fetch(url, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					matchId: nextMatch.id,
					tournamentId: tournament.id,
					player1: {
						id: nextMatch.player1!.id,
						username: nextMatch.player1!.username
					},
					player2: {
						id: nextMatch.player2!.id,
						username: nextMatch.player2!.username
					}
				}),
			});

			if (!response.ok)
			{
				throw new Error(`Failed to create match: ${response.statusText}`);
			}

			const data = await response.json();
			
			nextMatch.roomId = data.roomId;
			nextMatch.status = 'in_progress';
			nextMatch.scheduledAt = new Date();

			await callDatabase(`/games/room/${data.roomId}/start`, 'PATCH');

			console.log(`Match started successfully: roomId=${data.roomId}`);
		}
		catch (err)
		{
			console.error('Failed to create tournament match:', err);
			setTimeout(() => this.startNextMatch(tournamentId), 5000);
		}
	}

	async onMatchFinished(matchId: string, winnerId: string): Promise<void>
	{
		const match = this.findMatchById(matchId);
		if (!match)
		{
			console.error(`Match ${matchId} not found`);
			return;
		}

		const tournament = this.tournaments.get(match.tournamentId);
		if (!tournament)
		{
			console.error(`Tournament ${match.tournamentId} not found`);
			return;
		}

		match.winner = match.player1?.id === winnerId ? match.player1 : match.player2;
		match.status = 'finished';
		match.finishedAt = new Date();

		console.log(`Match finished: ${match.winner?.username} wins!`);

		const loser = match.player1?.id === winnerId ? match.player2 : match.player1;
		if (loser) {
			const loserInTournament = tournament.currentPlayers.find(p => p.id === loser.id);
			if (loserInTournament) {
				loserInTournament.isEleminated = true;

				await callDatabase(
					`/tournament-registrations/tournament/${tournament.id}/player/${loser.id}/eliminate`,
					'PATCH'
				);
			}
		}

		await callDatabase(`/users/${winnerId}/stats`, 'PATCH', { won: loser ? false : true});

		await this.checkRoundCompletion(match.tournamentId);
	}

	async checkRoundCompletion(tournamentId: string): Promise<void> {
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return;

		const currentRoundMatches = tournament.bracket.filter(m => m.round === tournament.currentRound);
		const finishedMatches = currentRoundMatches.filter(m => m.status === 'finished');
		const inProgressMatches = currentRoundMatches.filter(m => m.status === 'in_progress');

		console.log(`Round ${tournament.currentRound} status: ${finishedMatches.length}/${currentRoundMatches.length} finished, ${inProgressMatches.length} in progress`);

		if (inProgressMatches.length > 0)
		{
			console.log('Waiting for matches to finish...');
			return;
		}

		if (finishedMatches.length === currentRoundMatches.length)
		{
			if (finishedMatches.length === 1 && tournament.currentRound > 1)
			{
				tournament.winner = finishedMatches[0].winner;
				tournament.status = 'finished';
				tournament.finishedAt = new Date();

				await callDatabase(`/tournaments/${tournamentId}/finish`, 'PATCH', {
					winner_id: tournament.winner?.id
				});

				console.log(`Tournament finished! Winner: ${tournament.winner?.username}`);
				
				// Register tournament result on blockchain
				if (tournament.winner) {
					await this.registerTournamentOnBlockchain(
						tournament.id,
						tournament.name,
						tournament.maxPlayers,
						tournament.winner.id,
						tournament.winner.username
					);
				}
				
				return;
			}

			console.log(`Creating round ${tournament.currentRound + 1}`);
			await this.createNextRound(tournament, finishedMatches);

			await callDatabase(`/tournaments/${tournamentId}/next-round`, 'PATCH');
			
			await this.startNextMatch(tournamentId);
		}
		else
		{
			await this.startNextMatch(tournamentId);
		}
	}

	async createNextRound(tournament: Tournament, previousMatches: Match[]): Promise<void> {
        const nextRound = tournament.currentRound + 1;
        const winners = previousMatches.map(m => m.winner!).filter(Boolean);

        const nextRoundMatches: Match[] = [];
        for (let i = 0; i < winners.length; i += 2)
		{
            if (winners[i + 1])
			{
                const match: Match = {
                    id: uuidv4(),
                    tournamentId: tournament.id,
                    round: nextRound,
                    position: Math.floor(i / 2),
                    player1: winners[i],
                    player2: winners[i + 1],
                    status: 'ready'
                };
                nextRoundMatches.push(match);
            }
        }

        tournament.bracket.push(...nextRoundMatches);
        tournament.currentRound = nextRound;

        console.log(`Round ${nextRound} created with ${nextRoundMatches.length} matches`);
    }

	findMatchById(id: string): Match | null
	{
        for (const tournament of this.tournaments.values()) {
            const match = tournament.bracket.find(m => m.id === id);
            if (match) return match;
        }
        return null;
    }

	getTournamentBrackets(tournamentId: string): Match[] | null
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return null;
		
		return tournament.bracket;
	}

	getTournamentDetails(tournamentId: string): Tournament | null
	{
		const tournament = this.tournaments.get(tournamentId);
		return tournament || null;
	}

	private shuffleArray<T>(array: T[]): T[]
	{
		const shuffled = [...array];

		for (let i = shuffled.length - 1; i > 0; i--)
		{
			const randIdx = Math.floor(Math.random() * (i + 1));
			[shuffled[i], shuffled[randIdx]] = [shuffled[randIdx], shuffled[i]]
		}

		return shuffled
	}

	private async registerTournamentOnBlockchain(
		tournamentId: string,
		tournamentName: string,
		maxPlayers: number,
		winnerId: string,
		winnerUsername: string
	): Promise<void> {
		try {
			const url = `http://blockchainback:3070/register-tournament`;

			console.log(`Registering tournament ${tournamentId} on blockchain...`);

			const response = await fetch(url, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					tournamentId,
					tournamentName,
					maxPlayers,
					winnerId,
					winnerUsername
				}),
			});

			if (!response.ok) {
				const error = await response.json();
				throw new Error(`Blockchain registration failed: ${error.error || response.statusText}`);
			}

			const data = await response.json();
			console.log(`Tournament ${tournamentId} registered on blockchain: ${data.transactionHash}`);
		} catch (error) {
			console.error('Failed to register tournament on blockchain:', error);
		}
	}
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/chatback/chat/chat.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify, { FastifyInstance } from 'fastify'
import websocket from '@fastify/websocket'

const connectedClients = new Set<WebSocket>()
const msgHistory: string[] = []
const MAX_HISTORY_SIZE = 50

function broadcastToAll(message: string): void
{
	connectedClients.forEach((client: WebSocket) => {
		if (client.readyState === client.OPEN)
		{
			client.send(message);
		}
	})
}

function addToHistory(msg: string): void
{
	msgHistory.push(msg)

	if (msgHistory.length > MAX_HISTORY_SIZE)
	{
		msgHistory.shift()
	}
}

function sendHistoryToClient(socket: WebSocket): void
{
	if (msgHistory.length > 0)
	{
		msgHistory.forEach(msg => {
			if (socket.readyState === socket.OPEN)
			{
				socket.send(msg)
			}
		})
	}
}

function clearHistoryIfEmpty(): void {
	if (connectedClients.size === 0)
	{
		msgHistory.length = 0
	}
}

export const handleChat = (socket, req, fastify: FastifyInstance) : void => {
	connectedClients.add(socket);
	fastify.log.info(`Clients connected: ${connectedClients.size}`)

	sendHistoryToClient(socket)

	socket.on('message', message =>
		{
			const msgStr = message.toString()
			fastify.log.info(`Message received: ${msgStr}`)

			const formattedMsg = `Client said: ${msgStr}`

			addToHistory(formattedMsg)
			broadcastToAll(formattedMsg)
		}
	)

	socket.on('close', () => {
		connectedClients.delete(socket)
		fastify.log.info(`Client disconnected, ${connectedClients.size} clients left.`)
		clearHistoryIfEmpty()
	})

	socket.on('error', (err) => {
		fastify.log.error('WebSocket error:', err)
		connectedClients.delete(socket)
		clearHistoryIfEmpty()
	})
}



â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FILE: ./apps/chatback/server.ts
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
import Fastify from 'fastify'
import websocket from '@fastify/websocket'
import { handleChat } from './chat/chat'

const fastify = Fastify({
	logger: true
})

await fastify.register(websocket)

fastify.addHook('onRequest', async (request, reply) => {
    console.log('=== REQUÃŠTE REÃ‡UE ===')
    console.log('URL:', request.url)
    console.log('Method:', request.method)
    console.log('Headers:', JSON.stringify(request.headers, null, 2))
    console.log('====================')
})

fastify.get('/ws', { websocket: true }, function chatHandler (socket, req)
	{
		handleChat(socket, req, fastify)
	}
)

fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

fastify.get('/health', async (request, reply) => {
    return { status: 'ok', service: 'chat-backend' };
});

fastify.listen({ port: 3000, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



