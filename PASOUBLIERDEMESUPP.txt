═══════════════════════════════════════════════════════
FILE: ./apps/gameback/server.ts
═══════════════════════════════════════════════════════
import Fastify from 'fastify'
import websocket from '@fastify/websocket'
import { handleGame } from './game/game'
import { setMatchForRoom } from './game/session/session'
import { cleanupSession } from './game/session/session'

const fastify = Fastify({
	logger: true
})

await fastify.register(websocket)

fastify.addHook('onRequest', async (request, reply) => {
    console.log('=== REQUÊTE REÇUE ===')
    console.log('URL:', request.url)
    console.log('Method:', request.method)
    console.log('Headers:', JSON.stringify(request.headers, null, 2))
    console.log('====================')
})

fastify.get('/game/:roomId', { websocket: true }, function gameHandler (connection, _req)
	{
		handleGame(connection, _req, fastify)
	}
)

fastify.delete('/game/:roomId', async (request, reply) => {
    const { roomId } = request.params as { roomId: string };
    const deleted = cleanupSession(roomId);
    return reply.send({ success: deleted });
});

type CreateBody = {
    roomId: string;
    player1: {id: string; username: string};
    player2: {id: string; username: string};
	isTournament?: boolean;
    tournamentId?: string;
    matchId?: string;
}

fastify.post('/create', async (request, reply) => {

    console.log('Body:', JSON.stringify(request.body, null, 2));
	const body = request.body as Partial<CreateBody>;
    if (!body?.roomId || !body?.player1?.id || !body?.player2?.id)
    {
        reply.code(400).send({success: false, error: 'Invalid payload'});
        return;
    }
    setMatchForRoom(
		body.roomId,
		{
			left: {id: body.player1.id, username: body.player1.username || 'p1'},
			right: {id: body.player2.id, username: body.player2.username || 'p2'}
		},
		{
			isTournament: body.isTournament,
			tournamentId: body.tournamentId,
			matchId: body.matchId
		},
		fastify.log
	);

    reply.send({success: true});
})

fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

fastify.listen({ port: 3010, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/session/session.ts
═══════════════════════════════════════════════════════
import type { WebSocket, WebsocketHandler } from "@fastify/websocket";
import type { FastifyBaseLogger } from "fastify";
import { GameWorld } from "../engine/world";
import { SERVER_DT, SERVER_TICK_HZ, BROADCAST_HZ, TIMEOUT_MS } from "../engine/constants";
import type { ClientMessage, ServerMessage } from "../ws/messageTypes";
import { safeParse } from "../ws/messageTypes";

type Role = 'left' | 'right' | 'spectator';
type Player = {id: string; username: string};

const rooms = new Map<string, GameSession>();

class GameSession {
	private log?: FastifyBaseLogger;
	private world = new GameWorld();

	private clients = new Set<WebSocket>();
	private roles = new Map<WebSocket, Role>();
	private leftCtrl?: WebSocket;
	private rightCtrl?: WebSocket;
    
    private expected: {left?: Player; right?: Player} = {};

	private tickTimer?: NodeJS.Timeout;
	private broadcastTimer?: NodeJS.Timeout;

	private leftCtrlDisconnectedAt: number | null = null;
	private rightCtrlDisconnectedAt: number | null = null;
	private hadBothCtrl = false;

	private reportedGameOver = false;

	private lastPaused = false;
	private lastGameOver = false;

	private emptySince: number | null = null;

	private isTournament: boolean = false;
	private tournamentId?: string;
	private matchId?: string;

	constructor(private readonly roomId?: string, log?: FastifyBaseLogger) {
		this.startLoops();
		this.log = log;
	}

	private destroy() {
		if (this.tickTimer)
		{
			clearInterval(this.tickTimer);
		}
		if (this.broadcastTimer)
		{
			clearInterval(this.broadcastTimer);
		}
		this.clients.clear();
		this.roles.clear();
		this.leftCtrl = undefined;
		this.rightCtrl = undefined;
	}

    setPlayers(players: {left: Player; right: Player}, metadata?: {
		isTournament?: boolean;
		tournamentId?: string;
		matchId?: string;
	}) {
        this.expected.left = players.left;
        this.expected.right = players.right;

		if (metadata) {
            this.isTournament = metadata.isTournament || false;
            this.tournamentId = metadata.tournamentId;
            this.matchId = metadata.matchId;
        }

        this.log?.info({roomId: this.roomId, players: this.expected}, 'match set');
    }

	addClient(ws: WebSocket) {
		ws.on('message', (raw: Buffer) => this.onMessage(ws, raw));
		ws.on('close', () => this.onClose(ws));
		ws.on('error', () => this.onClose(ws));
	}

	private assignRole(ws: WebSocket, playerId?: string): Role {
		if (!this.expected.left?.id && !this.expected.right?.id)
		{
			throw new Error("Invalid room: no players expected")
		}
		if (this.expected.left?.id || this.expected.right?.id) 
        {
            if (playerId && this.expected.left?.id === playerId && !this.leftCtrl)
            {
                this.leftCtrl = ws;
                this.leftCtrlDisconnectedAt = null;
                return ('left');
            }
            if (playerId && this.expected.right?.id === playerId && !this.rightCtrl)
            {
                this.rightCtrl = ws;
                this.rightCtrlDisconnectedAt = null;
                return ('right');
            }
            return ('spectator');
        }
        // if (!this.leftCtrl)
        // {
        //     this.leftCtrl = ws;
        //     this.leftCtrlDisconnectedAt = null;
        //     return ('left');
        // }
        // if (!this.rightCtrl)
        // {
        //     this.rightCtrl = ws;
        //     this.rightCtrlDisconnectedAt = null;
        //     return ('right');
        // }
        return ('spectator');
	}

	private onMessage(ws: WebSocket, raw: Buffer) {
		const msg = safeParse<ClientMessage>(raw.toString());
		if (!msg)
		{
			return;
		}
        const role = this.roles.get(ws);
		const canCtrl = (role === 'left' && ws === this.leftCtrl) ||
						(role === 'right' && ws === this.rightCtrl);
		switch (msg.type) {
			case 'input': {
				if (role === 'left' && ws === this.leftCtrl)
				{
					const intention = msg.up && !msg.down ? -1 : msg.down && !msg.up ? 1 : 0;
                    this.world.applyInput('left', intention);
				}
				else if (role === 'right' && ws === this.rightCtrl)
                {
                    const intention = msg.up && !msg.down ? -1 : msg.down && !msg.up ? 1 : 0;
                    this.world.applyInput('right', intention)
                }
                break;
			}
			case 'smash': {
				if (role === 'left' || role === 'right')
				{
					this.world.pressSmash(role);
				}
				break;
			}
			case 'pause':
				if (!canCtrl)
				{
					this.send(ws, {type: 'error', message: 'Spectators can\'t pause the game'});
					break;
				}
				this.world.pause();
				break;
			case 'resume': {
				if (!canCtrl)
				{
					this.send(ws, {type: 'error', message: 'Spectators can\'t resume the game'});
					break;
				}
				if (this.world.state.isGameOver)
				{
					if (this.leftCtrl && this.rightCtrl)
					{
						this.world.restart();
						this.lastGameOver = false;
						this.broadcast({type: 'resumed'});
					}
					else
					{
						this.send(ws, {type: 'error', message: 'Two players required'});
					}
				}
				else
				{
					this.world.resume();
				}
				break;
			}
			case 'logIn':
				try
				{
					const assRole = this.assignRole(ws, msg.id);
					this.clients.add(ws);
					this.roles.set(ws, assRole);
	
					this.send(ws, {
						type: 'welcome', 
						side: assRole,
						isTournament: this.isTournament,
						tournamentId: this.tournamentId
					});
	
					this.log?.info({ roomId: this.roomId, assRole, clients: this.clients.size, playerId: msg.id }, 'client connected');
					
					const haveBoth = !!this.leftCtrl && !!this.rightCtrl;
					if (haveBoth && !this.hadBothCtrl)
					{
						if (this.world.state.isGameOver)
						{
							this.world.restart();
							this.lastGameOver = false;
						}
						else
						{
							this.world.startCountdown();
						}
					}
					this.hadBothCtrl = haveBoth;
				}
				catch (err)
				{
					this.send(ws, {type : 'error', message: 'no player expected for this room.'})
				}
				break;
			case 'ping':
				this.send(ws, {type: 'pong', t: msg.t});
				break;
		}
	}

	private onClose(ws: WebSocket) {
		this.clients.delete(ws);
		const role = this.roles.get(ws);
		this.roles.delete(ws);
		if (this.leftCtrl === ws)
		{
			this.leftCtrl = undefined;
            this.leftCtrlDisconnectedAt = Date.now();
            this.log?.info({roomId: this.roomId, role}, 'client disconnected starting 30s timeout');
		}
		if (this.rightCtrl === ws)
		{
			this.rightCtrl = undefined;
            this.rightCtrlDisconnectedAt = Date.now();
            this.log?.info({roomId: this.roomId, role}, 'client disconnected starting 30s timeout');
		}
        if (!this.leftCtrl && !this.rightCtrl)
        {
            this.log?.info({roomId: this.roomId, role}, 'Both client disconnected');
        }
		this.log?.info({roomId: this.roomId, role}, 'client disconnected');
		if (this.clients.size === 0 && this.emptySince === null)
		{
			this.emptySince = Date.now();
		}
		this.hadBothCtrl = !!this.leftCtrl && !!this.rightCtrl;
	}

	private async notifyGameEnd(reason: 'score' | 'timeout', winner?: 'left' | 'right'): Promise<void> {
        if (this.reportedGameOver)
		{
            return;
        }
        this.reportedGameOver = true;

		const winnerId = winner === 'left' ? this.expected.left?.id : this.expected.right?.id;

		if (this.isTournament && this.matchId && winnerId)
		{
            await this.notifyTournamentMatchEnd(this.matchId, winnerId);
        }

        const host = process.env.VITE_HOST || 'localhost:8443';
        const endpoint = '/quickplay/room-finished';
        const url = `https://${host}${endpoint}`;

        try
		{
            const payload = {
                roomId: this.roomId,
                reason: reason,
                winner: winner ? {
                    id: winner === 'left' ? this.expected.left?.id : this.expected.right?.id,
                    username: winner === 'left' ? this.expected.left?.username : this.expected.right?.username
                } : null,
                score: this.world.state.score
            };

            await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            this.log?.info({ roomId: this.roomId, reason }, 'Game end notified to quickplay');
        }
		catch (err)
		{
            this.log?.error({ roomId: this.roomId, error: err }, 'Failed to notify game end');
        }
    }

	private async notifyTournamentMatchEnd(matchId: string, winnerId: string): Promise<void> {
        const host = process.env.VITE_HOST || 'localhost:8443';
        const endpoint = '/tournamentback/match-finished';
        const url = `https://${host}${endpoint}`;

        try
		{
            await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    matchId,
                    winnerId
                })
            });

            this.log?.info({ 
                roomId: this.roomId, 
                matchId, 
                winnerId 
            }, 'Tournament match end notified');
        }
		catch (err)
		{
            this.log?.error({ 
                roomId: this.roomId, 
                error: err 
            }, 'Failed to notify tournament match end');
        }
    }

	private startLoops() {
		this.tickTimer = setInterval(() => {
			this.world.update(SERVER_DT);
		}, Math.round(1000 / SERVER_TICK_HZ));

		this.broadcastTimer = setInterval(() => {
            const now = Date.now();
            const leftDisconnected = this.leftCtrlDisconnectedAt !== null && !this.leftCtrl;
            const rightDisconnected = this.rightCtrlDisconnectedAt !== null && !this.rightCtrl;
            const bothDisconnected = !this.leftCtrl && !this.rightCtrl;

            if ((leftDisconnected || rightDisconnected) && !this.world.state.isGameOver)
            {
                this.world.pause();
            }
            let leftRemaining = 0;
            let rightRemaining = 0;

            if (leftDisconnected && this.leftCtrlDisconnectedAt)
            {
                const elapsed = now - this.leftCtrlDisconnectedAt;
                leftRemaining = Math.max(0, TIMEOUT_MS - elapsed);
                if (leftRemaining === 0 && !this.world.state.isGameOver)
                {
                    this.world.state.isGameOver = true;
                    this.world.state.winner = 'right';
                    this.world.state.isTimeoutLeft = true;
					this.notifyGameEnd('timeout', 'right');
                }
            }

            if (rightDisconnected && this.rightCtrlDisconnectedAt)
            {
                const elapsed = now - this.rightCtrlDisconnectedAt;
                rightRemaining = Math.max(0, TIMEOUT_MS - elapsed);
                if (rightRemaining === 0 && !this.world.state.isGameOver)
                {
                    this.world.state.isGameOver = true;
                    this.world.state.winner = 'left';
                    this.world.state.isTimeoutRight = true;
					this.notifyGameEnd('timeout', 'left');
                }
            }

            if ((leftDisconnected || rightDisconnected) && !this.world.state.isGameOver)
            {
                this.broadcast({
                    type: 'timeout_status',
                    left: {
                        active: leftDisconnected,
                        remainingMs: leftRemaining
                    },
                    right: {
                        active: rightDisconnected,
                        remainingMs: rightRemaining
                    }
                });
            }
			const state = this.world.publicState();
			this.broadcast({type: 'state', state, serverTime: Date.now()});
			if (state.countdownValue > 0)
			{
				this.broadcast({type: 'countdown', value: state.countdownValue});
			}
			const pausedNow = state.isPaused;
			if (pausedNow !== this.lastPaused)
			{
				this.broadcast({type: pausedNow ? 'paused' : 'resumed'});
				this.lastPaused = pausedNow
			}
			if (state.isGameOver && !this.lastGameOver)
			{
				this.lastGameOver = true;
				this.broadcast({
					type: 'gameover', 
					winner: state.winner || 'left',
					isTournament: this.isTournament,
					tournamentId: this.tournamentId
				});
				this.notifyGameEnd('score', state.winner as 'left' | 'right');
			}
			if (this.clients.size === 0)
			{
				if (this.emptySince && (Date.now() - this.emptySince > 5 * 60_000))
				{
					rooms.delete(this.roomId || '');
					this.destroy();
					return;
				}
			else
			{
				this.emptySince = null;
			}
			}
		}, Math.round(1000 / BROADCAST_HZ));
	}

	private send(ws: WebSocket | undefined, msg: ServerMessage) {
		if (!ws || ws.readyState !== 1)
		{
			return;
		}
		ws.send(JSON.stringify(msg));
	}

	private broadcast(msg: ServerMessage) {
		for (const c of this.clients)
		{
			this.send(c, msg);
		}
	}

	cleanup(): void
	{
        if (this.tickTimer)
		{
            clearInterval(this.tickTimer);
            this.tickTimer = undefined;
        }
        if (this.broadcastTimer)
		{
            clearInterval(this.broadcastTimer);
            this.broadcastTimer = undefined;
        }
        this.clients.clear();
        this.roles.clear();
        this.log?.info({ roomId: this.roomId }, 'GameSession cleaned up');
    }
}

export const getSessionForRoom = (roomId: string, log?: FastifyBaseLogger) => {
    if (!rooms.has(roomId))
    {
        log?.warn(`Attempt to access non-existent room: ${roomId}`);
        return null;
    }
    return (rooms.get(roomId)!);
}

export const setMatchForRoom = (
	roomId: string,
	players: {left: Player; right: Player},
	metadata?: {
		isTournament?: boolean;
		tournamentId?: string;
		matchId?: string;
	},
	log?: FastifyBaseLogger
) => {
    const session = new GameSession(roomId, log);
	if (!session)
		return null;
	rooms.set(roomId, session);
    session.setPlayers(players, metadata);
    return session;
}

export const cleanupSession = (roomId: string): boolean => {
    const session = rooms.get(roomId);
    if (session) {
        session.cleanup();
        rooms.delete(roomId);
        return true;
    }
    return false;
};



═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/ws/messageTypes.ts
═══════════════════════════════════════════════════════
export type ClientMessage =
	| {type: 'input'; up: boolean; down: boolean }
	| {type: 'pause'}
	| {type: 'resume'}
	| {type: 'ping'; t: number}
	| {type: 'smash'}
	| {type: 'logIn'; id: string};

export type ServerMessage = 
	| {type: 'welcome'; side: 'left' | 'right' | 'spectator'; isTournament?: boolean; tournamentId?: string}
	| {type: 'state'; state: PublicState; serverTime: number}
	| {type: 'countdown'; value: number}
	| {type: 'paused'}
	| {type: 'resumed'}
    | {type: 'timeout_status'; left: {active: boolean; remainingMs: number};
                               right: {active: boolean; remainingMs: number}}
	| {type: 'gameover'; winner: 'left' | 'right' | 'nobody'; isTournament?: boolean; tournamentId?: string}
	| {type: 'pong'; t: number}
	| {type: 'error'; message: string};

export type PublicState = {
	leftPaddle: {y: number; speed: number; intention: number};
	rightPaddle: {y: number; speed: number; intention: number};
	balls: {x: number; y: number; vx: number, vy: number; radius: number}[];
	score: {left: number; right: number;};
	isPaused: boolean;
	isGameOver: boolean;
    isTimeoutLeft: boolean;
    isTimeoutRight: boolean;
    isTimeoutBoth: boolean;
	winner: '' | 'left' | 'right' | 'nobody';
	countdownValue: number;
	powerUps: {x: number; y: number; radius: number}[];
	splitActive: boolean;
	clock: number;

	smash: {
		cooldown: number;
		animDuration: number;
		left: {cooldownRemaining: number; lastSmashAt: number};
		right: {cooldownRemaining: number; lastSmashAt: number};
	};
};

export function safeParse<T>(raw: string): T | null {
	try 
	{
		return JSON.parse(raw) as T;
	}
	catch
	{
		return (null);
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/game.ts
═══════════════════════════════════════════════════════
import Fastify, { FastifyInstance, FastifyRequest } from 'fastify'
import type { WebSocket } from 'ws'
import { getSessionForRoom } from './session/session'

export const handleGame = (conn: WebSocket, _req: FastifyRequest, fastify: FastifyInstance) : void => {
	fastify.log.info({ url: _req.url, params: _req.params, query: _req.query }, 'WS connect');
    const {roomId} = (_req.params ?? {}) as {roomId?: string};

    const room = getSessionForRoom(roomId || '', fastify.log);
    if (!room)
    {
        fastify.log.warn(`Closing connection to invalid room: ${roomId}`);
        conn.close(1008, 'Room does not exist');
        return;
    }
    room.addClient(conn);
}



═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/world.ts
═══════════════════════════════════════════════════════
import { 
	WORLD_WIDTH, WORLD_HEIGHT, PADDLE_MARGIN, PADDLE_HEIGHT, PADDLE_SPEED,
	PADDLE_SPEED_INCREASE, BALL_INITIAL_SPEED, BALL_SPEED_INCREASE, BALL_MAX_SPEED,
	BALL_RADIUS, SCORE_TO_WIN, PADDLE_MAX_SPEED, SMASH_ANIM_DURATION, SMASH_COOLDOWN,
	SMASH_SPEED_MULTIPLIER, SMASH_TIMING_WINDOW,
	PADDLE_WIDTH} from "./constants";
import type { Ball, GameState, Side } from "./types";
import { clamp } from "./helpers";
import { bounceOnWalls, checkPaddleCollision, resolveBallBallCollision } from "./physics";
import { activateSplit, endSplit, pruneExpiredPowerUps, scheduleNextPowerUp, spawnPowerUp } from "./powerups";
import type { PublicState } from "../ws/messageTypes";

const newBall = (vx: number, vy: number): Ball => ({
	x: WORLD_WIDTH / 2,
	y: WORLD_HEIGHT / 2,
	vx,
	vy,
	radius: BALL_RADIUS,
	lastPaddleHit: ''
});

export class GameWorld {
	state: GameState;

	constructor() {
		this.state = this._freshState();
	}

	private _freshState(): GameState {
		return {
			leftPaddle: {speed: PADDLE_SPEED, y: WORLD_HEIGHT / 2, intention: 0},
			rightPaddle: {speed: PADDLE_SPEED, y: WORLD_HEIGHT / 2, intention: 0},
			balls: [newBall(Math.random() < 0.5 ? -BALL_INITIAL_SPEED : BALL_INITIAL_SPEED, 0)],
			score: {left: 0, right: 0},
			isPaused: false,
			isGameOver: false,
            isTimeoutLeft: false,
            isTimeoutRight: false,
            isTimeoutBoth: false,
			winner: '',
			clock: 0,
			countdownValue: 0,
			countdownTimer: 0,
			powerUps: [],
			nextPowerUpAt: 5 + Math.random() * 10,
			splitActive: false,
			splitEndsAt: 0,
			smash : {
				left: {availableAt: 0, lastPressAt: -1e9, lastSmashAt: -1e9},
				right: {availableAt: 0, lastPressAt: -1e9, lastSmashAt: -1e9}
			}
		};
	}

	applyInput(side: 'left' | 'right', intention: -1 | 0 | 1) {
		(side === 'left' ? this.state.leftPaddle : this.state.rightPaddle).intention = intention;
	}

	pressSmash(side: Side)
	{
		const sm = this.state.smash[side];
        if (this.state.clock >= sm.availableAt)
        {
            sm.lastSmashAt = this.state.clock;
            sm.availableAt = this.state.clock + SMASH_COOLDOWN;
            sm.lastPressAt = this.state.clock;
        }
	}

	startCountdown() {
		this.state.countdownValue = 3;
		this.state.countdownTimer = 0;
		this.state.isPaused = true;
	}

	pause() {
		if (this.state.countdownValue === 0)
		{
			this.state.isPaused = true;
		}
	}
	
	resume() {
		if (this.state.countdownValue === 0)
		{
			this.startCountdown();
		}
	}

	restart() {
		this.state = this._freshState();
		this.startCountdown();
	}

	update(dt: number) {
		const s = this.state;

		if (s.countdownValue > 0)
		{
			s.countdownTimer += dt;
			if (s.countdownTimer >= 1)
			{
				s.countdownValue--;
				s.countdownTimer = 0;
				if (s.countdownValue <= 0)
				{
					s.isPaused = false;
				}
			}
			return;
		}
		if (s.isPaused || s.isGameOver)
		{
			return;
		}
		s.clock += dt;

		s.leftPaddle.y = clamp(s.leftPaddle.y + s.leftPaddle.intention * s.leftPaddle.speed * dt,
			PADDLE_HEIGHT / 2, WORLD_HEIGHT - PADDLE_HEIGHT / 2);
		s.rightPaddle.y = clamp(s.rightPaddle.y + s.rightPaddle.intention * s.rightPaddle.speed * dt,
			PADDLE_HEIGHT / 2, WORLD_HEIGHT - PADDLE_HEIGHT / 2);
		
		if (s.clock >= s.nextPowerUpAt)
		{
			spawnPowerUp(s);
			scheduleNextPowerUp(s);
		}

		pruneExpiredPowerUps(s);

		const leftX = PADDLE_MARGIN;
		const rightX = WORLD_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;

		for (let i = s.powerUps.length - 1; i >= 0; i--)
		{
			const pu = s.powerUps[i];
			let picked = false;
			for (const b of s.balls)
			{
				const dx = b.x - pu.x;
				const dy = b.y - pu.y;
				if (Math.hypot(dx, dy) <= b.radius + pu.radius)
				{
					s.powerUps.splice(i, 1);
					activateSplit(s, b);
					picked = true;
					break;
				}
			}
			if (picked)
			{
				continue;
			}
		}

		for (const b of s.balls)
		{
			b.x += b.vx * dt;
			b.y += b.vy * dt;
			bounceOnWalls(b);
			if (b.lastPaddleHit === 'left' && b.x - b.radius > leftX + PADDLE_WIDTH + 2)
			{
				b.lastPaddleHit = '';
			}
			if (b.lastPaddleHit === 'right' && b.x + b.radius < rightX - 2)
			{
				b.lastPaddleHit = '';
			}
			const hitL = checkPaddleCollision(b, leftX, s.leftPaddle.y, true);
			const hitR = checkPaddleCollision(b, rightX, s.rightPaddle.y, false);
			if (hitL || hitR)
			{
				const curr = Math.max(1e-6, Math.hypot(b.vx, b.vy));
				let target = Math.min(curr * BALL_SPEED_INCREASE, BALL_MAX_SPEED);

				const side: Side | '' = hitL ? 'left' : hitR ? 'right' : '';
				if (side)
				{
					const sm = s.smash[side];
					const smashRecent = (s.clock - sm.lastSmashAt) <= SMASH_TIMING_WINDOW;
					if (smashRecent)
					{
						target = Math.min(target * SMASH_SPEED_MULTIPLIER, BALL_MAX_SPEED);
					}
				}

				const norm = Math.max(1e-6, Math.hypot(b.vx, b.vy));
				const k = target / norm;
				b.vx *= k;
				b.vy *= k;
				s.leftPaddle.speed = Math.min(s.leftPaddle.speed * PADDLE_SPEED_INCREASE, PADDLE_MAX_SPEED);
				s.rightPaddle.speed = Math.min(s.rightPaddle.speed * PADDLE_SPEED_INCREASE, PADDLE_MAX_SPEED);
			}
		}
		if (s.balls.length > 1)
		{
			for (let i = 0; i < s.balls.length; i++)
			{
				for (let j = i + 1; j < s.balls.length; j++)
				{
					resolveBallBallCollision(s.balls[i], s.balls[j]);
				}
			}
		}
		if (s.splitActive && s.clock >= s.splitEndsAt)
		{
			endSplit(s);
		}
		const removed: number[] = [];
		for (let i = 0; i < s.balls.length; i++)
		{
			const b = s.balls[i];
			if (b.x + b.radius <= 0)
			{
				s.score.right++;
				removed.push(i);
			}
			else if (b.x - b.radius >= WORLD_WIDTH)
			{
				s.score.left++;
				removed.push(i);
			}
		}
		for (let i = removed.length - 1; i >= 0; i--)
		{
			s.balls.splice(removed[i], 1);
		}
		if (s.score.left >= SCORE_TO_WIN || s.score.right >= SCORE_TO_WIN)
		{
			s.isGameOver = true;
			s.isPaused = true;
			s.winner = s.score.left >= SCORE_TO_WIN ? 'left' : 'right';
			return;
		}
		if (s.balls.length === 0)
		{
			s.balls = [newBall((Math.random() < 0.5 ? -1 : 1) * BALL_INITIAL_SPEED, 0)];
			s.leftPaddle.speed = PADDLE_SPEED;
			s.rightPaddle.speed = PADDLE_SPEED;
			s.splitActive = false;
			s.splitEndsAt = 0;
			scheduleNextPowerUp(s);
		}
	}

	publicState(): PublicState {
		const s = this.state;
		return {
			leftPaddle: {...s.leftPaddle},
			rightPaddle: {...s.rightPaddle},
			balls: s.balls.map(({x, y, vx, vy, radius}) => ({x, y, vx, vy, radius})),
			score: {...s.score},
			isPaused: s.isPaused,
			isGameOver: s.isGameOver,
            isTimeoutLeft: s.isTimeoutLeft,
            isTimeoutRight: s.isTimeoutRight,
            isTimeoutBoth: s.isTimeoutBoth,
			winner: s.winner,
			countdownValue: s.countdownValue,
			powerUps: s.powerUps.map(({x, y, radius}) => ({x, y, radius})),
			splitActive: s.splitActive,
			clock: s.clock,
			smash: {
				cooldown: SMASH_COOLDOWN,
				animDuration: SMASH_ANIM_DURATION,
				left: {
					cooldownRemaining: Math.max(0, s.smash.left.availableAt - s.clock),
					lastSmashAt: s.smash.left.lastSmashAt
				},
				right: {
					cooldownRemaining: Math.max(0, s.smash.right.availableAt - s.clock),
					lastSmashAt: s.smash.right.lastSmashAt
				}
			}
		};
	}
}


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/physics.ts
═══════════════════════════════════════════════════════
import { PADDLE_HEIGHT, PADDLE_WIDTH, MAX_BOUNCE_DEG, WORLD_HEIGHT, BALL_MAX_SPEED } from "./constants";
import { clamp } from "./helpers";
import type { Ball } from "./types";

export const checkPaddleCollision = (
	ball: Ball,
	paddleX: number,
	paddleY: number,
	isLeftPaddle: boolean
): boolean => {
	const paddleName = isLeftPaddle ? 'left' : 'right';
	if (ball.lastPaddleHit === paddleName)
	{
		return false;
	}

	const speedBefore = Math.max(1e-6, Math.hypot(ball.vx, ball.vy));
	const rectLeft = paddleX;
	const rectRight = paddleX + PADDLE_WIDTH;
	const rectTop = paddleY - PADDLE_HEIGHT / 2;
	const rectBottom = paddleY + PADDLE_HEIGHT / 2;

	const cx = clamp(ball.x, rectLeft, rectRight);
	const cy = clamp(ball.y, rectTop, rectBottom);

	let nx = ball.x - cx;
	let ny = ball.y - cy;

	const r = ball.radius;
	const dist2 = nx * nx + ny * ny;
	if (dist2 > r * r) 
	{
		return false;
	}

	let dist = Math.sqrt(dist2);
	if (dist === 0)
	{
		const midX = (rectLeft + rectRight) / 2;
		const midY = (rectTop + rectBottom) / 2;
		const penX = Math.min(Math.abs(ball.x - rectLeft), Math.abs(rectRight - ball.x));
		const penY = Math.min(Math.abs(ball.y - rectTop), Math.abs(rectBottom - ball.y));
		if (penX < penY)
		{
			nx = ball.x < midX ? -1 : 1;
			ny = 0;
		}
		else
		{
			nx = 0;
			ny = ball.y < midY ? -1 : 1;
		}
		dist = 0;
	}
	else
	{
		nx /= dist;
		ny /= dist;
	}

	const penetration = r - dist + 0.01;
	ball.x += nx * penetration;
	ball.y += ny * penetration;

	const MAX_BOUNCE_RAD = (MAX_BOUNCE_DEG * Math.PI) / 180;
	const rel = clamp((ball.y - paddleY) / (PADDLE_HEIGHT / 2), -1, 1);
	const angle = rel * MAX_BOUNCE_RAD;
	const dir = isLeftPaddle ? 1 : -1;
	ball.vx = Math.cos(angle) * speedBefore * dir;
	ball.vy = Math.sin(angle) * speedBefore;
	ball.lastPaddleHit = paddleName;
	return true;
};

export const resolveBallBallCollision = (a: Ball, b: Ball) => {
	const dx = b.x - a.x;
	const dy = b.y - a.y;
	const dist = Math.max(1e-6, Math.hypot(dx, dy));
	const minDist = a.radius + b.radius;
	if (dist >= minDist)
	{
		return;
	}
	const nx = dx / dist;
	const ny = dy / dist;
	const tx = -ny;
	const ty = nx;
	
	const va_n = a.vx * nx + a.vy * ny;
	const va_t = a.vx * tx + a.vy * ty;
	const vb_n = b.vx * nx + b.vy * ny;
	const vb_t = b.vx * tx + b.vy * ty;

	const va_n_after = vb_n; 
	const vb_n_after = va_n;

	a.vx = va_n_after * nx + va_t * tx;
	a.vy = va_n_after * ny + va_t * ty;
	b.vx = vb_n_after * nx + vb_t * tx;
	b.vy = vb_n_after * ny + vb_t * ty;

	const overlap = minDist - dist + 0.5;
	a.x -= nx * overlap * 0.5;
	a.y -= ny * overlap * 0.5;
	b.x += nx * overlap * 0.5;
	b.y += ny * overlap * 0.5;
};

export const bounceOnWalls = (b: Ball) => {
	if (b.y - b.radius <= 0)
	{
		b.y = b.radius;
		b.vy = Math.abs(b.vy);
	}
	else if (b.y + b.radius >= WORLD_HEIGHT)
	{
		b.y = WORLD_HEIGHT - b.radius;
		b.vy = -Math.abs(b.vy);
	}
};


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/types.ts
═══════════════════════════════════════════════════════
export type Side = 'left' | 'right';

export type Ball = {
	x: number;
	y: number;
	vx: number;
	vy: number;
	radius: number;
	lastPaddleHit: '' | 'left' | 'right';
};

export type PowerUp = {
	id: number;
	x: number;
	y: number;
	radius: number;
	expiresAt: number;
};

export type SmashSideState = {
	availableAt: number;
	lastPressAt: number;
	lastSmashAt: number;
};

export type GameState = {
	leftPaddle: {speed: number; y: number; intention: number};
	rightPaddle: {speed: number; y: number; intention: number};
	balls: Ball[];
	score: { left: number; right: number};
	isPaused: boolean;
	isGameOver: boolean;
    isTimeoutLeft: boolean;
    isTimeoutRight: boolean;
    isTimeoutBoth: boolean;
	winner: '' | 'left' | 'right';
	clock: number;
	countdownValue: number;
	countdownTimer: number;
	powerUps: PowerUp[];
	nextPowerUpAt: number;
	splitActive: boolean;
	splitEndsAt: number;

	smash: {
		left: SmashSideState;
		right: SmashSideState;
	}
};


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/powerups.ts
═══════════════════════════════════════════════════════
import { WORLD_WIDTH, WORLD_HEIGHT, POWERUP_MIN_DELAY_SEC,
	POWERUP_EXTRA_RANDOM_SEC, POWERUP_LIFETIME_SEC, SPLIT_DURATION_SEC, 
	POWERUP_RADIUS, MAX_BALLS_ON_FIELD, SPLIT_SPAWN_PER_PICKUP, SPLIT_SPREAD_DEG,
	POWERUP_MAX_ON_SCREEN} from "./constants";
import { length2, scheduleAfter } from "./helpers";
import type { Ball, GameState } from "./types";

let PU_ID = 1;

export const scheduleNextPowerUp = (state: GameState) => {
	state.nextPowerUpAt = scheduleAfter(state.clock, POWERUP_MIN_DELAY_SEC, POWERUP_EXTRA_RANDOM_SEC);
};

export const spawnPowerUp = (state: GameState) => {
	if (state.powerUps.length >= POWERUP_MAX_ON_SCREEN)
	{
		return;
	}
	const margin = 150;
	state.powerUps.push({
		id: PU_ID++,
		x: margin + Math.random() * (WORLD_WIDTH - 2 * margin),
		y: margin + Math.random() * (WORLD_HEIGHT - 2 * margin),
		radius: POWERUP_RADIUS,
		expiresAt: state.clock + POWERUP_LIFETIME_SEC
	});
};

export const pruneExpiredPowerUps = (state: GameState) => {
	state.powerUps = state.powerUps.filter(p => p.expiresAt > state.clock);
}

export const activateSplit = (state: GameState, fromBall?: Ball) => {
	const spreadRad = (SPLIT_SPREAD_DEG * Math.PI) / 180;
	state.splitActive = true;
	state.splitEndsAt = Math.max(state.splitEndsAt, state.clock + SPLIT_DURATION_SEC);
	if (state.balls.length === 0)
	{
		return ;
	}
	const canAdd = Math.max(0, MAX_BALLS_ON_FIELD - state.balls.length);
	const toAdd = Math.min(SPLIT_SPAWN_PER_PICKUP, canAdd);
	if (toAdd <= 0)
	{
		return;
	}
	const src = fromBall ?? state.balls[0];
	const speed = Math.max(1e-6, length2(src.vx, src.vy));
	const base = Math.atan2(src.vy, src.vx);

	const makeAtAngle = (angle : number): Ball => ({
		...src,
		vx: Math.cos(angle) * speed,
		vy: Math.sin(angle) * speed,
		lastPaddleHit: src.lastPaddleHit
	});

	for (let i = 0; i < toAdd; i++)
	{
		const offset = (Math.random() * 2 - 1) * spreadRad;
		state.balls.push(makeAtAngle(base + offset));
	}
};

export const endSplit = (state: GameState) => {
	state.splitActive = false;
	if (state.balls.length > 1)
	{
		let keep = 0;
		let best = -Infinity;
		for (let i = 0; i < state.balls.length; i++)
		{
			const k = Math.abs(state.balls[i].vx);
			if (k > best)
			{
				best = k;
				keep = i;
			}
		}
		state.balls = [state.balls[keep]];
		scheduleNextPowerUp(state);
	}
};


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/helpers.ts
═══════════════════════════════════════════════════════
export const clamp = (v: number, min: number, max: number) =>
	Math.max(min, Math.min(max, v));
export const length2 = (x: number, y: number) => Math.sqrt(x * x + y * y);
export const scheduleAfter = (now: number, min: number, rand: number) =>
	now + min + Math.random() * rand;


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/constants.ts
═══════════════════════════════════════════════════════
export const WORLD_WIDTH = 1920
export const WORLD_HEIGHT = 1080;

export const PADDLE_WIDTH = 15;
export const PADDLE_HEIGHT = 100;
export const PADDLE_MARGIN = 30;
export const PADDLE_SPEED = 400;
export const PADDLE_SPEED_INCREASE = 1.05;
export const PADDLE_MAX_SPEED = 1600;


export const BALL_RADIUS = 15;
export const BALL_INITIAL_SPEED = 600;
export const BALL_SPEED_INCREASE = 1.05;
export const BALL_MAX_SPEED = 1500;
export const MAX_BOUNCE_DEG = 45;

export const SCORE_TO_WIN = 11;

export const POWERUP_RADIUS = 35;
export const POWERUP_MIN_DELAY_SEC = 6;
export const POWERUP_EXTRA_RANDOM_SEC = 6;
export const POWERUP_LIFETIME_SEC = 9;
export const SPLIT_DURATION_SEC = 10;
export const POWERUP_MAX_ON_SCREEN = 5;

export const MAX_BALLS_ON_FIELD = 10;
export const SPLIT_SPAWN_PER_PICKUP = 2;
export const SPLIT_SPREAD_DEG = 20;

export const SMASH_COOLDOWN = 3;
export const SMASH_TIMING_WINDOW = 0.2;
export const SMASH_SPEED_MULTIPLIER = 1.6;
export const SMASH_ANIM_DURATION = 0.12;

export const SERVER_TICK_HZ = 240;
export const SERVER_DT = 1 / SERVER_TICK_HZ;
export const BROADCAST_HZ = 60;
export const TIMEOUT_MS = 30000;


═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/TounamentQuickPlay.ts
═══════════════════════════════════════════════════════
import { FastifyInstance } from 'fastify'
import { RoomManager } from './RoomManager'
import { v4 as uuidv4 } from 'uuid'
import https from 'https'

const isDevelopment = process.env.NODE_ENV === 'development'
const agent = isDevelopment ? new https.Agent({ rejectUnauthorized: false }) : undefined

export function handleTournamentQuickPlay(fastify: FastifyInstance, roomManager: RoomManager)
{
	fastify.post('/tournament-match', async (request, reply) => {
		const { matchId, tournamentId, player1, player2 } = request.body as {
			matchId: string;
			tournamentId: string;
			player1: { id: string; username: string };
			player2: { id: string; username: string };
		};

		if (!matchId || !tournamentId || !player1 || !player2)
		{
			return reply.code(400).send({ error: 'Invalid payload' });
		}

		const roomId = uuidv4();

		console.log(`Creating tournament match: ${player1.username} vs ${player2.username} (roomId: ${roomId})`);

		try
		{
			const host = process.env.VITE_HOST || 'localhost:8443';
			const create_endpoint = process.env.VITE_CREATEGAME_ENDPOINT || '/gameback/create';
			const fetchURL = `https://${host}${create_endpoint}`;

			await fetch(fetchURL, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					roomId,
					player1,
					player2,
					isTournament: true,
					tournamentId,
					matchId
				}),
				// @ts-ignore
				agent
			});

			console.log(`Tournament match created successfully: roomId=${roomId}`);

			return { 
				success: true, 
				roomId,
				matchId 
			};
		}
		catch (err)
		{
			fastify.log.error(err);
			return reply.code(500).send({ error: 'Failed to initialize game' });
		}
	});
}



═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/server.ts
═══════════════════════════════════════════════════════
import Fastify from 'fastify'
import { handleQuickPlay } from './quickplay'
import { handleTournamentQuickPlay } from './TounamentQuickPlay'
import { RoomManager } from './RoomManager'

const fastify = Fastify({
	logger: true
})

export const roomManager = new RoomManager()

fastify.addHook('onRequest', async (request, reply) => {
    console.log('=== REQUÊTE REÇUE ===')
    console.log('URL:', request.url)
    console.log('Method:', request.method)
    console.log('Headers:', JSON.stringify(request.headers, null, 2))
    console.log('====================')
})


fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

handleQuickPlay(fastify, roomManager);
handleTournamentQuickPlay(fastify, roomManager)

fastify.listen({ port: 3030, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/types.ts
═══════════════════════════════════════════════════════
export interface Player
{
	id: string;
	username: string;
	roomId ?: string;
	isReady: boolean;
}

export interface Room
{
	id: string;
	players: Player[];
	status: 'waiting' | 'playing' | 'finished';
	createdAt: Date;
}

export type RoomFinishedPayload =
{
	roomId: string;
	reason: 'score' | 'timeout';
	winner?: Player | null;
	score?: { left: number; right: number };
};



═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/quickplay.ts
═══════════════════════════════════════════════════════
import { FastifyInstance } from 'fastify'
import { RoomManager } from './RoomManager'
import { Player, ClientMessage, ServerMessage } from './types'
import type { RoomFinishedPayload } from './types'
import { v4 as uuidv4 } from 'uuid'
import https from 'https'

const isDevelopment = process.env.NODE_ENV === 'development'
const agent = isDevelopment ? new https.Agent({ rejectUnauthorized: false }) : undefined

export function handleQuickPlay(fastify: FastifyInstance, roomManager: RoomManager)
{
	fastify.post('/join', async (request, reply) => {
		const { username, playerId } = request.body as { username: string; playerId: string };
		
		if (!username || !playerId) {
			return reply.code(400).send({ error: 'Username and playerId required' });
		}

		const player: Player = {
			id: playerId,
			username,
			isReady: false
		};

		const room = roomManager.findOrCreateRoom(player);
		
		if (room.players.length === 2)
		{
			const host = process.env.VITE_HOST;
			const create_endpoint = process.env.VITE_CREATEGAME_ENDPOINT;
			const fetchURL = `https://${host || 'localhost:8443'}${create_endpoint || '/gameback/create'}`;
			
			try
			{
				await fetch(fetchURL, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						roomId: room.id,
						player1: { id: room.players[0].id, username: room.players[0].username },
						player2: { id: room.players[1].id, username: room.players[1].username },
					}),
					agent
				});
				room.status = 'playing';
			}
			catch (err)
			{
				fastify.log.error(err);
				return reply.code(500).send({ error: 'Failed to initialize game' });
			}
		}

		return { success: true, roomId: room.id, status: room.status };
	});

	fastify.get('/status/:roomId', async (request, reply) => {
		const { roomId } = request.params as { roomId: string };
		const room = roomManager.getRoom(roomId);
		
		if (!room)
		{
			return reply.code(404).send({ error: 'Room not found' });
		}

		if (room.status === 'playing')
		{
			const host = process.env.VITE_HOST;
			const game_endpoint = process.env.VITE_GAME_ENDPOINT;
			const baseGameWs = `wss://${host || 'localhost:8443'}${game_endpoint || '/gameback/game'}/${roomId}`;
			
			return {
				success: true,
				status: 'ready',
				roomId,
				gameServerURL: baseGameWs,
				players: room.players.length
			};
		}

		return { 
			success: true,
			status: room.status, 
			players: room.players.length,
			maxPlayers: 2
		};
	});

	fastify.post('/room-finished', (request, reply) => {
		try
		{
			const body = request.body as Partial<RoomFinishedPayload> | undefined;
			if (!body || !body.roomId)
			{
				return reply.code(400).send({ success: false, error: 'Invalid payload' });
			}

			fastify.log.info({
			route: '/room-finished',
			body
			}, 'room-finished received');

			const deleted = roomManager.deleteRoom(body.roomId);
			return reply.send({ success: true, deleted });
		}
		catch (err)
		{
			fastify.log.error(err);
			return reply.code(500).send({ success: false, error: 'Internal server error' });
		}
	})
}



═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/RoomManager.ts
═══════════════════════════════════════════════════════
import type { Room, Player } from "./types";
import { v4 as uuidv4 } from 'uuid'

export class RoomManager
{
	private rooms: Map<string, Room> = new Map();
	private waitingRoom: Room | null = null

	public findOrCreateRoom(player: Player) : Room
	{
		if (this.waitingRoom && this.waitingRoom.players.length === 1)
		{
			this.waitingRoom.players.push(player)
			player.roomId = this.waitingRoom.id

			const completedRoom = this.waitingRoom
			this.waitingRoom = null
			completedRoom.status = 'playing'

			this.rooms.set(completedRoom.id, completedRoom)

			console.log(`Room ${completedRoom.id} is complete with 2 players`)
			return completedRoom
		}

		const newRoom: Room = {
			id: uuidv4(),
			players: [player],
			status: 'waiting',
			createdAt: new Date()
		}

		player.roomId = newRoom.id
		this.rooms.set(newRoom.id, newRoom)
		this.waitingRoom = newRoom

		console.log(`Created new room ${newRoom.id}, waiting for a second player...`)
		return newRoom
	}

	public deleteRoom(roomId: string): boolean
	{
		const room = this.rooms.get(roomId);
		if (!room)
		{
			console.log(`deleteRoom: room ${roomId} not found`);
			if (this.waitingRoom?.id === roomId)
			{
				this.waitingRoom = null;
			}
			return false;
		}

		this.rooms.delete(roomId);

		if (this.waitingRoom?.id === roomId)
		{
			this.waitingRoom = null;
		}

		console.log(`Room ${roomId} deleted (room-finished received)`);
		this.debugRooms();
		return true;
	}

	public getRoom(roomId: string): Room | undefined
	{
		return (this.rooms.get(roomId))
	}

	public removePlayerFromRoom(player: Player): void
	{
		if (!player.roomId) return

		const room = this.rooms.get(player.roomId)
		if (!room) return

		room.players = room.players.filter(p => p.id !== player.id)
		console.log(`Player ${player.username} removed from the room`)

		if (room.players.length === 0 && room.status === 'waiting')
		{
			this.rooms.delete(room.id)
			if (this.waitingRoom?.id === room.id)
			{
				this.waitingRoom = null
			}
			console.log(`Room ${room.id} deleted (empty)`)
		}
		else if (room.players.length === 1)
		{
			const remainingPlayer = room.players[0]

			room.status = 'waiting'
			this.waitingRoom = room
			console.log(`Room ${room.id} waiting for a new player (one disconnected)`)
		}
	}

	public debugRooms(): void
	{
		console.log('=== ÉTAT DES ROOMS ===');
		console.log(`Rooms actives: ${this.rooms.size}`);
		console.log(`Room en attente: ${this.waitingRoom?.id || 'aucune'}`);
		this.rooms.forEach(room => {
			const playerNames = room.players.map(p => p.username).join(', ');
			console.log(`Room ${room.id}:`);
			console.log(`  - Joueurs (${room.players.length}): ${playerNames}`);
			console.log(`  - Status: ${room.status}`);
			console.log(`  - Créée il y a: ${Math.round((Date.now() - room.createdAt.getTime()) / 1000)}s`);
		});
		console.log('=====================');
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/types/index.ts
═══════════════════════════════════════════════════════
export interface Game
{
	id?: number;
	player1_name: string;
	player2_name: string;
	player1_score: number;
	player2_score: number;
	duration: number; // secondes
	status: 'active' | 'finished';
	started_at?: string;
	finished_at?: string | null;
}

export interface CreateGameRequest
{
	player1_name: string;
	player2_name: string;
}

export interface UpdateGameRequest
{
	player1_score?: number;
	player2_score?: number;
	duration?: number;
	status?: 'active' | "finished";
	finished_at?: string;
}

export interface GlobalMessage
{
	id?: number;
	username: string;
	content: string;
	timestamp?: string;
}

export interface GameMessage
{
	id?: number;
	game_id: number;
	username: string;
	content: string;
	timestamp?: string;
}

export interface CreateMessageRequest
{
	username: string;
	content: string;
}

export interface CreateGameMessageRequest extends CreateMessageRequest
{
	game_id: number;
}

export interface ApiResponse<T>
{
	success: boolean;
	data?: T;
	error?: string;
}

export interface PaginatedResponse<T>
{
	success: boolean;
	data: T[];
	pagination: {
		total: number;
		page: number;
		limit: number;
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/database/connection.ts
═══════════════════════════════════════════════════════
import * as sqlite3 from 'sqlite3';
import * as path from 'path';
import * as fs from 'fs';
import { rejects } from 'assert';

interface DatabaseInterface {
	connect(): Promise<void>;
	init(): Promise<void>;
	getDb(): sqlite3.Database;
}

class Database implements DatabaseInterface
{
	private db: sqlite3.Database | null = null;

	async connect(): Promise<void> 
	{
		const dbPath = path.join(__dirname, '../../data/transcendence.db');

		const dataDir = path.dirname(dbPath)
		if (!fs.existsSync(dataDir))
		{
			fs.mkdirSync(dataDir, {recursive: true})
		}

		return new Promise((resolve, reject) => {
			this.db = new sqlite3.Database(dbPath, (err: Error | null) => {
				if (err)
				{
					reject(err);
				}
				else
				{
					console.log('Connected to SQlite db');
					resolve();
				}
			})
		})
	}

	async init(): Promise<void>
	{
		if (!this.db)
		{
			throw new Error('Db not connected.');
		}

		const schemaPath = path.join(__dirname, 'schema.sql')
		const schema = fs.readFileSync(schemaPath, 'utf8')

		return new Promise((resolve, reject) => {
			this.db!.exec(schema, (err: Error | null) => {
				if (err)
				{
					reject(err)
				}
				else
				{
					console.log('Db schema initialized')
					resolve()
				}
			})
		})
	}

	getDb(): sqlite3.Database {
		if (!this.db)
		{
			throw new Error('Db not connected.');
		}
		return this.db
	}
}

export default new Database;



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/server.ts
═══════════════════════════════════════════════════════
import Fastify, { FastifyInstance } from 'fastify'
import cors from '@fastify/cors'
import database from './database/connection'

const fastify: FastifyInstance = Fastify({
	logger: true
})

fastify.register(cors, {
	origin: true,
	credentials: true
})

declare module 'fastify'
{
	interface FastifyInstance
	{
		db: import('sqlite3').Database
	}
}

fastify.register(require('./routes/games'), { prefix: '/api/games' })
fastify.register(require('./routes/messages'), { prefix: '/api/messages' })

fastify.get('/health', async (request, reply) => {
	return {
		status: 'ok',
		timestamp: new Date().toISOString(),
		service: 'database'
	}
})

fastify.setErrorHandler((error, request, reply) => {
	fastify.log.error(error)
	reply.status(500).send({
		success: false,
		error: 'Internal server error'
	})
})

const start = async (): Promise<void> => {
	try
	{
		await database.connect()
		await database.init()

		// Adding db to fastify instance
		fastify.decorate('db', database.getDb())

		await fastify.listen({
			port: 3020,
			host: '0.0.0.0'
		})
		console.log('Database API service running on port 3020')
	}
	catch (err)
	{
		fastify.log.error(err)
		process.exit(1)
	}
}

process.on('SIGINT', async () => {
	console.log('Shutting down database API service...')
	await fastify.close()
	process.exit()
})

start()



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/routes/messages.ts
═══════════════════════════════════════════════════════
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { 
  GlobalMessage, 
  GameMessage, 
  CreateMessageRequest,
  CreateGameMessageRequest,
  ApiResponse 
} from '../types';

async function messagesRoutes(fastify: FastifyInstance) {

  // GET /api/messages/global => Recuperer les messages global
	fastify.get('/global', async (request: FastifyRequest<{ 
		Querystring: { limit?: string } 
	}>, reply: FastifyReply) => {
		const limit = parseInt(request.query.limit || '50');
		
		return new Promise<ApiResponse<GlobalMessage[]>>((resolve, reject) => {
		const query = 'SELECT * FROM global_messages ORDER BY timestamp DESC LIMIT ?';
		
		fastify.db.all(query, [limit], (err, rows: GlobalMessage[]) => {
			if (err)
			{
				fastify.log.error(err);
				reply.status(500);
				resolve({ success: false, error: 'Database error' });
			}
			else
			{
				resolve({ success: true, data: rows.reverse() });
			}
		});
		});
	});

	// POST /api/messages/global => Poster un message global
	fastify.post('/global', async (request: FastifyRequest<{ 
		Body: CreateMessageRequest 
	}>, reply: FastifyReply) => {
		const { username, content } = request.body;
		
		return new Promise<ApiResponse<GlobalMessage>>((resolve, reject) => {
		const query = 'INSERT INTO global_messages (username, content) VALUES (?, ?)';
		
		fastify.db.run(query, [username, content], function(err) {
			if (err)
			{
				fastify.log.error(err);
				reply.status(500);
				resolve({ success: false, error: 'Failed to create message' });
			}
			else
			{
				const selectQuery = 'SELECT * FROM global_messages WHERE id = ?';
				fastify.db.get(selectQuery, [this.lastID], (err, row: GlobalMessage) => {
					if (err)
					{
						reply.status(500);
						resolve({ success: false, error: 'Message created but failed to retrieve' });
					}
					else
					{
						reply.status(201);
						resolve({ success: true, data: row });
					}
				});
			}
		});
		});
	});

	// GET /api/messages/game/:gameId => Recup les messages d'une partie
	fastify.get('/game/:gameId', async (request: FastifyRequest<{ 
		Params: { gameId: string } 
	}>, reply: FastifyReply) => {
		const { gameId } = request.params;
		
		return new Promise<ApiResponse<GameMessage[]>>((resolve, reject) => {
			const gameQuery = 'SELECT finished_at FROM games WHERE id = ? AND status = "finished"';
			
			fastify.db.get(gameQuery, [gameId], (err, game: { finished_at?: string }) => {
				if (err)
				{
					fastify.log.error(err);
					reply.status(500);
					resolve({ success: false, error: 'Database error' });
					return;
				}
				
				if (game?.finished_at)
				{
					const finishedTime = new Date(game.finished_at).getTime();
					const now = Date.now();
					const tenMinutes = 10 * 60 * 1000;
					
					if (now - finishedTime > tenMinutes)
					{
						resolve({ success: true, data: [] });
						return;
					}
				}
				
				const messagesQuery = 'SELECT * FROM game_messages WHERE game_id = ? ORDER BY timestamp ASC';
				fastify.db.all(messagesQuery, [gameId], (err, rows: GameMessage[]) => {
					if (err)
					{
						fastify.log.error(err);
						reply.status(500);
						resolve({ success: false, error: 'Database error' });
					}
					else
					{
						resolve({ success: true, data: rows });
					}
				});
			});
		});
	});

	// POST /api/messages/game/:gameId - Poster un message dans une partie
	fastify.post('/game/:gameId', async (request: FastifyRequest<{ 
		Params: { gameId: string },
		Body: CreateMessageRequest 
	}>, reply: FastifyReply) => {
		const { gameId } = request.params;
		const { username, content } = request.body;
		
		return new Promise<ApiResponse<GameMessage>>((resolve, reject) => {
			const query = 'INSERT INTO game_messages (game_id, username, content) VALUES (?, ?, ?)';
			
			fastify.db.run(query, [gameId, username, content], function(err) {
				if (err)
				{
					fastify.log.error(err);
					reply.status(500);
					resolve({ success: false, error: 'Failed to create message' });
				}
				else
				{
					const selectQuery = 'SELECT * FROM game_messages WHERE id = ?';
					fastify.db.get(selectQuery, [this.lastID], (err, row: GameMessage) => {
						if (err)
						{
							reply.status(500);
							resolve({ success: false, error: 'Message created but failed to retrieve' });
						}
						else
						{
							reply.status(201);
							resolve({ success: true, data: row });
						}
					});
				}
			});
		});
	});
}

module.exports = messagesRoutes;



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/routes/games.ts
═══════════════════════════════════════════════════════
import {
	FastifyInstance,
	FastifyRequest,
	FastifyReply
} from 'fastify'
import {
	Game,
	CreateGameRequest,
	UpdateGameRequest,
	ApiResponse
} from '../types'

async function gamesRoutes(fastify: FastifyInstance)
{
	interface SqliteRunResult
	{
		lastID: number;
		changes: number;
	}

	// GET /api/games => GET toutes les parties
	fastify.get('/', async (request: FastifyRequest, reply: FastifyReply) => {
		return new Promise<ApiResponse<Game[]>>((resolve, reject) => {
			const query = 'SELECT * FROM games ORDER BY started_at DESC'

			fastify.db.all(query, (err, rows: Game[]) => {
				if (err)
				{
					fastify.log.error(err);
					reply.status(500);
					resolve({ success: false, error: 'Database error' });
				}
				else 
				{
					resolve({ success: true, data: rows });
				}
			})
		})
	})

	// GET /api/games/:id => GET une partie via id
	fastify.get('/:id', async (request: FastifyRequest<{ Params : {id: string} }>,
		reply: FastifyReply) => {
		const { id } = request.params

		return new Promise<ApiResponse<Game>>((resolve, reject) => {
			const query = 'SELECT * FROM games WHERE id = ?'

			fastify.db.get(query, [id], (err, row: Game) => {
				if (err)
				{
					fastify.log.error(err)
					reply.status(500)
					resolve({success: false, error: 'Database error'})
				}
				else if (!row)
				{
					reply.status(404)
					resolve({success: false, error: 'Game not found'})
				}
				else
				{
					resolve({success: true, data: row})
				}
			})
		})
	})

	// POST /api/games => Creer une nouvelle partie
	fastify.post('/', async (request: FastifyRequest<{ Body: CreateGameRequest }>,
		reply: FastifyReply) => {
		const { player1_name, player2_name } = request.body

		return new Promise<ApiResponse<Game>>((resolve, reject) => {
			const query = `
				INSERT INTO games (player1_name, player2_name, player1_score, player2_score, duration, status)
				VALUES (?, ?, 0, 0, 0, 'active')
			`

			fastify.db.run(query, [player1_name, player2_name], function (this: SqliteRunResult, err: Error) {
				if (err)
				{
					fastify.log.error(err)
					reply.status(500)
					resolve({success: false, error: 'Failed to create game'})
				}
				else
				{
					const selectedQuery = 'SELECT * FROM games WHERE id = ?'
					fastify.db.get(selectedQuery, [this.lastID], (err, row: Game) => {
						if (err)
						{
							reply.status(500)
							resolve({success: false, error: 'Game created but failed to retrieve'})
						}
						else
						{
							reply.status(201)
							resolve({success: true, data: row})
						}
					})
				}
			})
		})
	})

	// PUT /api/games/:id => Mettre a jour une partie
	fastify.put('/:id', async (request: FastifyRequest<{
		Params: {id: string}
		Body: UpdateGameRequest
	}>, reply: FastifyReply) => {
		const { id } = request.params
		const updates = request.body

		const fields = Object.keys(updates).map(key => `${key} = ?`).join(', ')
		const values = Object.values(updates)

		if (fields.length === 0)
		{
			reply.status(400)
			return {success: false, error: 'No fields to update'}
		}

		return new Promise<ApiResponse<Game>>((resolve, reject) => {
			const query = `UPDATE games SET ${fields} WHERE id = ?`

			fastify.db.run(query, [...values, id], function(this: SqliteRunResult, err: Error) {
				if (err)
				{
					fastify.log.error(err)
					reply.status(500)
					resolve({success: false, error: 'Failed to update game'})
				}
				else if (this.changes === 0)
				{
					reply.status(404)
					resolve({success: false, error: 'Game not found'})
				}
				else
				{
					const selectQuery = `SELECT * FROM games WHERE id = ?`
					fastify.db.get(selectQuery, [id], (err, row: Game) => {
						if (err)
						{
							reply.status(500)
							resolve({success: false, error: 'Game updated but failed to retrieve'})
						}
						else 
						{
							resolve({success: true, data: row})
						}
					})
				}
			})
		})
	})
}

module.exports = gamesRoutes;



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/vite.config.ts
═══════════════════════════════════════════════════════
import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
	server: {
		host: '0.0.0.0',
		port: 5173,
		allowedHosts: true
	},
	plugins: [
		tailwindcss(),
	],
})



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/simpleAuth/SimpleAuth.ts
═══════════════════════════════════════════════════════
import { v4 as uuidv4 } from 'uuid'

class CookieManager {
    static setCookie(name: string, value: string | null, days: number = 7): void
	{
        const expires = new Date();
        expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Strict`;
    }

    static getCookie(name: string): string | null
	{
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++)
		{
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }

    static deleteCookie(name: string): void
	{
        document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
    }
}

export class SimpleAuth
{
    private static readonly COOKIE_NAME = 'player_session';
    private playerId: string | null;

    constructor()
	{
        this.playerId = this.getOrCreatePlayerId();
    }

    private getOrCreatePlayerId(): string | null
	{
        let playerId = CookieManager.getCookie(SimpleAuth.COOKIE_NAME);
        
        if (!playerId)
		{
            playerId = uuidv4();
            CookieManager.setCookie(SimpleAuth.COOKIE_NAME, playerId, 30);
            console.log('New player ID created:', playerId);
        }
		else
		{
            console.log('Existing player ID found:', playerId);
        }
        
        return playerId;
    }

    getPlayerId(): string | null
	{
        return this.playerId;
    }

    renewSession(): void
	{
        CookieManager.setCookie(SimpleAuth.COOKIE_NAME, this.playerId, 30);
    }

    logout(): void
	{
        CookieManager.deleteCookie(SimpleAuth.COOKIE_NAME);
        this.playerId = uuidv4();
        CookieManager.setCookie(SimpleAuth.COOKIE_NAME, this.playerId, 30);
    }
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/PongGame/PongGame.ts
═══════════════════════════════════════════════════════
import type { Component } from "../types";
import { WSClient, type PublicState } from "../../net/wsClient";
import type { PongGameState, TimeoutStatus } from "./types";
import { PongRenderer } from "./PongRenderer";
import { PongInputHandler } from "./PongInput";
import { PongParticleSystem } from "./PongParticles";
import { PongAssets } from "./PongAssets";
import { WORLD_HEIGHT, PADDLE_HEIGHT } from "./constants";
import { Button } from "../Button";

export class PongGame implements Component {
	private el: HTMLElement;
	private canvas: HTMLCanvasElement;
	private startBtn: HTMLButtonElement;

	private net = new WSClient();
	private renderer: PongRenderer;
	private input: PongInputHandler;
	private particles: PongParticleSystem;
	private assets: PongAssets;

	private state: PublicState = {
		leftPaddle: {y: WORLD_HEIGHT / 2, speed: 0, intention: 0},
		rightPaddle: {y: WORLD_HEIGHT / 2, speed: 0, intention: 0},
		balls: [],
		score: {left: 0, right: 0},
		isPaused: true,
		isGameOver: false,
		winner: '',
		countdownValue: 0,
		powerUps: [],
		splitActive: false,
		clock: 0,
		smash: {
			cooldown: 0,
			animDuration: 0.12,
			left: {cooldownRemaining: 0, lastSmashAt: -1e9},
			right: {cooldownRemaining: 0, lastSmashAt: -1e9}
		}
	};

    private timeoutStatus: TimeoutStatus = {
        leftActive: false,
        leftRemainingMs: 0,
        rightActive: false,
        rightRemainingMs: 0
    };

	private animationFrameId: number | null = null;

	constructor(element: HTMLElement) {
		this.el = element;

		const canvas = this.el.querySelector('#pong-canvas') as HTMLCanvasElement | null;
		const startBtn = this.el.querySelector('#startBtn') as HTMLButtonElement | null;
		if (!canvas || !startBtn)
		{
			throw new Error('PongGame: canvas or button not found in the component.');
		}
		this.canvas = canvas;
		this.startBtn = startBtn;

		this.renderer = new PongRenderer(this.canvas, this.net);
		this.input = new PongInputHandler(this.net);
		this.particles = new PongParticleSystem();
		this.assets = new PongAssets();

		this.setupNetworkHandlers();
		this.setupEventHandlers();
		this.connectToServer();

		this.startAnimationLoop();

	}

	private setupNetworkHandlers(): void {
		this.net.onState = (s: PublicState) => {
			for (const ball of s.balls) {
				this.particles.createTrail(ball.x, ball.y, ball.vx, ball.vy);
			}

			Object.assign(this.state, s);
		};

		this.net.onPaused = () => {
			this.state.isPaused = false;
			this.timeoutStatus = {
				leftActive: false,
				leftRemainingMs: 0,
				rightActive: false,
				rightRemainingMs: 0
			};
		};

		this.net.onTimeoutStatus = (status) => {
			this.timeoutStatus = {
				leftActive: status.left.active,
				leftRemainingMs: status.left.remainingMs,
				rightActive: status.right.active,
				rightRemainingMs: status.right.remainingMs
			};
		};

		this.net.onCountdown = (v: number) => {
			this.state.countdownValue = v;
		};

		this.net.onGameOver = (winner, isTournament, tournamentId) => {
			console.log('Game Over!', {winner, isTournament, tournamentId});
			this.particles.createExplosion(
				this.canvas.width / 2,
				this.canvas.height / 2,
				30
			);
			if (isTournament && tournamentId)
			{
                this.handleTournamentGameOver(winner, tournamentId);
            }
			else
			{
                this.startBtn.textContent = 'Replay';
            }
		};
	}

	private handleTournamentGameOver(winner: 'left' | 'right', tournamentId: string) {
        const amILeft = this.net.side === 'left';
        const didIWin = (amILeft && winner === 'left') || (!amILeft && winner === 'right');

        this.state.isGameOver = true;
        this.state.winner = winner;

        const message = didIWin 
            ? 'Victoire ! Redirection vers les brackets...' 
            : 'Défaite... Redirection vers les brackets...';
        
        console.log(message);

        setTimeout(() => {
			sessionStorage.removeItem('gameWsURL');
            window.location.href = `/tournament/${tournamentId}`;
        }, 3000);
    }

	private setupEventHandlers(): void {
		this.startBtn.addEventListener('click', this.handleStartClick);
		window.addEventListener('resize', this.handleResize);
		window.addEventListener('pong:togglePause', this.handleTogglePause);

		this.input.attach();
	}

	private connectToServer(): void {
		const storedUrl = sessionStorage.getItem('gameWsURL');
		if (storedUrl) 
		{
			this.net.connect(storedUrl);
		} 
		else 
		{
			const host = import.meta.env.VITE_HOST;
			const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
			const roomId = window.location.pathname.split('/').pop();
			const fallback =
				host && endpoint && roomId ? `wss://${host}${endpoint}/${roomId}` : undefined;
			this.net.connect(fallback);
		}
	}

	private handleStartClick = (): void => {
		this.net.resume();
	};

	private handleResize = (): void => {
		this.renderer.setupCanvas();
	};

	private handleTogglePause = (): void => {
		if (this.state.isPaused) 
		{
			this.net.resume();
		} 
		else 
		{
			this.net.pause();
		}
	};

	private smashOffsetX = (side: 'left' | 'right'): number => {
		const smash = this.state.smash;
		if (!smash) 
		{
			return 0;
		}

		const last = side === 'left' ? smash.left.lastSmashAt : smash.right.lastSmashAt;
		const dur = smash.animDuration;
		const dt = Math.max(0, this.state.clock - last);

		if (dt <= 0 || dt > dur) 
		{
			return 0;
		}

		const t = dt / dur;
		const amp = 24;
		const dir = side === 'left' ? 1 : -1;

		return (dir * amp * Math.sin(Math.PI * t));
	};

	private startAnimationLoop(): void {
		const animate = (): void => {
			this.particles.update();
			this.renderer.render(
				this.state,
				this.timeoutStatus,
				this.particles,
				this.net.side,
				this.smashOffsetX
			);
			this.animationFrameId = requestAnimationFrame(animate);
		};
		animate();
	}

	cleanup(): void {
		if (this.animationFrameId !== null) 
		{
			cancelAnimationFrame(this.animationFrameId);
			this.animationFrameId = null;
		}

		this.startBtn.removeEventListener('click', this.handleStartClick);
		window.removeEventListener('resize', this.handleResize);
		window.removeEventListener('pong:togglePause', this.handleTogglePause);

		this.input.detach();
		this.particles.clear();
	}
}

export function Pong(): string {
	
	return `
		<div class="container ml-auto mr-auto flex flex-col items-center" data-component="pong-game">
			<canvas id="pong-canvas"></canvas>
			${Button({
				children: 'Start',
				variant: 'danger',
				size: 'lg',
				className: 'font-bold',
				id: 'startBtn'
			})}
		</div>
	`;
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/PongGame/PongParticles.ts
═══════════════════════════════════════════════════════
import type { Particle } from "./types";
import { TRAIL_THRESHOLD, BALL_MAX_SPEED } from "./constants";

export class PongParticleSystem {
	private particles: Particle[] = [];

	addParticle(particle: Particle): void {
		this.particles.push(particle);
	}

	createExplosion(x: number, y: number, count: number = 10): void {
		for (let i = 0; i < count; i++)
		{
			const angle = (Math.PI * 2 * i) / count;
			const speed = 2 + Math.random() * 3;
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * speed,
				vy: Math.sin(angle) * speed,
				life: 1,
				size: 3 + Math.random() * 3,
				color: '#FFFFFF'
			});
		}
	}

	createTrail(x: number, y: number, vx: number, vy: number): void {
		const speed = Math.hypot(vx, vy);
		if (speed < TRAIL_THRESHOLD)
		{
			return;
		}
		const nx = -vx / speed;
		const ny = -vy / speed;

		this.particles.push({
			x: x + nx * 10,
			y: y + ny * 10,
			vx: 0,
			vy: 0,
			life: 0.5,
			size: 8 + (speed / 1500) * 7,
			color: `rgba(255, 255, 255, ${0.3 + (speed / BALL_MAX_SPEED) * 0.4})`
		});
	}

	update(dt: number = 0.016): void {
		for (let i = this.particles.length - 1; i >= 0; i--)
		{
			const p = this.particles[i];
			p.x += p.vx;
			p.y += p.vy;
			p.life -= dt * 2;

			if (p.life <= 0)
			{
				this.particles.splice(i, 1);
			}
		}
	}

	render(ctx: CanvasRenderingContext2D): void {
		for (const p of this.particles)
		{
			ctx.globalAlpha = p.life;
			ctx.fillStyle = p.color;
			ctx.beginPath();
			ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
			ctx.fill();
		}
		ctx.globalAlpha = 1;
	}

	clear(): void {
		this.particles = [];
	}

	getParticles(): Particle[] {
		return (this.particles);
	}
}


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/PongGame/PongInput.ts
═══════════════════════════════════════════════════════
import type { WSClient } from "../../net/wsClient";

export class PongInputHandler {
	private keys = {w: false, s: false, up: false, down: false};
	private net: WSClient;

	constructor(net: WSClient) {
		this.net = net;
	}

	private onKeyDown = (e: KeyboardEvent): void => {
		switch (e.key) {
			case 'w':
			case 'W':
				this.keys.w = true;
				break;
			case 's':
			case 'S':
				this.keys.s = true;
				break;
			case 'ArrowUp':
				this.keys.up = true;
				e.preventDefault();
				break;
			case 'ArrowDown':
				this.keys.down = true;
				e.preventDefault();
				break;
			case ' ':
				this.net.smash();
				e.preventDefault();
				return;
			case 'p':
			case 'P':
			case 'Escape':
				this.handlePause();
				e.preventDefault();
				return;
		}
		this.sendIntent();
	};

	private onKeyUp = (e: KeyboardEvent): void => {
		switch (e.key) {
			case 'w':
			case 'W':
				this.keys.w = false;
				break;
			case 's':
			case 'S':
				this.keys.s = false;
				break;
			case 'ArrowUp':
				this.keys.up = false;
				break;
			case 'ArrowDown':
				this.keys.down = false;
				break;
		}
		this.sendIntent();
	};

	private sendIntent(): void {
		const up = this.keys.w || this.keys.up;
		const down = this.keys.s || this.keys.down;
		this.net.sendInput(!!up, !!down);
	}

	private handlePause(): void {
		window.dispatchEvent(new CustomEvent('pong:togglePause'));
	}

	attach(): void {
		window.addEventListener('keydown', this.onKeyDown);
		window.addEventListener('keyup', this.onKeyUp);
	}

	detach(): void {
		window.removeEventListener('keydown', this.onKeyDown);
		window.removeEventListener('keyup', this.onKeyUp);
	}

	getKeys() {
		return ({ ...this.keys});
	}
}


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/PongGame/types.ts
═══════════════════════════════════════════════════════
import type { PublicState } from "../../net/wsClient";

export interface PongGameState extends PublicState {
	// si jamais
}

export interface Particle {
	x: number;
	y: number;
	vx: number;
	vy: number;
	life: number;
	size: number;
	color: string;
}

export interface Ball {
	x: number;
	y: number;
	vx: number;
	vy: number;
	radius: number;
}

export interface TimeoutStatus {
	leftActive: boolean;
	leftRemainingMs: number;
	rightActive: boolean;
	rightRemainingMs: number;
}


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/PongGame/PongAssets.ts
═══════════════════════════════════════════════════════
export class PongAssets {
	private images: Map<string, HTMLImageElement> = new Map();
	private loaded = false;

	async loadAll(): Promise<void> {
		this.loaded = true;
	}

	getImage(key: string): HTMLImageElement | undefined {
		return (this.images.get(key));
	}

	isLoaded(): boolean {
		return (this.loaded);
	}
}


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/PongGame/constants.ts
═══════════════════════════════════════════════════════
export const WORLD_WIDTH = 1920;
export const WORLD_HEIGHT = 1080;
export const PADDLE_WIDTH = 15;
export const PADDLE_HEIGHT = 100;
export const PADDLE_MARGIN = 30;

export const COLORS = {
	background: '#000000',
	paddle: '#FFFFFF',
	ball: '#FFFFFF',
	ballTrail: 'rgba(255, 255, 255, 0.5)',
	powerUp: '#FFD700',
	net: '#FFFFFF',
	text: '#FFFFFF'
};

export const BALL_MAX_SPEED = 1500;
export const TRAIL_THRESHOLD = 1400;


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/PongGame/PongRenderer.ts
═══════════════════════════════════════════════════════
import type { PongGameState, TimeoutStatus } from "./types";
import type { PongParticleSystem } from "./PongParticles";
import { WORLD_WIDTH, WORLD_HEIGHT, PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_MARGIN,
COLORS, BALL_MAX_SPEED, TRAIL_THRESHOLD } from "./constants";
import type { WSClient } from "../../net/wsClient";

export class PongRenderer {
	private ctx: CanvasRenderingContext2D;
	private canvas: HTMLCanvasElement;
	private net

	constructor(canvas: HTMLCanvasElement, net: WSClient) {
		this.net = net;
		this.canvas = canvas;
		const ctx = canvas.getContext('2d');
		if (!ctx) {
			throw new Error('PongRenderer: 2D context not found');
		}
		this.ctx = ctx;
		this.setupCanvas();
	}

	setupCanvas(): void {
		const container = this.canvas.parentElement;
		if (!container)
		{
			return;
		}

		const W = WORLD_WIDTH;
		const H = WORLD_HEIGHT;
		const containerWidth = container.clientWidth * 0.9;
		const containerHeight = window.innerHeight * 0.8;
		const scaleX = containerWidth / W;
		const scaleY = containerHeight / H;
		const scale = Math.min(scaleX, scaleY);
		const displayWidth = Math.floor(W * scale);
		const displayHeight = Math.floor(H * scale);
		const dpr = window.devicePixelRatio || 1;

		this.canvas.width = W * dpr;
		this.canvas.height = H * dpr;
		this.ctx.resetTransform();
		this.ctx.scale(dpr, dpr);

		this.canvas.style.width = displayWidth + 'px';
		this.canvas.style.height = displayHeight + 'px';
		this.canvas.style.display = 'block';
		this.canvas.style.margin = '20px auto';
		this.canvas.style.border = '2px solid #333';
		this.canvas.style.boxShadow = '0 4px 20px rgba(0, 0, 0, 0.5)';

		this.ctx.imageSmoothingEnabled = true;
	}

	render(state: PongGameState, timeoutStatus: TimeoutStatus, particles: PongParticleSystem, side: 'left' | 'right' | 'spectator', smashOffsetX: (side: 'left' | 'right') => number): void {
		const ctx = this.ctx;
		const W = WORLD_WIDTH;
		const H = WORLD_HEIGHT;

		ctx.fillStyle = COLORS.background;
		ctx.fillRect(0, 0, W, H);

		ctx.strokeStyle = COLORS.net;
		ctx.setLineDash([10, 10]);
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(W / 2, 0);
		ctx.lineTo(W / 2, H);
		ctx.stroke();
		ctx.setLineDash([]);

		const leftX = PADDLE_MARGIN + smashOffsetX('left');
		const rightX = W - PADDLE_MARGIN - PADDLE_WIDTH + smashOffsetX('right');

		ctx.fillStyle = COLORS.paddle;
		ctx.fillRect(
			leftX,
			state.leftPaddle.y - PADDLE_HEIGHT / 2,
			PADDLE_WIDTH,
			PADDLE_HEIGHT
		);
		ctx.fillRect(
			rightX,
			state.rightPaddle.y - PADDLE_HEIGHT / 2,
			PADDLE_WIDTH,
			PADDLE_HEIGHT
		);

		for (const powerUp of state.powerUps) 
		{
			this.drawPowerUp(ctx, powerUp.x, powerUp.y, powerUp.radius, state.clock);
		}

		particles.render(ctx);

		for (const b of state.balls) 
		{
			const speed = Math.hypot(b.vx, b.vy);
			
			if (speed >= TRAIL_THRESHOLD) 
			{
				this.drawBallTrail(ctx, b, speed);
			}

			ctx.fillStyle = COLORS.ball;
			ctx.beginPath();
			ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
			ctx.fill();

			if (speed >= BALL_MAX_SPEED * 0.9) 
			{
				ctx.shadowBlur = 20;
				ctx.shadowColor = COLORS.ball;
				ctx.beginPath();
				ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
				ctx.fill();
				ctx.shadowBlur = 0;
			}
		}

		ctx.fillStyle = COLORS.text;
		ctx.font = '48px monospace';
		ctx.textAlign = 'center';
		ctx.fillText(String(state.score.left), W / 2 - 100, 60);
		ctx.fillText(String(state.score.right), W / 2 + 100, 60);

		if ((side === 'left' || side === 'right') && state.smash) 
		{
			const smash = state.smash;
			const mine = side === 'left' ? smash.left : smash.right;
			const progress =
				mine.cooldownRemaining > 0
					? Math.max(0, Math.min(1, 1 - mine.cooldownRemaining / smash.cooldown))
					: 1;

			this.drawCooldownDonut(ctx, 60, 60, 28, 10, progress);

			ctx.fillStyle = COLORS.text;
			ctx.font = '16px monospace';
			ctx.textAlign = 'left';
			if (mine.cooldownRemaining > 0) 
			{
				ctx.fillText(mine.cooldownRemaining.toFixed(1) + 's', 95, 66);
			}
			ctx.textAlign = 'center';
		}

		this.renderOverlays(ctx, state, timeoutStatus, side, W, H);
	}

	private drawBallTrail(ctx: CanvasRenderingContext2D, ball: { x: number; y: number; vx: number; vy: number; radius: number }, speed: number): void {
		const trailLength = Math.min(8, Math.floor((speed / BALL_MAX_SPEED) * 10));
		const direction = Math.atan2(ball.vy, ball.vx);

		for (let i = 1; i <= trailLength; i++) 
		{
			const distance = i * 12;
			const trailX = ball.x - Math.cos(direction) * distance;
			const trailY = ball.y - Math.sin(direction) * distance;
			const alpha = 1 - i / trailLength;
			const size = ball.radius * (1 - i / trailLength * 0.5);

			ctx.globalAlpha = alpha * 0.6;
			ctx.fillStyle = COLORS.ballTrail;
			ctx.beginPath();
			ctx.arc(trailX, trailY, size, 0, Math.PI * 2);
			ctx.fill();
		}
		ctx.globalAlpha = 1;
	}

	private drawPowerUp(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, time: number): void {
		const pulse = Math.sin(time * 4) * 2;
		ctx.beginPath();
		ctx.fillStyle = COLORS.powerUp;
		ctx.arc(x, y, radius + pulse, 0, Math.PI * 2);
		ctx.fill();
		ctx.strokeStyle = '#333';
		ctx.lineWidth = 3;
		ctx.stroke();

		const oscillation = Math.sin(time * 3) * 3;
		const iconRadius = radius * 0.25;
		const baseOffset = radius * 0.3;

		ctx.beginPath();
		ctx.fillStyle = '#FFF';
		ctx.arc(x - baseOffset - oscillation, y, iconRadius, 0, Math.PI * 2);
		ctx.fill();
		ctx.strokeStyle = '#333';
		ctx.lineWidth = 2;
		ctx.stroke();

		ctx.beginPath();
		ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
		ctx.arc(x + baseOffset + oscillation, y, iconRadius, 0, Math.PI * 2);
		ctx.fill();
		ctx.strokeStyle = 'rgba(51, 51, 51, 0.8)';
		ctx.lineWidth = 2;
		ctx.stroke();
	}

	private drawCooldownDonut(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, thickness: number, progress: number): void {
		const start = -Math.PI / 2;
		const end = start + progress * Math.PI * 2;

		ctx.strokeStyle = '#444';
		ctx.lineWidth = thickness;
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2);
		ctx.stroke();

		if (progress > 0) 
		{
			ctx.strokeStyle = progress >= 1 ? '#00e676' : '#ffcc00';
			ctx.lineWidth = thickness;
			ctx.beginPath();
			ctx.arc(x, y, r, start, end);
			ctx.stroke();
		}
	}

	private renderOverlays(ctx: CanvasRenderingContext2D, state: PongGameState, timeoutStatus: TimeoutStatus, side: 'left' | 'right' | 'spectator', W: number, H: number): void {
		if (state.countdownValue > 0) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			ctx.fillStyle = '#fff';
			ctx.font = '120px monospace';
			ctx.textAlign = 'center';
			ctx.fillText(String(state.countdownValue), W / 2, H / 2);
		} 
		else if (state.isGameOver) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			if (this.net.isTournament) {
				const amILeft = this.net.side === 'left';
				const didIWin = (amILeft && state.winner === 'left') || 
							(!amILeft && state.winner === 'right');
				
				ctx.fillStyle = didIWin ? '#00ff00' : '#ff0000';
				ctx.font = '72px monospace';
				ctx.fillText(didIWin ? 'VICTOIRE !' : 'DÉFAITE', W / 2, H / 2 - 40);
				
				ctx.fillStyle = '#fff';
				ctx.font = '36px monospace';
				ctx.fillText(`${state.winner} wins`, W / 2, H / 2 + 10);
				
				ctx.font = '24px monospace';
				ctx.fillText('Redirection vers les brackets...', W / 2, H / 2 + 60);
			} else {
				// Affichage normal pour une partie classique
				ctx.fillStyle = '#fff';
				ctx.font = '72px monospace';
				ctx.fillText('GAME OVER', W / 2, H / 2 - 40);
				ctx.font = '36px monospace';
				ctx.fillText(`${state.winner} wins`, W / 2, H / 2 + 10);
				ctx.font = '24px monospace';
				ctx.fillText('Click "Replay" to restart', W / 2, H / 2 + 60);
			}
		} 
		else if (state.isPaused) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);

			const iAmLeft = side === 'left';
			const opponentDisconnected = iAmLeft
				? timeoutStatus.rightActive
				: timeoutStatus.leftActive;
			const opponentRemainingMs = iAmLeft
				? timeoutStatus.rightRemainingMs
				: timeoutStatus.leftRemainingMs;

			if (opponentDisconnected && opponentRemainingMs > 0) 
			{
				const secondsRemaining = Math.ceil(opponentRemainingMs / 1000);
				ctx.font = '36px monospace';
				ctx.fillStyle = '#ff6b6b';
				ctx.textAlign = 'center';
				ctx.fillText('⚠️ Adversaire déconnecté', W / 2, H / 2 + 20);

				ctx.font = '48px monospace';
				ctx.fillStyle = '#fff';
				ctx.fillText(`Forfeit dans: ${secondsRemaining}s`, W / 2, H / 2 + 80);

				const barWidth = 400;
				const barHeight = 10;
				const barX = (W - barWidth) / 2;
				const barY = H / 2 + 120;
				const progress = opponentRemainingMs / 30000;

				ctx.fillStyle = 'rgba(255,255,255,0.2)';
				ctx.fillRect(barX, barY, barWidth, barHeight);

				ctx.fillStyle = progress > 0.3 ? '#4CAF50' : '#ff6b6b';
				ctx.fillRect(barX, barY, barWidth * progress, barHeight);
			} 
			else 
			{
				ctx.fillStyle = '#fff';
				ctx.font = '72px monospace';
				ctx.textAlign = 'center';
				ctx.fillText('PAUSED', W / 2, H / 2);
				ctx.font = '24px monospace';
				ctx.fillText('Press P, SPACE or ESC to resume', W / 2, H / 2 + 60);
			}
		}
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/VolumeControl.ts
═══════════════════════════════════════════════════════
import { gsap } from "gsap";

interface VolumeControlProps {
    initialVolume?: number;
    className?: string;
}

export function VolumeControl({ 
    initialVolume = 50,
    className = '' 
}: VolumeControlProps = {}): string {
    // Setup après le rendu
    setTimeout(() => {
        let holdTimer: any = null;
        let chargeLevel = 0;
        const speaker = document.getElementById('volume-speaker');
        const volumeTrack = document.getElementById('volume-track');
        const volumeBall = document.getElementById('volume-ball');
        
        if (!speaker || !volumeTrack || !volumeBall) {
            console.log('Volume control elements not found');
            return;
        }

        // Position initiale
        const initialPos = (initialVolume / 100) * volumeTrack.offsetWidth;
        gsap.set(volumeBall, { x: initialPos });
        
        // Mouse down - commence à charger ET reset la boule
        speaker.addEventListener('mousedown', () => {
            chargeLevel = 0;
            
            // Reset la position de la boule au début
            gsap.set(volumeBall, { 
                x: 0,
                y: 0,
                scale: 1
            });
            
            holdTimer = setInterval(() => {
                chargeLevel = Math.min(100, chargeLevel + 2);
                
                // Vibration du speaker
                gsap.to(speaker, {
                    scale: 1 + (chargeLevel / 200),
                    duration: 0.1
                });
            }, 20);
        });

        // Mouse up - lance la boule avec physique réaliste
        speaker.addEventListener('mouseup', () => {
            if (holdTimer) {
                clearInterval(holdTimer);
                
                // Position finale basée sur la charge
                const finalPosition = (chargeLevel / 100) * volumeTrack.offsetWidth;
                const jumpHeight = 20 + (chargeLevel / 4);
                
                // Mouvement horizontal linéaire
                gsap.fromTo(volumeBall,
                    { x: 0 },
                    { 
                        x: finalPosition,
                        duration: 0.6,
                        ease: "none"
                    }
                );
                
                // Mouvement vertical parabolique
                gsap.fromTo(volumeBall,
                    { y: 0 },
                    {
                        y: -jumpHeight,
                        duration: 0.3,
                        ease: "power2.out",
                        yoyo: true,
                        repeat: 1,
                        immediateRender: false
                    }
                );
                
                gsap.to(speaker, {
                    scale: 1,
                    duration: 0.3
                });
                
                chargeLevel = 0;
            }
        });

        // Mouse leave - annule la charge
        speaker.addEventListener('mouseleave', () => {
            if (holdTimer) {
                clearInterval(holdTimer);
                holdTimer = null;
                
                gsap.to(speaker, {
                    scale: 1,
                    duration: 0.3
                });
                
                chargeLevel = 0;
            }
        });
    }, 0);

    return `
        <div class="flex items-center gap-3 ${className}">
            <!-- Speaker sans fond -->
            <div 
                id="volume-speaker"
                class="w-8 h-8 flex items-center justify-center cursor-pointer select-none"
            >
                <!-- Icône speaker -->
                <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217z"/>
                </svg>
            </div>

            <!-- Container avec padding pour la trajectoire -->
            <div class="relative flex-1 py-6">
                <!-- Ligne de volume -->
                <div 
                    id="volume-track"
                    class="h-[2px] bg-white/50 rounded-full relative"
                >
                    <!-- Boule -->
                    <div 
                        id="volume-ball"
                        class="absolute top-1/2 -translate-y-1/2 w-3 h-3 bg-white rounded-full"
                        style="left: 0; transform: translateY(-50%);"
                    ></div>
                </div>
            </div>
        </div>
    `;
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/index.ts
═══════════════════════════════════════════════════════
import { ChatComponant } from './Chat';
import { PongGame } from './PongGame/PongGame';
import { ComponentRegistry } from './ComponantManager';
import { JoinTournamentComponent } from './JoinTournament';

export function registerComponents(): void
{
    ComponentRegistry.register('chat', ChatComponant)
    ComponentRegistry.register('pong-game', PongGame)
    ComponentRegistry.register('joinTournament', JoinTournamentComponent)
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/Header.ts
═══════════════════════════════════════════════════════
import type { ComponentProps } from './types';
import { Button } from './Button';

interface HeaderProps extends ComponentProps {
    isLogged?: boolean
}

export function Header({ 
	className = '',
	isLogged = false
}: HeaderProps): string {

	const baseClass = `
		container flex justify-between
		gap-4 py-4 px-8 mt-4 ml-auto mr-auto
		rounded-xl
		bg-orange-600
		${className}
	`.replace(/\s+/g, ' ').trim();
	
	return `
		<header class="${baseClass}">
			<h1 class="text-2xl text-white">Pongers!</h1>
			${isLogged ? 
				Button({
					children: "Profile",
					id: "profileBtn",
					variant: "secondary",
					size: "md",
					href: ""
				})
					:
				Button({
					children: "Login",
					id: "loginBtn",
					variant: "secondary",
					size: "md",
					href: "/login"
				})
			}
		</header>
	`;
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/Button.ts
═══════════════════════════════════════════════════════
import type { ComponentProps } from './types';
import { renderChildren } from './types';

// ============= BUTTON DE BASE =============
interface ButtonProps extends ComponentProps {
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
    size?: 'sm' | 'md' | 'lg';
    href?: string;
}

export function Button({ 
    children, 
    variant = 'primary', 
    size = 'md',
    href,
    className = '',
    id
}: ButtonProps): string {
    const variants = {
        primary: 'bg-blue-500 hover:bg-blue-600 text-white',
        secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-800',
        danger: 'bg-red-500 hover:bg-red-600 text-white',
		default: ''
    };
    
    const sizes = {
        sm: 'px-3 py-1 text-sm',
        md: 'px-4 py-2',
        lg: 'px-6 py-3 text-lg'
    };
    
    const baseClass = `
        ${variants[variant]}
        ${sizes[size]}
        rounded-lg font-medium transition-colors cursor-pointer
		relative block w-fit
        ${className}
    `.replace(/\s+/g, ' ').trim();
    
    const content = renderChildren(children);
    
    if (href) {
        return `<a href="${href}" id=${id} class="${baseClass}">${content}</a>`;
    }
    
    return `<button id=${id} class="${baseClass}">${content}</button>`;
}

// ============= SETTINGS BUTTON =============
interface SettingsButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
}

export function SettingsButton({ 
    className = '', 
    size = 'md' 
}: SettingsButtonProps = {}): string {
    return Button({
        children: "⚙️",
        variant: "default",
        size: size,
        href: "/settings",
        className: className,
        id: "settings-button"
    });
}

// ============= SKIN BUTTON =============
interface SkinButtonProps extends ButtonProps {
    showLabel?: boolean;
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
}

export function SkinButton({ 
    className = '', 
    size = 'md',
    showLabel = true,
    variant = 'default'
}: SkinButtonProps = {}): string {
    const buttonContent = showLabel ? "🎨" : "🎨";
    
    return Button({
        children: buttonContent,
        variant: variant,
        size: size,
        href: "/customization",
        className: className,
        id: "skin-button"
    });
}

// ============= COFFEE BUTTON =============
interface CoffeeButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
    showIcon?: boolean;
}

export function CoffeeButton({ 
    className = '', 
    size = 'md',
    showIcon = true
}: CoffeeButtonProps = {}): string {
    const content = showIcon ? "☕ Buy me a Coffee" : "Buy me a Coffee";
    
    return Button({
        children: content,
        variant: "default",
        size: size,
        href: "/cafe",
        className: `bg-yellow-500 hover:bg-yellow-600 ${className}`,
        id: "coffee-button"
    });
}

// ============= BACK BUTTON =============
interface BackButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
    text?: string;
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
}

export function BackButton({ 
    className = '', 
    size,
    text = "←",
    variant = 'default'
}: BackButtonProps = {}): string {
    return `
        <button 
            onclick="history.back()" 
            class="
                ${variant === 'primary' ? 'bg-blue-500 hover:bg-blue-600 text-white' : ''}
                ${variant === 'secondary' ? 'bg-gray-200 hover:bg-gray-300 text-gray-800' : ''}
                ${variant === 'danger' ? 'bg-red-500 hover:bg-red-600 text-white' : ''}
                ${size === 'sm' ? 'px-3 py-1 text-sm' : ''}
                ${size === 'md' ? 'px-4 py-2' : ''}
                ${size === 'lg' ? 'px-6 py-3 text-lg' : ''}
                rounded-lg font-medium transition-colors cursor-pointer
                relative block w-fit
                ${className}
            "
            id="back-button"
        >
            ${text}
        </button>
    `;
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/Chat.ts
═══════════════════════════════════════════════════════
import type { ComponentProps, Component } from "./types";

interface GlobalChatProps extends ComponentProps
{
	type: 'global' | 'game' | 'private'
}

export class ChatComponant implements Component
{
	private element: HTMLElement
	private ws: WebSocket
	private type: string
	private statusElem: HTMLElement | null
	private chatHistory: HTMLDivElement
	private chatInput: HTMLInputElement

	constructor(element: HTMLElement)
	{
		const host = import.meta.env.VITE_HOST
		const endpoint = import.meta.env.VITE_CHAT_ENDPOINT
		const wsUrl = (host && endpoint) ? `wss://${host}${endpoint}`
					: 'wss://localhost:8443/chatback/ws';

        this.element = element;
        this.type = element.getAttribute('data-chat-type') || 'global';
		this.ws = new WebSocket(wsUrl);
		this.statusElem = element.querySelector('h2');
		this.chatHistory = element.querySelector('.history') as HTMLDivElement
		this.chatInput = element.querySelector('input') as HTMLInputElement
        this.init();
    }

	private sendMessage = (msg: string): void => {
			const trimedMsg = msg.trim();
			if (this.ws && trimedMsg)
			{
				this.ws.send(trimedMsg)
			}
		}


	private handleKeyDown = (e: KeyboardEvent): void => {
		if (e.key === 'Enter' && !e.shiftKey)
		{
			e.preventDefault();
			const msg = this.chatInput.value;
			this.sendMessage(msg);
			this.chatInput.value = ''
		}
	}

	private init(): void
	{		
		console.log("init")
		this.ws.onopen = () => {
			this.ws.send('hi from client');
			this.statusElem!.innerHTML = 'Connecté au chat!';
		};
		
		this.ws.onmessage = (event) => {
			this.chatHistory!.innerHTML += `<p class="p-4 block bg-red-400 text-white rounded-xl w-fit">` + event.data + '</p>';
		};
		
		this.ws.onerror = () => {
			this.statusElem!.innerHTML = 'Erreur de connexion';
		};

		this.chatInput?.addEventListener("keydown", this.handleKeyDown)
    }
    
    cleanup(): void
	{
        this.chatInput.removeEventListener('keydown', this.handleKeyDown)
		if (this.ws && this.ws.readyState === WebSocket.OPEN) {
			this.ws.close();
		}
    }
}

export function Chat({
	className = '',
	type = 'global'
} : GlobalChatProps) {
	const chatClasses = `${className}
	${type == 'global' ? `` : ``}
	`;


	return `
		<div class="${chatClasses}"
			data-component="chat"
			data-chat-type=${type}	
		>
			<h2 class="text-3xl">Connexion en cours...</h2>
			<div class="history mt-4 flex flex-col gap-4"></div>
			<input type="text" id="chatInput" name="chatInput"
				placeholder="Tapez votre message..."
				class="border-2 rounded-md p-4 w-full mt-4" />
		<div>
	`
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/JoinTournament.ts
═══════════════════════════════════════════════════════
import type { ComponentProps, Component } from "./types";

interface JoinTournamentProps extends ComponentProps
{
	slots: number
}

export class JoinTournamentComponent implements Component
{
	private element: HTMLElement
	private slots: string | null

	constructor(element: HTMLElement)
	{

		this.element = element;
		this.slots = element.getAttribute('data-slots')
		this.init();
	}

	private init(): void
	{

	}
	
	cleanup(): void
	{

	}
}

export function JoinTournament({
	className = 'px-32 py-16 border-2 border-red-400 rounded-2xl cursor-pointer',
	slots
} : JoinTournamentProps) {
	const chatClasses = `${className}`

	return `
		<button class="${chatClasses}"
			data-component="joinTournament"
			data-slots=${slots}	
		>
			${slots} Players
			<span></span>
		<button>
	`
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/types.ts
═══════════════════════════════════════════════════════
export interface ComponentProps {
    children?: string | string[];
    className?: string;
    id?: string;
    [key: string]: any;
}

export function renderChildren(children?: string | string[]): string {
    if (!children) return '';
    return Array.isArray(children) ? children.join('') : children;
}

export interface Component
{
    cleanup(): void;
}


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/ComponantManager.ts
═══════════════════════════════════════════════════════
import type { Component } from "./types";

type ComponentConstructor = new (element: HTMLElement) => Component;

export class ComponentRegistry
{
    private static components: Map<string, ComponentConstructor> = new Map();

    static register(name: string, constructor: ComponentConstructor): void
    {
        this.components.set(name, constructor);
    }

    static get(name: string): ComponentConstructor | undefined
    {
        return this.components.get(name);
    }
}

export class ComponentManager
{
    private instances: Map<HTMLElement, Component> = new Map();
    
    scanAndMount(): void
    {
        const components = document.querySelectorAll('[data-component]');
        console.log(components)
        
        components.forEach(element => {
            const componentName = element.getAttribute('data-component');
            if (!componentName) return;
            
            const ComponentClass = ComponentRegistry.get(componentName);
            
            if (ComponentClass && !this.instances.has(element as HTMLElement))
            {
                const instance = new ComponentClass(element as HTMLElement);
                this.instances.set(element as HTMLElement, instance);
            }
        });
    }
    
    cleanupAll(): void
    {
        this.instances.forEach(instance => instance.cleanup());
        this.instances.clear();
    }
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/vite-env.d.ts
═══════════════════════════════════════════════════════
/// <reference types="vite/client" />



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/GameView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { Pong } from "../components/PongGame/PongGame";
import { gsap } from "gsap";
import { BackButton } from "../components/Button";

 export const GameView: ViewFunction = () => {

	// Animation d'entrée
	setTimeout(() => {
		const tl = gsap.timeline();
		
		// Récupérer les positions data-x et data-y
		const stars = document.querySelectorAll('.star-particle');
		stars.forEach((star) => {
			const targetX = parseFloat(star.getAttribute('data-x') || '0');
			const targetY = parseFloat(star.getAttribute('data-y') || '0');
			
			gsap.fromTo(star,
				{ 
					x: 0,
					y: 0,
					scale: 0.1,
					opacity: 1
				},
				{ 
					x: targetX,
					y: targetY,
					scale: 1,
					opacity: 1,
					duration: 4,
					ease: "power2.out"
				}
			);
		});
		
		// Faire disparaître la transition après l'animation
		tl.to("#space-transition", 
			{ 
				opacity: 0,
				duration: 1,
				delay: 2, // Attendre que les étoiles soient parties
				onComplete: () => {
					const transition = document.getElementById('space-transition');
					if (transition) transition.style.display = 'none';
				}
			}
		)
		.fromTo("#game-content", 
			{ opacity: 0, scale: 0.8 },
			{ opacity: 1, scale: 1, duration: 0.5, ease: "back.out" },
			"-=0.5"
		);
	}, 0);
	
	return `
		<div id="space-transition" class="fixed inset-0 z-50 bg-[#04071A] overflow-hidden">
			${Array.from({length: 300}, (_) => {
				const angle = Math.random() * Math.PI * 2;
				const distance = Math.random() * 1500 + 500;
				const x = Math.cos(angle) * distance;
				const y = Math.sin(angle) * distance;
				const size = Math.random() * 4 + 1;
				
				return `
					<div 
						class="star-particle absolute bg-white rounded-full"
						style="
							width: ${size}px;
							height: ${size}px;
							left: 50%;
							top: 50%;
							transform: translate(-50%, -50%);
							box-shadow: 0 0 ${size * 2}px rgba(255, 255, 255, 0.8);
						"
						data-x="${x}"
						data-y="${y}"
					></div>
				`;
			}).join('')}
			
			<!-- Lignes de vitesse -->
			${Array.from({length: 50}, (_) => {
				const angle = Math.random() * Math.PI * 2;
				const length = Math.random() * 200 + 100;
				const distance = Math.random() * 800;
				
				return `
					<div 
						class="absolute bg-gradient-to-r from-transparent via-white to-transparent opacity-30"
						style="
							width: ${length}px;
							height: 1px;
							left: 50%;
							top: 50%;
							transform: translate(-50%, -50%) 
									  rotate(${angle}rad) 
									  translateX(${distance}px);
						"
					></div>
				`;
			}).join('')}
		</div>
		<div id="game-content">
			${BackButton()}
			${Pong()}
		</div>
	`

};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/TournamentView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types"
import { Header } from "../components/Header";
import { JoinTournament } from "../components/JoinTournament";

export const TournamentView: ViewFunction = () => {
    return `
        ${Header({isLogged: false})}
        <div class="relative">
            <div class="mt-16 flex flex-col gap-4 items-center">
                <input type="text" name="username" id="usernameInput" value="Anon"
                    class="px-8 py-4 border-b-cyan-300 border-2 rounded-xl"/>
                ${JoinTournament({slots: 4})}
                ${JoinTournament({slots: 8})}
                ${JoinTournament({slots: 16})}
            </div>
            <div id="countdown" style="display: none;" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 px-8 py-4 text-white bg-gray-950 rounded-xl z-50">
                <h2>Tournament is starting...</h2>
                <div id="countdown-text" class="text-center text-4xl py-4">3</div>
            </div>
        </div>
    `
}

export const tournamentLogic = (): (() => void) => {
    const tournamentBtns = document.querySelectorAll('[data-component="joinTournament"]')
    const usernameInput = document.getElementById("usernameInput") as HTMLInputElement;
    
    let pollInterval: NodeJS.Timeout | null = null;
    let currentTournamentId: string | null = null;

    // Fonction pour récupérer et mettre à jour les tournois
    const fetchTournaments = async () => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/tournamentback/tournaments`);
            const data = await response.json();

            if (data.success) {
                tournamentBtns.forEach(btn => {
                    const span: HTMLSpanElement | null = btn.querySelector("span");
                    const slots = btn.getAttribute('data-slots');
                    
                    data.registrations.forEach((tournament: any) => {
                        if (tournament.name === slots + 'p') {
                            span!.innerText = `${tournament.currentPlayerCount}/${slots}`;
                            btn.setAttribute("data-tournament-id", tournament.id);
                        }
                    });
                });
            }
        } catch (err) {
            console.error('Error fetching tournaments:', err);
        }
    };

    // Polling initial et régulier
    fetchTournaments();
    const updateInterval = setInterval(fetchTournaments, 2000);

    // Fonction pour rejoindre un tournoi
    const handleJoinTournament = async (e: Event) => {
        const username = usernameInput.value;
        const target = e.target as HTMLElement;
        const tournamentId = target?.getAttribute('data-tournament-id');

        if (!tournamentId) {
            console.error('No tournament ID found');
            return;
        }

        currentTournamentId = tournamentId;

        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const playerId = window.simpleAuth.getPlayerId();
            
            const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}/join`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, playerId })
            });

            const data = await response.json();

            if (data.success) {
                if (data.tournamentStarted) {
                    // Le tournoi démarre !
                    startCountdownAndRedirect(data.tournamentId);
                } else {
                    // En attente d'autres joueurs
                    console.log(`Joined tournament: ${data.currentPlayers}/${data.maxPlayers} players`);
                    startPollingForStart(tournamentId);
                }
            } else {
                alert(data.error || 'Failed to join tournament');
            }
        } catch (err) {
            console.error('Error joining tournament:', err);
            alert('Failed to join tournament');
        }
    };

    // Polling pour vérifier si le tournoi a démarré
    const startPollingForStart = (tournamentId: string) => {
        if (pollInterval) return; // Déjà en cours

        pollInterval = setInterval(async () => {
            try {
                const host = import.meta.env.VITE_HOST || 'localhost:8443';
                const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}`);
                const data = await response.json();

                if (data.success && data.tournament.status === 'in_progress') {
                    if (pollInterval) {
                        clearInterval(pollInterval);
                        pollInterval = null;
                    }
                    startCountdownAndRedirect(tournamentId);
                }
            } catch (err) {
                console.error('Error polling tournament status:', err);
            }
        }, 1000); // Check every second
    };

    // Countdown avant redirection
    const startCountdownAndRedirect = (tournamentId: string): void => {
        const countdownModal = document.getElementById('countdown');
        const countdownText = document.getElementById('countdown-text');
        
        if (!countdownModal || !countdownText) return;

        let count = 3;
        countdownModal.style.display = 'block';
        countdownText.textContent = count.toString();

        const countdownInterval = setInterval(() => {
            count--;
            
            if (count > 0) {
                countdownText.textContent = count.toString();
            } else {
                clearInterval(countdownInterval);
                countdownModal.style.display = 'none';
                window.location.href = `/tournament/${tournamentId}`;
            }
        }, 1000);
    };

    // Attacher les event listeners
    tournamentBtns.forEach(tournamentBtn => {
        tournamentBtn.addEventListener("click", handleJoinTournament);
    });

    // Fonction de cleanup
    return (): void => {
        if (updateInterval) {
            clearInterval(updateInterval);
        }
        if (pollInterval) {
            clearInterval(pollInterval);
        }
        tournamentBtns.forEach(tournamentBtn => {
            tournamentBtn.removeEventListener("click", handleJoinTournament);
        });

        // Se désinscrire du tournoi si on quitte la page
        if (currentTournamentId) {
            const playerId = window.simpleAuth.getPlayerId();
            if (playerId) {
                const host = import.meta.env.VITE_HOST || 'localhost:8443';
                fetch(`https://${host}/tournamentback/tournaments/leave/${playerId}`, {
                    method: 'DELETE'
                }).catch(err => console.error('Error leaving tournament:', err));
            }
        }
    };
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/CreateAccountView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { 
	Button,
	BackButton
	 } from "../components/Button";

 export const CreateAccountView: ViewFunction = () => {
	return `
		<!-- Fond étoilé -->
		<div class="fixed inset-0 bg-[#04071A] overflow-hidden">
			<!-- Étoiles -->
			${Array.from({length: 150}, (_, i) => `
			<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			<!-- Étoiles normales -->
			${Array.from({length: 150}, (_, i) => `
				<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			
			<!-- Étoiles qui scintillent fort -->
			${Array.from({length: 50}, (_) => `
				<div 
					class="absolute"
					style="
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
					"
				>
					<div class="w-[4px] h-[4px] bg-white rounded-full"></div>
				</div>
			`).join('')}
			
			<style>
				@keyframes strong-sparkle {
					0%, 100% {
						opacity: 0.3;
						filter: blur(0px);
					}
					50% {
						opacity: 1;
						filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
					}
				}
			</style>
			
			

		<!-- BackButton -->
		<div class="relative z-10 p-8">
			${BackButton()}
		</div>

		<!-- Fenêtre centrale -->
		<div class="fixed inset-0 flex items-center justify-center z-10 px-8">
    		<div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-8 w-full max-w-6xl min-h-[600px] shadow-2xl flex">
				<!-- Côté gauche avec le formulaire -->
				<div class="absolute top-8 left-8">
					${BackButton({
						size: "lg",
						className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
					})}
				</div>
				<div class="w-1/2 border-r border-white/20 p-8 flex items-center justify-center">
					<img 
						src="/sprites/dancing-cat.gif" 
						alt="Animation"
						class="w-full h-full object-contain rounded"
					/>
				</div>
				
				<!-- Côté droit avec le formulaire -->
				<div class="w-1/2 px-8 flex flex-col justify-center items-center">
					<h1 class="text-4xl font-bold mb-4 text-white">Hello !</h1>
					<h2 class="text-2xl font-bold mb-8 text-white/80 text-center">Create your account</h2>

					<form action="/create" method="POST" id="createform">
						<div class="mb-4">
							<label for="username" class="block mb-2 text-white/70">Username:</label>
							<input 
								type="text" 
								id="username" 
								name="username"
								placeholder="Enter username"
								required
								class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
							>
						</div>
						<div class="mb-6">
							<label for="password" class="block mb-2 text-white/70">Password:</label>
							<input 
								type="password" 
								id="password" 
								name="password"
								placeholder="Enter password"
								required
								class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
							>
						</div>
						<div class="mb-6">
							<label for="confirmpassword" class="block mb-2 text-white/70">Confirm your password:</label>
							<input 
								type="confirmpassword" 
								id="confirmpassword" 
								name="confirmpassword"
								placeholder="Confirm your password"
								required
								class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
							>
						</div>
						<button type="submit" class="w-full py-2 mb-4 text-center bg-[#101C69]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20">
							Submit
						</button>


					</form>

					${Button({
						children: "Login",
						variant: "default",
						size: "sm",
						href: "/login",
						className: "w-full text-center text-white/80"
					})} 
				</div>
			</div>
		</div>
	`;
};
	


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/StartGameView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { 
	Button,
	BackButton,
	SettingsButton
		} from "../components/Button";  // Ajoute BackButton
import { gsap } from "gsap";

export const StartGameView: ViewFunction = () => {
    // Animation GSAP après le rendu
    setTimeout(() => {
        // Timeline pour contrôler toute l'animation
        const tl = gsap.timeline();
        
        // Variables pour le contrôle du vaisseau
        let mouseY = window.innerHeight / 2;
        const spaceship = document.getElementById("spaceship");
        
        // 1. Suivre la souris
        document.addEventListener('mousemove', (e) => {
            mouseY = e.clientY;
            
            if (spaceship) {
                // Position relative au centre de l'écran
                const centerY = window.innerHeight / 2;
                const offsetY = mouseY - centerY;
                
                // Limiter le mouvement (max 300px du centre)
                const clampedY = Math.max(-300, Math.min(200, offsetY));
                
                // Animation fluide vers la position de la souris
                gsap.to("#spaceship", {
                    y: clampedY,
                    duration: 0.3,  // Délai pour un mouvement plus smooth
                    ease: "power2.out"
                });
            }
        });
        
        // 2. Fonction pour créer un projectile
        function createProjectile() {
            const spaceship = document.getElementById("spaceship");
            const gameAnimation = document.getElementById("game-animation");
            
            if (!spaceship || !gameAnimation) return;
            
            const rect = spaceship.getBoundingClientRect();
            
            const projectile = document.createElement("div");
            projectile.className = "absolute bg-yellow-400";
            projectile.style.cssText = `
                width: 10px;
                height: 4px;
                left: ${rect.right}px;
                top: ${rect.top + rect.height/2}px;
                border-radius: 1px;
            `;
            
            gameAnimation.appendChild(projectile);
            
            gsap.to(projectile, {
                x: window.innerWidth,
                duration: 2,
                ease: "none",
                onComplete: () => {
                    projectile.remove();
                }
            });
        }
        
        // 3. Tir avec la barre espace
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();  // Empêche le scroll
                createProjectile();
            }
        });
        
        // 4. Tir automatique toutes les secondes
        const shootInterval = setInterval(createProjectile, 1000);
        
        // 5. Animation du background
        tl.to("#stars-bg", {
            x: "-80%",
            duration: 3,
            ease: "power2.out"
        })
        
        // 6. Faire apparaître les boutons
        .to("#menu-buttons", {
            opacity: 1,
            pointerEvents: "auto",
            duration: 1,
            ease: "power2.out",
        });
    }, 0);
    
    return `
        <!-- Instructions de contrôle EN BAS À GAUCHE -->
        <div class="fixed bottom-4 left-4 text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white">
            <p>🖱️ Souris : Contrôler l'avion</p>
            <p>Espace : Tirer</p>
        </div>
        
        <!-- Canvas pour l'animation -->
        <div id="game-animation" class="fixed inset-0 w-full h-full bg-[#04071A] overflow-hidden">
            <!-- Background étoilé -->
            <div id="stars-bg" class="absolute inset-0 w-[200%]">
                ${Array.from({length: 100}, (_, i) => `
                    <div 
                        class="absolute bg-white rounded-full ${i % 5 === 0 ? 'animate-pulse' : ''}"
                        style="
                            width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                            height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                            left: ${Math.random() * 100}%;
                            top: ${Math.random() * 100}%;
                            opacity: ${0.3 + Math.random() * 0.7};
                            ${i % 5 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
                        "
                    ></div>
                `).join('')}
            </div>
            
            <!-- Avion -->
            <div id="spaceship" class="absolute" style="
                width: 128px;
                height: 128px;
                top: 50%;
                left: 20%;
                transform: translate(-50%, -50%);
            ">
                <img 
                    src="/sprites/spaceship.png" 
                    alt="spaceship"
                    class="w-full h-full"
                    style="image-rendering: pixelated;"
                />
            </div>
        </div>

        <!-- Container des boutons -->
		<div id="menu-buttons" class="fixed inset-0 flex flex-col items-center justify-center opacity-0 pointer-events-none">

			<div class="absolute top-8 left-8">
				${BackButton({
					size: "lg",
					className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
				})}
			</div>

			<div class="absolute top-8 right-8">
			${SettingsButton({
				size: "lg",
				className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
			})}
			</div>
		

			<!-- Texte central qui change -->
			<div id="center-text" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white/70 text-4xl font-bold text-center">
				Choisissez votre destination !
			</div>

			<div class="absolute right-0 top-0 w-1/3 h-full">
				<!-- Bouton Quickplay -->
				<a href="/game" 
				class="absolute block w-[350px] h-[250px]" 
				style="top: 10%; right: 30%;"
				onmouseover="document.getElementById('center-text').textContent = '⚡ Partie Rapide'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/blackhole.png" 
						alt="Quickplay"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
				
				<!-- Bouton Tournament -->
				<a href="/tournament" 
				class="absolute block w-[900px] h-[800px]" 
				style="top: 65%; right: 50%;"
				onmouseover="document.getElementById('center-text').textContent = '🏆 Mode Tournoi'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/earth.png" 
						alt="Tournament"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
				
				<!-- Bouton Skin -->
				<a href="/skin" 
				class="absolute block w-[125px] h-[125px]" 
				style="top: 65%; right: 175px;"
				onmouseover="document.getElementById('center-text').textContent = '🎨 Personnalisation'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/satellite.png" 
						alt="Skin"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
		</div>

    `;
};




═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/LoginView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { 
	Button,
	BackButton
	 } from "../components/Button";

 export const LoginView: ViewFunction = () => {
	return `
		<!-- Fond étoilé -->
		<div class="fixed inset-0 bg-[#04071A] overflow-hidden">
			<!-- Étoiles -->
			${Array.from({length: 150}, (_, i) => `
			<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			<!-- Étoiles normales -->
			${Array.from({length: 150}, (_, i) => `
				<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			
			<!-- Étoiles qui scintillent fort -->
			${Array.from({length: 50}, (_) => `
				<div 
					class="absolute"
					style="
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
					"
				>
					<div class="w-[4px] h-[4px] bg-white rounded-full"></div>
				</div>
			`).join('')}
			
			<style>
				@keyframes strong-sparkle {
					0%, 100% {
						opacity: 0.3;
						filter: blur(0px);
					}
					50% {
						opacity: 1;
						filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
					}
				}
			</style>
			
			

		<!-- BackButton -->
		
		<!-- Fenêtre centrale -->
		<div class="fixed inset-0 flex items-center justify-center z-10 px-8">
		<div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-8 w-full max-w-6xl min-h-[600px] shadow-2xl flex">
		<!-- Côté gauche avec le formulaire -->
			<div class="w-1/2 border-r border-white/20 p-8 flex items-center justify-center">
				<div class="absolute top-8 left-8">
					${BackButton({
						size: "lg",
						className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
					})}
				</div>
					<img 
						src="/sprites/cat.gif" 
						alt="Animation"
						class="w-full h-full object-contain rounded"
					/>
			</div>
			<!-- Côté droit avec le formulaire -->
			<div class="w-1/2 px-8 flex flex-col justify-center items-center">
				<h1 class="text-4xl font-bold mb-4 text-white">Hello !</h1>
				<h2 class="text-2xl font-bold mb-8 text-white/80 text-center">Login your account</h2>

				<form action="/login" method="POST" id="loginForm">
					<div class="mb-4">
						<label for="username" class="block mb-2 text-white/70">Username:</label>
						<input 
							type="text" 
							id="username" 
							name="username"
							placeholder="Enter your username"
							required
							class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
						>
					</div>
					<div class="mb-6">
						<label for="password" class="block mb-2 text-white/70">Password:</label>
						<input 
							type="password" 
							id="password" 
							name="password"
							placeholder="Enter your password"
							required
							class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
						>
					</div>
					<button type="submit" class="w-full py-2 mb-4 text-center bg-[#101C69]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20">
						Submit
					</button>
				</form>

				${Button({
					children: "Create account",
					variant: "default",
					size: "sm",
					href: "/create",
					className: "w-full text-center text-white/80"
				})} 
			</div>
		</div>
	`;
};
	


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/TestView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { Header } from "../components/Header";
import { SimpleAuth } from "../simpleAuth/SimpleAuth";

export const TestView: ViewFunction = () => {
	return `
		${Header({ isLogged: false })}
		<div class="container mx-auto p-6 max-w-4xl">
			<h1 class="text-3xl font-bold text-gray-800 mb-6">Test Client QuickPlay</h1>
			
			<!-- Status de connexion -->
			<div id="connection-status" class="p-4 mb-4 rounded-lg border bg-gray-100 text-gray-800">
				Non connecté
			</div>
			
			<!-- Contrôles de connexion -->
			<div class="mb-6 p-4 bg-white rounded-lg shadow-sm border">
				<h3 class="text-lg font-semibold mb-3">Connexion</h3>
				<div class="flex flex-wrap gap-3 items-center">
					<input 
						type="text" 
						id="username" 
						placeholder="Nom d'utilisateur" 
						value="TestPlayer"
						class="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
					>
				</div>
			</div>
			
			<!-- Contrôles de jeu -->
			<div class="mb-6 p-4 bg-white rounded-lg shadow-sm border">
				<h3 class="text-lg font-semibold mb-3">Actions de jeu</h3>
				<div class="flex flex-wrap gap-3">
					<button 
						id="join-quickplay-btn" 
						class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500"
					>
						Rejoindre QuickPlay
					</button>
				</div>
			</div>
			
			<!-- Messages reçus -->
			<div class="mb-6">
				<h3 class="text-lg font-semibold mb-3">Messages reçus :</h3>
				<div 
					id="messages" 
					class="h-64 overflow-y-auto border border-gray-300 rounded-lg p-4 bg-gray-50 font-mono text-sm"
				></div>
			</div>
			
			<!-- Infos de debug -->
			<div class="p-4 bg-white rounded-lg shadow-sm border">
				<h3 class="text-lg font-semibold mb-3">Infos de debug :</h3>
				<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
					<div class="flex justify-between">
						<span class="font-medium">Room ID:</span>
						<span id="room-id" class="text-gray-600">-</span>
					</div>
					<div class="flex justify-between">
						<span class="font-medium">Player Number:</span>
						<span id="player-number" class="text-gray-600">-</span>
					</div>
				</div>
			</div>
		</div>
	`;
};

export const quickplayLogic = (): CleanupFunction => {
    let pollInterval: NodeJS.Timeout | null = null;
    let roomId: string | null = null;

    const handleJoin = async () => {
        const username = (document.getElementById('username') as HTMLInputElement).value;
        const playerId = window.simpleAuth.getPlayerId();

		console.log(`Attempting to join quickplay...`)
		console.log(JSON.stringify({ username, playerId }))

        try {
            const response = await fetch('/quickplay/join', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, playerId })
            });
            const data = await response.json();
            
            if (data.success) {
                roomId = data.roomId;
                startPolling();
            }
        } catch (err) {
            console.error(err);
        }
    };

    const startPolling = () => {
        pollInterval = setInterval(async () => {
            if (!roomId) return;
            
            const response = await fetch(`/quickplay/status/${roomId}`);
            const data = await response.json();
            
            if (data.status === 'ready') {
                // Redirige vers le jeu
                sessionStorage.setItem('gameWsURL', data.gameServerURL);
                window.router.navigate(`/game/${roomId}`);
                stopPolling();
            }
        }, 2000); // Poll toutes les 2s
    };

    const stopPolling = () => {
        if (pollInterval) clearInterval(pollInterval);
    };

    // Attache handleJoin à un bouton
    document.getElementById('join-quickplay-btn')?.addEventListener('click', handleJoin);

    return () => {
        stopPolling();
        document.getElementById('join-quickplay-btn')?.removeEventListener('click', handleJoin);
    };
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/HomeView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { Header } from "../components/Header";
import { VolumeControl } from "../components/VolumeControl";
import { 
    Button,
    SkinButton,
    SettingsButton,
	CoffeeButton
} from "../components/Button";


export const HomeView: ViewFunction = () => {
    return `
		${Header({ isLogged: false })}
        <div class="container ml-auto mr-auto">
            <h1 class="text-9xl text-amber-300">Pong</h1>
			${Button({ // -> syntax pour appeler la fonction creer dans les composants
				children: "Start game",
				variant: "primary",
				size: "lg",
				href: "/startgame",
				className: "flex justify-center align-center"
			})} 
			${SkinButton()}
			${SettingsButton()}
			${CoffeeButton()}
			<div class="fixed bottom-4 right-4 z-20 bg-black/50 backdrop-blur-sm rounded-lg">
            ${VolumeControl({ 
                initialVolume: 0,
                className: "w-32"
            })}
        </div>
        </div>
    `;
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/BracketView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types"
import { Header } from "../components/Header";
import type { RouteParams } from "../router/types";

interface Player
{
	id: string;
	username: string;
	currentTournament?: string;
	isEleminated: boolean;
}

interface Match
{
    id: string;
	tournamentId: string;
	round: number;
	position: number;
	player1?: Player;
	player2?: Player;
	winner?: Player;
	roomId?: string;
	status: 'pending' | 'ready' | 'in_progress' | 'finished';
	scheduledAt?: Date;
	finishedAt?: Date;
}

interface Tournament
{
	id: string;
	name: string;
	status: 'registration' | 'in_progress' | 'finished';
	maxPlayers: number;
	currentPlayers: Player[];
	bracket: Match[];
	currentRound: number;
	winner?: Player;
	createdAt: Date;
	StartedAt?: Date;
	finishedAt?: Date;
}


export const BracketView: ViewFunction = () => {
	return `
		${Header({isLogged: false})}
        <div class="relative container ml-auto mr-auto">
            <div id="tournament-loading" class="text-center p-8">
                <div>Chargement du tournoi...</div>
            </div>
            <div id="tournament-content" style="display: none;">
                <div id="tournament-header" class="mb-6"></div>
                <div id="tournament-brackets"></div>
            </div>
            <div id="tournament-error" style="display: none;" class="text-center p-8 text-red-500">
                <div>Erreur lors du chargement du tournoi</div>
            </div>
        </div>
	`
}

export const bracketLogic = (params: RouteParams | undefined): (() => void) => {
	const tournamentId = params?.id;
	const myPlayerId = window.simpleAuth.getPlayerId();

    const fetchTournamentData = async (): Promise<void> => {
        try
		{
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok)
			{
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const tournament = data.tournament;
            
            displayTournament(tournament);
            
            checkIfMyTurn(tournament);
        }
		catch (error)
		{
            console.error('Erreur lors de la récupération du tournoi:', error);
            showError();
        }
    };

	const checkIfMyTurn = (tournament: Tournament): void => {
        const myMatch = tournament.bracket.find(match => 
            match.status === 'in_progress' &&
            (match.player1?.id === myPlayerId || match.player2?.id === myPlayerId)
        );

        if (myMatch && myMatch.roomId)
		{
            console.log('Mon match est prêt ! Redirection...');
            
            const host = import.meta.env.VITE_HOST;
            const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
            const wsUrl = `wss://${host}${endpoint}/${myMatch.roomId}`;
            sessionStorage.setItem('gameWsURL', wsUrl);
            
            window.location.href = `/game/${myMatch.roomId}`;
        }
    };

	const displayTournament = (tournament: Tournament): void => {
        hideLoading();
        showContent();

        const headerElement = document.getElementById('tournament-header');
        if (headerElement) {
            headerElement.innerHTML = `
                <div class="bg-gray-800 p-4 rounded-lg mb-4">
                    <h2 class="text-2xl font-bold text-white mb-2">Tournoi ${tournament.name}</h2>
                    <div class="text-gray-300">
                        <span class="mr-4">Statut: <span class="text-blue-400">${getStatusText(tournament.status)}</span></span>
                        <span class="mr-4">Round actuel: <span class="text-green-400">${tournament.currentRound}</span></span>
                        ${tournament.winner ? `<span>Gagnant: <span class="text-yellow-400">${tournament.winner.username}</span></span>` : ''}
                    </div>
                </div>
            `;
        }

        const bracketsElement = document.getElementById('tournament-brackets');
        if (bracketsElement) {
            bracketsElement.innerHTML = generateBracketsHTML(tournament.bracket);
        }
		
    };

	const generateBracketsHTML = (matches: Match[]): string => {
        if (matches.length === 0) {
            return '<div class="text-center p-8 text-gray-500">Aucun match disponible</div>';
        }

        const matchesByRound = matches.reduce((acc, match) => {
            if (!acc[match.round]) {
                acc[match.round] = [];
            }
            acc[match.round].push(match);
            return acc;
        }, {} as Record<number, Match[]>);

        let html = '<div class="brackets-container">';
        
        Object.keys(matchesByRound).sort((a, b) => parseInt(a) - parseInt(b)).forEach(round => {
            const roundMatches = matchesByRound[parseInt(round)];
            html += `
                <div class="round mb-8">
                    <h3 class="text-xl font-semibold mb-4 ">Round ${round}</h3>
                    <div class="matches grid gap-4">
            `;
            
            roundMatches.forEach(match => {
                html += generateMatchHTML(match);
            });
            
            html += `
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        return html;
    };

	const generateMatchHTML = (match: Match): string => {
        const getStatusColor = (status: string): string => {
            switch (status) {
                case 'ready': return 'bg-blue-600';
                case 'in_progress': return 'bg-yellow-600';
                case 'finished': return 'bg-green-600';
                default: return 'bg-gray-600';
            }
        };

        return `
            <div class="match bg-gray-800 p-4 rounded-lg border-2 ${match.winner ? 'border-green-500' : 'border-gray-600'}">
                <div class="match-header mb-2">
                    <span class="text-sm ${getStatusColor(match.status)} text-white px-2 py-1 rounded">
                        ${getStatusText(match.status)}
                    </span>
                </div>
                <div class="players">
                    <div class="player ${match.winner?.id === match.player1?.id ? 'winner' : ''} p-2 mb-1 rounded ${match.winner?.id === match.player1?.id ? 'bg-green-700' : 'bg-gray-700'}">
                        <span class="text-white">${match.player1?.username || 'En attente...'}</span>
                        ${match.winner?.id === match.player1?.id ? '<span class="text-yellow-400 ml-2">👑</span>' : ''}
                    </div>
                    <div class="vs text-center text-gray-400 text-sm">VS</div>
                    <div class="player ${match.winner?.id === match.player2?.id ? 'winner' : ''} p-2 mt-1 rounded ${match.winner?.id === match.player2?.id ? 'bg-green-700' : 'bg-gray-700'}">
                        <span class="text-white">${match.player2?.username || 'En attente...'}</span>
                        ${match.winner?.id === match.player2?.id ? '<span class="text-yellow-400 ml-2">👑</span>' : ''}
                    </div>
                </div>
            </div>
        `;
    };

	const getStatusText = (status: string): string => {
        switch (status) {
            case 'registration': return 'Inscription';
            case 'in_progress': return 'En cours';
            case 'finished': return 'Terminé';
            case 'ready': return 'Prêt';
            case 'pending': return 'En attente';
            default: return status;
        }
    };

    const hideLoading = (): void => {
        const loading = document.getElementById('tournament-loading');
        if (loading) loading.style.display = 'none';
    };

    const showContent = (): void => {
        const content = document.getElementById('tournament-content');
        if (content) content.style.display = 'block';
    };

    const showError = (): void => {
        hideLoading();
        const error = document.getElementById('tournament-error');
        if (error) error.style.display = 'block';
    };

    fetchTournamentData();

    const pollInterval = setInterval(fetchTournamentData, 2000);

	// === FONCTION DE CLEANUP ===
	return (): void => {
		clearInterval(pollInterval);
	};
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/router/Router.ts
═══════════════════════════════════════════════════════
import type { Route, CleanupFunction, RouteParams } from './types';
import { ComponentManager } from '../components/ComponantManager'
import { HomeView } from '../views/HomeView';
import { TestView, quickplayLogic } from '../views/TestView';
import { GameView } from '../views/GameView';
import { StartGameView } from '../views/StartGameView';
import { LoginView } from '../views/LoginView';
import { CreateAccountView } from '../views/CreateAccountView';
import { tournamentLogic, TournamentView } from '../views/TournamentView';
import { BracketView, bracketLogic } from '../views/BracketView';
import type { NavigationGuard } from './types';
import {
    logGuard,
    tournamentExistsGuard,
    roomExistsGuard
} from './Guards'

export class Router {
    private routes: Route[];
	private currentCleanup: CleanupFunction | null = null;
    private componentManager: ComponentManager;
    private currentRoute?: Route;
    private globalBeforeEach?: NavigationGuard;
    
    constructor()
    {
        this.routes = [];
        this.componentManager = new ComponentManager();
        this.setupRoutes();
		this.setupLinkInterception();
		this.setupHistoryNavigation();

        this.globalBeforeEach = logGuard;
    }
    
    private setupRoutes(): void
    {
        this.routes.push({
            path: '/',
            view: HomeView,
            title: 'Accueil'
        });

		this.routes.push({
            path: '/test',
            view: TestView,
			onMount: quickplayLogic,
            title: 'Test'
        });

		this.routes.push({
            path: '/game/:roomId',
            view: GameView,
            title: 'Pong gaming',
            beforeEnter: async (to, from, params) => {
                return await roomExistsGuard(to, from, params);
            },
        });

        this.routes.push({
            path: '/tournament',
            view: TournamentView,
            onMount: tournamentLogic,
            title: 'Tournament'
        });

        this.routes.push({
            path: '/tournament/:id',
            view: BracketView,
            onMount: bracketLogic,
            title: 'Tounament brackets',
            beforeEnter: async (to, from, params) => {
                return await tournamentExistsGuard(to, from, params);
            }
        });

		this.routes.push({
            path: '/startgame',
            view: StartGameView,
            title: 'Test'
        });

		this.routes.push({
            path: '/login',
            view: LoginView,
            title: 'Test'
        });

		this.routes.push({
            path: '/create',
            view: CreateAccountView,
            title: 'Test'
        });

        this.compileRoutes();
    }

    private compileRoutes(): void {
        this.routes.forEach(route => {
            if (route.path.includes(':'))
            {
                const paramNames: string[] = [];
                
                const regexPattern = route.path.replace(/:([^/]+)/g, (match, paramName) => {
                    paramNames.push(paramName);
                    return '([^/]+)';
                });

                route.regex = new RegExp(`^${regexPattern}$`);
                route.paramNames = paramNames;
            }
        });
    }

	private setupLinkInterception(): void
    {
		document.addEventListener('click', (e: MouseEvent) => {
			const target = e.target as HTMLElement;
			const link = target.closest('a');
			
			if (link && link instanceof HTMLAnchorElement)
            {
				const href = link.getAttribute('href');
				
				if (!href) return;
				
				if (this.isExternalLink(href))
                {
					return;
				}
				
				e.preventDefault();
				this.navigateTo(href);
			}
		});
	}

	private isExternalLink(href: string): boolean
    {
		return /^(https?:\/\/|mailto:|tel:|ftp:)/.test(href);
	}

	private setupHistoryNavigation(): void
    {
        window.addEventListener('popstate', () => {
            this.navigate(window.location.pathname, false);
        });
    }

	public navigateTo(path: string): void
    {
        if (window.location.pathname !== path)
        {
            window.history.pushState({}, '', path);
            this.navigate(path);
        }
    }
    
    public async navigate(path: string, updateHistory: boolean = true): Promise<void> {
        this.cleanup();
        
        const matchResult = this.findRoute(path);
        if (matchResult) {
            const { route, params } = matchResult;

            if (this.globalBeforeEach)
            {
                const globalResult = await this.globalBeforeEach(
                    route, 
                    this.currentRoute, 
                    params
                );
                
                if (globalResult === false)
                {
                    console.log('Navigation unauthorized by global guard');
                    return;
                }
                
                if (typeof globalResult === 'string')
                {
                    console.log(`Global redirection to ${globalResult}`);
                    this.navigateTo(globalResult);
                    return;
                }
            }

            if (route.beforeEnter)
            {
                const guardResult = await route.beforeEnter(
                    route, 
                    this.currentRoute, 
                    params
                );
                
                if (guardResult === false)
                {
                    console.log('Navigation unauthorized by local path guard');
                    return;
                }
                
                if (typeof guardResult === 'string')
                {
                    console.log(`Redirection by local path guard to ${guardResult}`);
                    this.navigateTo(guardResult);
                    return;
                }
            }
            
            const htmlContent = route.view(params);
            const app = document.getElementById('app');
            if (app) {
                app.innerHTML = htmlContent;
            }
            
            document.title = route.title || 'Transcendence';
            
            if (updateHistory && window.location.pathname !== path) {
                window.history.pushState({}, '', path);
            }
            
            this.componentManager.scanAndMount();

            if (route.onMount) {
                const cleanup = route.onMount(params);
                if (cleanup && typeof cleanup === 'function') {
                    this.currentCleanup = cleanup;
                }
            }

            this.currentRoute = route;

        } else {
            this.show404();
        }
    }

	private cleanup(): void
    {
        this.componentManager.cleanupAll();

        if (this.currentCleanup)
        {
            this.currentCleanup();
            this.currentCleanup = null;
        }
    }
    
    private findRoute(path: string): { route: Route; params: RouteParams } | undefined {
        for (const route of this.routes)
        {
            if (!route.regex && route.path === path)
            {
                return { route, params: {} };
            }
            
            if (route.regex && route.paramNames)
            {
                const match = path.match(route.regex);
                if (match)
                {
                    const params: RouteParams = {};
                    
                    route.paramNames.forEach((paramName, index) => {
                        params[paramName] = match[index + 1];
                    });
                    
                    return { route, params };
                }
            }
        }
        
        return undefined;
    }
    
    private show404(): void
    {
        document.getElementById('app')!.innerHTML = '<h1>Erm... This page does not exist.</h1>';
    }

    public setGlobalGuard(guard: NavigationGuard): void {
        this.globalBeforeEach = guard;
    }
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/router/Guards.ts
═══════════════════════════════════════════════════════
import type { NavigationGuard } from './types';

export const roomExistsGuard: NavigationGuard = async (to, from, params) => {
    const roomId = params?.roomId;
    
    if (!roomId)
	{
        console.log('No room id provided');
        return '/';
    }
    
    try {
        const host = import.meta.env.VITE_HOST || 'localhost:8443';
        const response = await fetch(
            `https://${host}/quickplay/status/${roomId}`,
            {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }
        );
        
        if (!response.ok) {
            console.log('Invalid room');
            return '/';
        }
        
        const data = await response.json();
        
        if (data.status === 'ready' && data.gameServerURL) {
            console.log('Room exists, statut ready');
            sessionStorage.setItem('gameWsURL', data.gameServerURL);
            return true;
        } else if (data.status === 'waiting') {
            console.log('Room is waiting for players, redirection');
            return '/test';
        } else if (data.status === 'finished') {
            console.log('Room is finished, redirection');
            return '/';
        } else {
            console.log('Invalid room status:', data.status);
            return '/';
        }
    } catch (err) {
        console.error('Error while guard checking the room', err);
        return '/';
    }
};

export const tournamentExistsGuard: NavigationGuard = async (to, from, params) => {
    if (!params?.id) {
        console.log('No tournament id provided');
        return '/tournament';
    }
    
    try {
        const host = import.meta.env.VITE_HOST || 'localhost:8443';
        const response = await fetch(
            `https://${host}/tournamentback/tournaments/${params.id}`
        );
        
        if (!response.ok) {
            console.log('Tournament not found');
            return '/tournament';
        }
        
        return true;
    } catch (err) {
        console.error('Error while fetching tournament:', err);
        return '/tournament';
    }
};

export const logGuard: NavigationGuard = (to, from, params) => {
    console.log('📍 Navigation:', {
        from: from?.path || 'initial',
        to: to.path,
        params
    });
    return true;
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/router/types.ts
═══════════════════════════════════════════════════════

export interface Route
{
	path: string;
	view: ViewFunction;
	onMount?: (params?: RouteParams) => CleanupFunction | void;
	title?: string;
	regex?: RegExp;
    paramNames?: string[];

	beforeEnter?: NavigationGuard;
    meta?: Record<string, any>;
}

export type GuardResult = boolean | string | Promise<boolean | string>;

export type NavigationGuard = (
	to: Route,
    from?: Route,
    params?: RouteParams
) => GuardResult;

export type ViewFunction = (params?: RouteParams) => string;
export type CleanupFunction = () => void;
export type RouteParams = Record<string, string>;



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/main.ts
═══════════════════════════════════════════════════════
import './style.css'
import { Router } from './router/Router';
import { registerComponents } from './components';
import { SimpleAuth } from './simpleAuth/SimpleAuth'

declare global {
    interface Window {
        router: Router;
        simpleAuth: SimpleAuth;
    }
}

registerComponents(); 

const auth = new SimpleAuth()
window.simpleAuth = auth;

const router = new Router();

const currentPath = window.location.pathname;
router.navigate(currentPath);

window.router = router;



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/net/wsClient.ts
═══════════════════════════════════════════════════════
export type PublicState = {
	leftPaddle: {y: number; speed: number; intention: number};
	rightPaddle: {y: number; speed: number; intention: number};
	balls: {x: number; y: number; vx: number; vy: number; radius: number}[];
	score: {left: number; right: number};
	isPaused: boolean;
	isGameOver: boolean;
	winner: '' | 'left' | 'right';
	countdownValue: number;
	powerUps: {x: number, y: number, radius: number}[];
	splitActive: boolean;
	clock: number;
	smash: {
		cooldown: number;
		animDuration: number;
		left: {cooldownRemaining: number; lastSmashAt: number};
		right: {cooldownRemaining: number; lastSmashAt: number};
	};
};

type ServerMsg = 
	| {type: 'welcome'; side: 'left' | 'right'; isTournament?: boolean; tournamentId?: string}
	| {type: 'state'; state: PublicState; serverTime: number}
	| {type: 'countdown'; value: number}
	| {type: 'paused' | 'resumed'}
    | {type: 'resumed'}
    | {type: 'timeout_status'; left: {active: boolean; remainingMs: number};
                               right: {active: boolean; remainingMs: number};}
	| {type: 'gameover'; winner: 'left' | 'right'; isTournament?: boolean; tournamentId?: string}
	| {type: 'pong'; t: number};

export class WSClient {
	private ws?: WebSocket;
	side: 'left' | 'right' = 'left';

	isTournament: boolean = false;
    tournamentId?: string;

	onState?: (s: PublicState) => void;
	onCountdown?: (v: number) => void;
	onGameOver?: (w: 'left' | 'right', isTournament?: boolean, tournamentId?: string) => void;
    onPaused?: () => void;
    onResumed?: () => void;
    onTimeoutStatus?: (status: {
        left: {active: boolean; remainingMs: number};
        right: {active: boolean; remainingMs: number}
    }) => void;
	connect(url?: string) {
		const host = import.meta.env.VITE_HOST
		const endpoint = import.meta.env.VITE_GAME_ENDPOINT
		const defaultUrl = (host && endpoint) ? `wss://${host}${endpoint}`
					: undefined;
		const finalUrl = url ?? defaultUrl;
        if (!finalUrl)
        {
            console.warn('WSClient: no URL provided and no defaultUrl');
            return;
        }
        console.log('WSClient: connecting to', finalUrl);
        this.ws = new WebSocket(finalUrl);
		this.ws.onopen = () => {
			const playerId = window.simpleAuth.getPlayerId();
			console.log('WebSocket opened, sending logIn with ID:', playerId);
			this.ws?.send(JSON.stringify({
				type: 'logIn', 
				id: playerId
			}));
		};
		this.ws.onmessage = (ev) => {
			console.log(ev.data)
			const msg = JSON.parse(ev.data) as ServerMsg;
			switch (msg.type) {
				case 'welcome':
					console.log('Welcome from server');
					this.side = msg.side;
					break;
				case 'state':
					this.onState?.(msg.state);
					break;
				case 'countdown':
					this.onCountdown?.(msg.value);
					break;
				case 'paused':
					this.onPaused?.();
					break;
				case 'resumed':
					this.onResumed?.();
					break;
				case 'timeout_status':
					this.onTimeoutStatus?.(msg);
					break;
				case 'gameover':
					this.onGameOver?.(msg.winner, msg.isTournament, msg.tournamentId);
					break;
			}
		};
	}
	sendInput(up: boolean, down: boolean) {
		this.ws?.send(JSON.stringify({ type: 'input', up, down }));
	}
	pause() {
		this.ws?.send(JSON.stringify({ type: 'pause' }));
	}
	resume() {
		this.ws?.send(JSON.stringify({ type: 'resume' }));
	}
	smash() {
		this.ws?.send(JSON.stringify({ type: 'smash' }));
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/authback/server.ts
═══════════════════════════════════════════════════════
import Fastify from 'fastify';
import fastifyJwt from '@fastify/jwt';
import fastifyCookie from '@fastify/cookie';
import { LoginRequest, RegisterRequest, UserPayload } from './types';

const app = Fastify({
	logger: true
});

// Register plugins
app.register(fastifyCookie, {
	secret: process.env.JWT_SECRET || (() => { throw new Error('JWT_SECRET environment variable is required'); })()
});

app.register(fastifyJwt, {
	secret: process.env.JWT_SECRET || (() => { throw new Error('JWT_SECRET environment variable is required'); })()
});

// WIP - Temporary storage and id
const users: Array<{ id: number; username: string; password: string; email?: string }> = [];
let userIdCounter = 1;

// WIP - find user will have to be related to the db
const findUser = (username: string) => users.find(u => u.username === username);

// Register
app.post('/register', async (request, reply) => {
	try {
		const { username, password, email } = request.body as RegisterRequest; // TODO: secure by checking schema

		if (!username || !password) {
			return reply.status(400).send({error: 'Username and password are required'});
		}
		if (findUser(username)) {
			return reply.status(409).send({ error: 'Username already exists'});
		}

		const newUser = {
			id: userIdCounter++,
			username,
			password, // TODO: Hash the password
			email
		};
		users.push(newUser);

		// create jwt
		const token = (app as any).jwt.sign({ // TODO: check the different type of encoding
			username: newUser.username, 
			userId: newUser.id
		});

		return reply.send({ 
			success: true,
			token,
			user: { 
				id: newUser.id, 
				username: newUser.username,
				email: newUser.email 
			} 
		});
	} catch (error) {
		app.log.error(error);
		// TODO: handle specific errors like 400 when body is malformed, 503 when db is down, etc
		return reply.status(500).send({error: 'Internal server error'});
	}
});

// Login
app.post('/login', async (request, reply) => {
	try {
		const { username, password } = request.body as LoginRequest; // TODO: secure by checking schema

		if (!username || !password) {
			return reply.status(400).send({error: 'Username and password are required'});
		}

		const user = findUser(username);
		if (!user || user.password !== password) { // WIP - compare hashed passwords
			return reply.status(401).send({error: 'Invalid credentials'});
		}

		// create jwt
		const token = (app as any).jwt.sign({ 
			username: user.username, 
			userId: user.id 
		});

		return reply.send({ 
			success: true,
			token,
			user: { 
				id: user.id, 
				username: user.username,
				email: user.email 
			} 
		});
	} catch (error) {
		app.log.error(error);
		return reply.status(500).send({error: 'Internal server error'});
	}
});

// Verify/validate token
app.get('/verify', async (request, reply) => {
	try {
		await (request as any).jwtVerify();
		const payload = (request as any).user as UserPayload;
		
		return reply.send({ 
			valid: true,
			user: {
				username: payload.username
			}
		});
	} catch (error) {
		return reply.status(401).send({valid: false, error: 'Invalid or expired token'});
	}
});

// Health check
app.get('/health', async (request, reply) => {
	return reply.send({status: 'ok', service: 'auth-server'});
});

// Start server
const start = async () => {
	try {
		const port = parseInt(process.env.AUTH_PORT || (() => { throw new Error('AUTH_PORT environment variable is required'); })());
		const host = process.env.AUTH_VALID_HOST || (() => { throw new Error('AUTH_VALID_HOST environment variable is required'); })();

		await app.listen({ port, host });
		app.log.info(`OK: Auth server listening on ${host}:${port}`);
	} catch (err) {
		app.log.error(`ERROR: ${err}`);
		process.exit(1);
	}
};

start();



═══════════════════════════════════════════════════════
FILE: ./apps/authback/types.ts
═══════════════════════════════════════════════════════
// types
export interface LoginRequest {
	username: string;
	password: string;
}

export interface RegisterRequest {
	username: string;
	password: string;
	email?: string;
}

export interface UserPayload {
	username: string;
}





═══════════════════════════════════════════════════════
FILE: ./apps/tournamentback/server.ts
═══════════════════════════════════════════════════════
import Fastify from 'fastify'
import { TournamentManager } from './TournamentManager'
import type { Player } from './types'

const fastify = Fastify({
	logger: true
})

const tournamentManager = new TournamentManager()
tournamentManager.initTournaments()

// fastify.addHook('onRequest', async (request, reply) => {
//     console.log('=== REQUÊTE REÇUE ===')
//     console.log('URL:', request.url)
//     console.log('Method:', request.method)
//     console.log('Headers:', JSON.stringify(request.headers, null, 2))
//     console.log('====================')
// })

fastify.post('/match-finished', async (request, reply) => {
    const { matchId, winnerId } = request.body as { 
        matchId: string; 
        winnerId: string;
    };

    if (!matchId || !winnerId)
	{
        return reply.status(400).send({ 
            success: false, 
            error: 'matchId and winnerId are required' 
        });
    }

    console.log(`Match ${matchId} finished, winner: ${winnerId}`);

    tournamentManager.onMatchFinished(matchId, winnerId);

    return { success: true };
});

fastify.get('/tournaments', async (request, reply) => {
    const registrations = tournamentManager.getCurrentRegistrations()
    return { success: true, registrations }
})

fastify.post('/tournaments/:tournamentId/join', async (request, reply) => {
    const { tournamentId } = request.params as { tournamentId: string }
    const { username, playerId } = request.body as { username: string; playerId: string }

    if (!username || !playerId)
	{
        return reply.status(400).send({ 
            success: false, 
            error: 'Username and playerId are required' 
        })
    }

    const newPlayer: Player = {
        id: playerId,
        username,
        currentTournament: tournamentId,
        isEleminated: false,
    }

    const success = tournamentManager.registerPlayer(tournamentId, newPlayer)
    
    if (!success)
	{
        return reply.status(400).send({ 
            success: false, 
            error: 'Cannot join tournament: tournament full or unavailable' 
        })
    }

    const tournament = tournamentManager.getTournamentDetails(tournamentId)
    if (tournament?.status === 'in_progress')
	{
        return { 
            success: true, 
            tournamentStarted: true,
            tournamentId: tournament.id,
            message: 'Tournament is starting!' 
        }
    }

    return { 
        success: true, 
        tournamentStarted: false,
        currentPlayers: tournament?.currentPlayers.length || 0,
        maxPlayers: tournament?.maxPlayers || 0
    }
})

fastify.delete('/tournaments/leave/:playerId', async (request, reply) => {
    const { playerId } = request.params as { playerId: string }
    
    const removed = tournamentManager.removePlayerFromAllRegistrations(playerId)
    
    return { success: removed }
})

fastify.get('/tournaments/:id', async (request, reply) => {
    const { id } = request.params as { id: string }
    
    const tournament = tournamentManager.getTournamentDetails(id)
    
    if (!tournament)
	{
        return reply.status(404).send({ error: 'Tournament not found' })
    }
    
    return { success: true, tournament }
})

fastify.get('/tournaments/:id/brackets', async (request, reply) => {
    const { id } = request.params as { id: string }
    
    const brackets = tournamentManager.getTournamentBrackets(id)
    
    if (!brackets)
	{
        return reply.status(404).send({ error: 'Tournament not found' })
    }
    
    return { success: true, tournamentId: id, brackets }
})

fastify.get('/health', async (request, reply) => {
    return { status: 'ok', service: 'tournament-backend' }
})

fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

fastify.listen({ port: 3040, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



═══════════════════════════════════════════════════════
FILE: ./apps/tournamentback/types.ts
═══════════════════════════════════════════════════════
export interface Player
{
	id: string;
	username: string;
	currentTournament?: string;
	isEleminated: boolean;
}

export interface Match
{
	id: string;
	tournamentId: string;
	round: number;
	position: number;
	player1?: Player;
	player2?: Player;
	winner?: Player;
	roomId?: string;
	status: 'pending' | 'ready' | 'in_progress' | 'finished';
	scheduledAt?: Date;
	finishedAt?: Date;
}

export interface Tournament
{
	id: string;
	name: string;
	status: 'registration' | 'in_progress' | 'finished';
	maxPlayers: number;
	currentPlayers: Player[];
	bracket: Match[];
	currentRound: number;
	winner?: Player;
	createdAt: Date;
	StartedAt?: Date;
	finishedAt?: Date;
}

export interface registration
{
	id: string;
	name: string;
	currentPlayerCount: number;
}



═══════════════════════════════════════════════════════
FILE: ./apps/tournamentback/TournamentManager.ts
═══════════════════════════════════════════════════════
import type { Match, Player, registration, Tournament } from "./types";
import { v4 as uuidv4 } from 'uuid'
import https from 'https'

const isDevelopment = process.env.NODE_ENV === 'development'
const agent = isDevelopment ? new https.Agent({ rejectUnauthorized: false }) : undefined

export class TournamentManager
{
	private tournaments = new Map<string, Tournament>()

	initTournaments(): void
	{
		this.createTournament("4p", 4);
		this.createTournament("8p", 8);
		this.createTournament("16p", 16);
	}

	getCurrentRegistrations(): registration[]
	{
		let currentRegistrations: registration[] = []

		this.tournaments.forEach(tournament => {
			if ('registration' === tournament.status)
			{
				const registration: registration = {
					id: tournament.id,
					name: tournament.name,
					currentPlayerCount: tournament.currentPlayers.length
				}
				currentRegistrations.push(registration)
			}
		})

		return currentRegistrations;
	}

	createTournament(name: string, maxPlayers: number): Tournament
	{
		const tournament: Tournament = {
			id: uuidv4(),
			name,
			status: 'registration',
			maxPlayers,
			currentPlayers: [],
			bracket: [],
			currentRound: 0,
			createdAt: new Date()
		}

		this.tournaments.set(tournament.id, tournament);
		return tournament;
	}

	registerPlayer(tournamentId: string, newPlayer: Player): boolean
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament || tournament.status !== 'registration') return false;
		if (tournament.currentPlayers.length >= tournament.maxPlayers) return false;

		this.removePlayerFromOtherRegistrations(newPlayer.id, tournamentId);

		const isPlayerInTournament = tournament.currentPlayers.some(
			player => player.id === newPlayer.id
		);
		
		if (!isPlayerInTournament)
		{
			tournament.currentPlayers.push(newPlayer);
		}

		if (tournament.currentPlayers.length === tournament.maxPlayers)
		{
			this.startTournament(tournamentId);
		}

		return true;
	}

	removePlayerFromOtherRegistrations(playerId: string, excludeTournamentId: string): void
	{
		for (const [tournamentId, tournament] of this.tournaments)
		{
			if (tournament.status === 'registration' && tournamentId !== excludeTournamentId)
			{
				const playerIndex = tournament.currentPlayers.findIndex(p => p.id === playerId);
				if (playerIndex !== -1)
				{
					tournament.currentPlayers.splice(playerIndex, 1);
					console.log(`Player ${playerId} removed from tournament ${tournament.name} (switching tournaments)`);
				}
			}
		}
	}

	removePlayerFromAllRegistrations(playerId: string): boolean
	{
		let removed = false;
		for (const [_, tournament] of this.tournaments)
		{
			if (tournament.status === 'registration')
			{
				const playerIndex = tournament.currentPlayers.findIndex(p => p.id === playerId);
				if (playerIndex !== -1)
				{
					tournament.currentPlayers.splice(playerIndex, 1);
					console.log(`Player ${playerId} removed from tournament ${tournament.name}`);
					removed = true;
				}
			}
		}
		return removed;
	}

	startTournament(tournamentId: string): void
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return;

		const shuffledPlayers = this.shuffleArray([... tournament.currentPlayers])

		const firstRoundMatches: Match[] = [];
		for (var i = 0; i < shuffledPlayers.length; i += 2)
		{
			const match: Match = {
				id: uuidv4(),
				tournamentId,
				round: 1,
				position: Math.floor(i / 2),
				player1: shuffledPlayers[i],
				player2: shuffledPlayers[i + 1],
				status: 'ready'
			};
			firstRoundMatches.push(match);
		}

		tournament.bracket = firstRoundMatches;
		tournament.status = 'in_progress';
		tournament.currentRound = 1;
		tournament.StartedAt = new Date();

		this.createTournament(tournament.name, tournament.maxPlayers)
		console.log(`Tournament ${tournament.name} started with ${tournament.currentPlayers.length} players`);

		this.startNextMatch(tournamentId);
	}

	async startNextMatch(tournamentId: string): Promise<void>
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return;

		const nextMatch = tournament.bracket.find(m => 
			m.status === 'ready' &&
			m.round === tournament.currentRound &&
			m.player1 && m.player2
		);

		if (!nextMatch)
		{
			console.log(`No more matches ready in round ${tournament.currentRound}`);
			this.checkRoundCompletion(tournamentId);
			return;
		}

		try
		{
			const host = process.env.VITE_HOST || 'localhost:8443';
			const endpoint = '/quickplay/tournament-match';
			const url = `https://${host}${endpoint}`;

			console.log(`Creating tournament match: ${nextMatch.player1?.username} vs ${nextMatch.player2?.username}`);

			const response = await fetch(url, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					matchId: nextMatch.id,
					tournamentId: tournament.id,
					player1: {
						id: nextMatch.player1!.id,
						username: nextMatch.player1!.username
					},
					player2: {
						id: nextMatch.player2!.id,
						username: nextMatch.player2!.username
					}
				}),
				// @ts-ignore
				agent
			});

			if (!response.ok)
			{
				throw new Error(`Failed to create match: ${response.statusText}`);
			}

			const data = await response.json();
			
			nextMatch.roomId = data.roomId;
			nextMatch.status = 'in_progress';
			nextMatch.scheduledAt = new Date();

			console.log(`Match started successfully: roomId=${data.roomId}`);
		}
		catch (err)
		{
			console.error('Failed to create tournament match:', err);
			setTimeout(() => this.startNextMatch(tournamentId), 5000);
		}
	}

	onMatchFinished(matchId: string, winnerId: string): void
	{
		const match = this.findMatchById(matchId);
		if (!match)
		{
			console.error(`Match ${matchId} not found`);
			return;
		}

		const tournament = this.tournaments.get(match.tournamentId);
		if (!tournament)
		{
			console.error(`Tournament ${match.tournamentId} not found`);
			return;
		}

		match.winner = match.player1?.id === winnerId ? match.player1 : match.player2;
		match.status = 'finished';
		match.finishedAt = new Date();

		console.log(`Match finished: ${match.winner?.username} wins!`);

		const loser = match.player1?.id === winnerId ? match.player2 : match.player1;
		if (loser) {
			const loserInTournament = tournament.currentPlayers.find(p => p.id === loser.id);
			if (loserInTournament) {
				loserInTournament.isEleminated = true;
			}
		}

		this.checkRoundCompletion(match.tournamentId);
	}

	checkRoundCompletion(tournamentId: string): void {
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return;

		const currentRoundMatches = tournament.bracket.filter(m => m.round === tournament.currentRound);
		const finishedMatches = currentRoundMatches.filter(m => m.status === 'finished');
		const inProgressMatches = currentRoundMatches.filter(m => m.status === 'in_progress');

		console.log(`Round ${tournament.currentRound} status: ${finishedMatches.length}/${currentRoundMatches.length} finished, ${inProgressMatches.length} in progress`);

		if (inProgressMatches.length > 0)
		{
			console.log('Waiting for matches to finish...');
			return;
		}

		if (finishedMatches.length === currentRoundMatches.length)
		{
			if (finishedMatches.length === 1 && tournament.currentRound > 1)
			{
				tournament.winner = finishedMatches[0].winner;
				tournament.status = 'finished';
				tournament.finishedAt = new Date();

				console.log(`Tournament finished! Winner: ${tournament.winner?.username}`);
				return;
			}

			console.log(`Creating round ${tournament.currentRound + 1}`);
			this.createNextRound(tournament, finishedMatches);
			
			this.startNextMatch(tournamentId);
		}
		else
		{
			this.startNextMatch(tournamentId);
		}
	}

	createNextRound(tournament: Tournament, previousMatches: Match[]): void {
        const nextRound = tournament.currentRound + 1;
        const winners = previousMatches.map(m => m.winner!).filter(Boolean);

        const nextRoundMatches: Match[] = [];
        for (let i = 0; i < winners.length; i += 2)
		{
            if (winners[i + 1])
			{
                const match: Match = {
                    id: uuidv4(),
                    tournamentId: tournament.id,
                    round: nextRound,
                    position: Math.floor(i / 2),
                    player1: winners[i],
                    player2: winners[i + 1],
                    status: 'ready'
                };
                nextRoundMatches.push(match);
            }
        }

        tournament.bracket.push(...nextRoundMatches);
        tournament.currentRound = nextRound;

        console.log(`Round ${nextRound} created with ${nextRoundMatches.length} matches`);
    }

	findMatchById(id: string): Match | null
	{
        for (const tournament of this.tournaments.values()) {
            const match = tournament.bracket.find(m => m.id === id);
            if (match) return match;
        }
        return null;
    }

	getTournamentBrackets(tournamentId: string): Match[] | null
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return null;
		
		return tournament.bracket;
	}

	getTournamentDetails(tournamentId: string): Tournament | null
	{
		const tournament = this.tournaments.get(tournamentId);
		return tournament || null;
	}

	private shuffleArray<T>(array: T[]): T[]
	{
		const shuffled = [...array];

		for (let i = shuffled.length - 1; i > 0; i--)
		{
			const randIdx = Math.floor(Math.random() * (i + 1));
			[shuffled[i], shuffled[randIdx]] = [shuffled[randIdx], shuffled[i]]
		}

		return shuffled
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/chatback/chat/chat.ts
═══════════════════════════════════════════════════════
import Fastify, { FastifyInstance } from 'fastify'
import websocket from '@fastify/websocket'

const connectedClients = new Set<WebSocket>()
const msgHistory: string[] = []
const MAX_HISTORY_SIZE = 50

function broadcastToAll(message: string): void
{
	connectedClients.forEach((client: WebSocket) => {
		if (client.readyState === client.OPEN)
		{
			client.send(message);
		}
	})
}

function addToHistory(msg: string): void
{
	msgHistory.push(msg)

	if (msgHistory.length > MAX_HISTORY_SIZE)
	{
		msgHistory.shift()
	}
}

function sendHistoryToClient(socket: WebSocket): void
{
	if (msgHistory.length > 0)
	{
		msgHistory.forEach(msg => {
			if (socket.readyState === socket.OPEN)
			{
				socket.send(msg)
			}
		})
	}
}

function clearHistoryIfEmpty(): void {
	if (connectedClients.size === 0)
	{
		msgHistory.length = 0
	}
}

export const handleChat = (socket, req, fastify: FastifyInstance) : void => {
	connectedClients.add(socket);
	fastify.log.info(`Clients connected: ${connectedClients.size}`)

	sendHistoryToClient(socket)

	socket.on('message', message =>
		{
			const msgStr = message.toString()
			fastify.log.info(`Message received: ${msgStr}`)

			const formattedMsg = `Client said: ${msgStr}`

			addToHistory(formattedMsg)
			broadcastToAll(formattedMsg)
		}
	)

	socket.on('close', () => {
		connectedClients.delete(socket)
		fastify.log.info(`Client disconnected, ${connectedClients.size} clients left.`)
		clearHistoryIfEmpty()
	})

	socket.on('error', (err) => {
		fastify.log.error('WebSocket error:', err)
		connectedClients.delete(socket)
		clearHistoryIfEmpty()
	})
}



═══════════════════════════════════════════════════════
FILE: ./apps/chatback/server.ts
═══════════════════════════════════════════════════════
import Fastify from 'fastify'
import websocket from '@fastify/websocket'
import { handleChat } from './chat/chat'

const fastify = Fastify({
	logger: true
})

await fastify.register(websocket)

fastify.addHook('onRequest', async (request, reply) => {
    console.log('=== REQUÊTE REÇUE ===')
    console.log('URL:', request.url)
    console.log('Method:', request.method)
    console.log('Headers:', JSON.stringify(request.headers, null, 2))
    console.log('====================')
})

fastify.get('/ws', { websocket: true }, function chatHandler (socket, req)
	{
		handleChat(socket, req, fastify)
	}
)

fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

fastify.listen({ port: 3000, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



