═══════════════════════════════════════════════════════
FILE: ./apps/gameback/server.ts
═══════════════════════════════════════════════════════
import Fastify from 'fastify'
import websocket from '@fastify/websocket'
import { handleGame } from './game/game'
import { setMatchForRoom } from './game/session/session'

const fastify = Fastify({
	logger: true
})

await fastify.register(websocket)

fastify.addHook('onRequest', async (request, reply) => {
    console.log('=== REQUÊTE REÇUE ===')
    console.log('URL:', request.url)
    console.log('Method:', request.method)
    console.log('Headers:', JSON.stringify(request.headers, null, 2))
    console.log('====================')
})

fastify.get('/game/:roomId', { websocket: true }, function gameHandler (connection, _req)
	{
		handleGame(connection, _req, fastify)
	}
)

type CreateBody = {
    roomId: string;
    player1: {id: string; username: string};
    player2: {id: string; username: string};
}

fastify.post('/create', async (request, reply) => {

    console.log('Body:', JSON.stringify(request.body, null, 2));
	const body = request.body as Partial<CreateBody>;
    if (!body?.roomId || !body?.player1?.id || !body?.player2?.id)
    {
        reply.code(400).send({success: false, error: 'Invalid payload'});
        return;
    }
    setMatchForRoom(body.roomId, {
        left: {id: body.player1.id, username: body.player1.username || 'p1'},
        right: {id: body.player2.id, username: body.player2.username || 'p2'}
    }, fastify.log);

    reply.send({success: true});
})

fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

fastify.listen({ port: 3010, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/session/session.ts
═══════════════════════════════════════════════════════
import type { WebSocket, WebsocketHandler } from "@fastify/websocket";
import type { FastifyBaseLogger } from "fastify";
import { GameWorld } from "../engine/world";
import { SERVER_DT, SERVER_TICK_HZ, BROADCAST_HZ } from "../engine/constants";
import type { ClientMessage, ServerMessage } from "../ws/messageTypes";
import { safeParse } from "../ws/messageTypes";

type Role = 'left' | 'right' | 'spectator';
type Player = {id: string; username: string};

class GameSession {
	private log?: FastifyBaseLogger;
	private world = new GameWorld();

	private clients = new Set<WebSocket>();
	private roles = new Map<WebSocket, Role>();
	private leftCtrl?: WebSocket;
	private rightCtrl?: WebSocket;
    
    private expected: {left?: Player; right?: Player} = {};

	private tickTimer?: NodeJS.Timeout;
	private broadcastTimer?: NodeJS.Timeout;

	constructor(private readonly roomId?: string, log?: FastifyBaseLogger) {
		this.startLoops();
		this.log = log;
	}

    setPlayers(players: {left: Player; right: Player}) {
        this.expected.left = players.left;
        this.expected.right = players.right;
        this.log?.info({roomId: this.roomId, players: this.expected}, 'match set');
    }

	addClient(ws: WebSocket, info?: {id?: string; username?: string}) {
		const role = this.assignRole(ws, info?.id);
		this.clients.add(ws);
		this.roles.set(ws, role);
		this.send(ws, {type: 'welcome', side: role});
		this.log?.info({ roomId: this.roomId, role, clients: this.clients.size, playerId: info?.id }, 'client connected');

		ws.on('message', (raw: Buffer) => this.onMessage(ws, raw));
		ws.on('close', () => this.onClose(ws));
		ws.on('error', () => this.onClose(ws));

		if (this.leftCtrl && this.rightCtrl)
		{
			if (this.world.state.isGameOver)
            {
                this.world.restart();
            }
            else
            {
                this.world.startCountdown();
            }
		}
	}

	private assignRole(ws: WebSocket, playerId?: string): Role {
		if (this.expected.left?.id || this.expected.right?.id) 
        {
            if (playerId && this.expected.left?.id === playerId && !this.leftCtrl)
            {
                this.leftCtrl = ws;
                return ('left');
            }
            if (playerId && this.expected.right?.id === playerId && !this.rightCtrl)
            {
                this.rightCtrl = ws;
                return ('right');
            }
            return ('spectator');
        }
        if (!this.leftCtrl)
        {
            this.leftCtrl = ws;
            return ('left');
        }
        if (!this.rightCtrl)
        {
            this.rightCtrl = ws;
            return ('right');
        }
        return ('spectator');
	}

	private onMessage(ws: WebSocket, raw: Buffer) {
		const msg = safeParse<ClientMessage>(raw.toString());
		if (!msg)
		{
			return;
		}
        const role = this.roles.get(ws);
		switch (msg.type) {
			case 'input': {
				if (role === 'left' && ws === this.leftCtrl)
				{
					const intention = msg.up && !msg.down ? -1 : msg.down && !msg.up ? 1 : 0;
                    this.world.applyInput('left', intention);
				}
				else if (role === 'right' && ws === this.rightCtrl)
                {
                    const intention = msg.up && !msg.down ? -1 : msg.down && !msg.up ? 1 : 0;
                    this.world.applyInput('right', intention)
                }
                break;
			}
			case 'smash': {
				const role = this.roles.get(ws);
				if (role === 'left' || role === 'right')
				{
					this.world.pressSmash(role);
				}
				break;
			}
			case 'pause':
				this.world.pause();
				this.broadcast({type: 'paused'});
				break;
			case 'resume': {
				if (this.world.state.isGameOver)
				{
					if (this.leftCtrl && this.rightCtrl)
					{
						this.world.restart();
						this.broadcast({type: 'resumed'});
					}
					else
					{
						this.send(ws, {type: 'error', message: 'Two players required'});
						this.world.restart();
					}
				}
				else
				{
					this.world.resume();
					this.broadcast({type: 'resumed'});
				}
				break;
			}
			case 'ping':
				this.send(ws, {type: 'pong', t: msg.t});
				break;
		}
	}

	private onClose(ws: WebSocket) {
		this.clients.delete(ws);
		const role = this.roles.get(ws);
		this.roles.delete(ws);
		if (this.leftCtrl === ws)
		{
			this.leftCtrl = undefined;
		}
		if (this.rightCtrl === ws)
		{
			this.rightCtrl = undefined;
		}
		this.log?.info({roomId: this.roomId, role}, 'client disconnected');
	}

	private startLoops() {
		this.tickTimer = setInterval(() => {
			this.world.update(SERVER_DT);
		}, Math.round(1000 / SERVER_TICK_HZ));

		this.broadcastTimer = setInterval(() => {
			const state = this.world.publicState();
			this.broadcast({type: 'state', state, serverTime: Date.now()});
			if (state.countdownValue > 0)
			{
				this.broadcast({type: 'countdown', value: state.countdownValue});
			}
			if (state.isGameOver)
			{
				this.broadcast({type: 'gameover', winner: state.winner || 'left'});
			}
		}, Math.round(1000 / BROADCAST_HZ));
	}

	private send(ws: WebSocket | undefined, msg: ServerMessage) {
		if (!ws || ws.readyState !== 1)
		{
			return;
		}
		ws.send(JSON.stringify(msg));
	}

	private broadcast(msg: ServerMessage) {
		for (const c of this.clients)
		{
			this.send(c, msg);
		}
	}
}

const rooms = new Map<string, GameSession>();

export const getSessionForRoom = (roomId: string, log?: FastifyBaseLogger) => {
    if (!rooms.has(roomId))
    {
        rooms.set(roomId, new GameSession(roomId, log));
    }
    return (rooms.get(roomId)!);
}

export const setMatchForRoom = (roomId: string, players: {left: Player; right: Player}, log?: FastifyBaseLogger) => {
    const session = getSessionForRoom(roomId, log);
    session.setPlayers(players);
    return session;
}

let singleton: GameSession | null = null;
export const getSession = (log?: FastifyBaseLogger) => {
	if (!singleton)
	{
		singleton = new GameSession(log);
	}
	return (singleton);
};


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/ws/messageTypes.ts
═══════════════════════════════════════════════════════
export type ClientMessage =
	| {type: 'input'; up: boolean; down: boolean }
	| {type: 'pause'}
	| {type: 'resume'}
	| {type: 'ping'; t: number}
	| {type: 'smash'};

export type ServerMessage = 
	| {type: 'welcome'; side: 'left' | 'right' | 'spectator'}
	| {type: 'state'; state: PublicState; serverTime: number}
	| {type: 'countdown'; value: number}
	| {type: 'paused'}
	| {type: 'resumed'}
	| {type: 'gameover'; winner: 'left' | 'right'}
	| {type: 'pong'; t: number}
	| {type: 'error'; message: string};

export type PublicState = {
	leftPaddle: {y: number; speed: number; intention: number};
	rightPaddle: {y: number; speed: number; intention: number};
	balls: {x: number; y: number; vx: number, vy: number; radius: number}[];
	score: {left: number; right: number;};
	isPaused: boolean;
	isGameOver: boolean;
	winner: '' | 'left' | 'right';
	countdownValue: number;
	powerUps: {x: number; y: number; radius: number}[];
	splitActive: boolean;
	clock: number;

	smash: {
		cooldown: number;
		animDuration: number;
		left: {cooldownRemaining: number; lastSmashAt: number};
		right: {cooldownRemaining: number; lastSmashAt: number};
	};
};

export function safeParse<T>(raw: string): T | null {
	try 
	{
		return JSON.parse(raw) as T;
	}
	catch
	{
		return (null);
	}
}


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/game.ts
═══════════════════════════════════════════════════════
import Fastify, { FastifyInstance, FastifyRequest } from 'fastify'
import type { WebSocket } from 'ws'
import { getSessionForRoom } from './session/session'

export const handleGame = (conn: WebSocket, _req: FastifyRequest, fastify: FastifyInstance) : void => {
	fastify.log.info({ url: _req.url, params: _req.params, query: _req.query }, 'WS connect');
    const {roomId} = (_req.params ?? {}) as {roomId?: string};
    const {playerId, username, playerNumber} = (_req.query ?? {}) as {playerId: string; username: string; playerNumber: string};

    const id = typeof playerId === 'string' ? playerId : undefined;
    const name = typeof username === 'string' ? username : undefined;
    const room = getSessionForRoom(roomId || 'default', fastify.log);
    room.addClient(conn, { id, username: name });
}



═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/world.ts
═══════════════════════════════════════════════════════
import { 
	WORLD_WIDTH, WORLD_HEIGHT, PADDLE_MARGIN, PADDLE_HEIGHT, PADDLE_SPEED,
	PADDLE_SPEED_INCREASE, BALL_INITIAL_SPEED, BALL_SPEED_INCREASE, BALL_MAX_SPEED,
	BALL_RADIUS, SCORE_TO_WIN, PADDLE_MAX_SPEED, SMASH_ANIM_DURATION, SMASH_COOLDOWN,
	SMASH_SPEED_MULTIPLIER, SMASH_TIMING_WINDOW,
	PADDLE_WIDTH} from "./constants";
import type { Ball, GameState, Side } from "./types";
import { clamp } from "./helpers";
import { bounceOnWalls, checkPaddleCollision, resolveBallBallCollision } from "./physics";
import { activateSplit, endSplit, pruneExpiredPowerUps, scheduleNextPowerUp, spawnPowerUp } from "./powerups";
import type { PublicState } from "../ws/messageTypes";

const newBall = (vx: number, vy: number): Ball => ({
	x: WORLD_WIDTH / 2,
	y: WORLD_HEIGHT / 2,
	vx,
	vy,
	radius: BALL_RADIUS,
	lastPaddleHit: ''
});

export class GameWorld {
	state: GameState;

	constructor() {
		this.state = this._freshState();
	}

	private _freshState(): GameState {
		return {
			leftPaddle: {speed: PADDLE_SPEED, y: WORLD_HEIGHT / 2, intention: 0},
			rightPaddle: {speed: PADDLE_SPEED, y: WORLD_HEIGHT / 2, intention: 0},
			balls: [newBall(Math.random() < 0.5 ? -BALL_INITIAL_SPEED : BALL_INITIAL_SPEED, 0)],
			score: {left: 0, right: 0},
			isPaused: false,
			isGameOver: false,
			winner: '',
			clock: 0,
			countdownValue: 0,
			countdownTimer: 0,
			powerUps: [],
			nextPowerUpAt: 5 + Math.random() * 10,
			splitActive: false,
			splitEndsAt: 0,
			smash : {
				left: {availableAt: 0, lastPressAt: -1e9, lastSmashAt: -1e9},
				right: {availableAt: 0, lastPressAt: -1e9, lastSmashAt: -1e9}
			}
		};
	}

	applyInput(side: 'left' | 'right', intention: -1 | 0 | 1) {
		(side === 'left' ? this.state.leftPaddle : this.state.rightPaddle).intention = intention;
	}

	pressSmash(side: Side)
	{
		const sm = this.state.smash[side];
        if (this.state.clock >= sm.availableAt)
        {
            sm.lastSmashAt = this.state.clock;
            sm.availableAt = this.state.clock + SMASH_COOLDOWN;
            sm.lastPressAt = this.state.clock;
        }
	}

	startCountdown() {
		this.state.countdownValue = 3;
		this.state.countdownTimer = 0;
		this.state.isPaused = true;
	}

	pause() {
		if (this.state.countdownValue === 0)
		{
			this.state.isPaused = true;
		}
	}
	
	resume() {
		if (this.state.countdownValue === 0)
		{
			this.startCountdown();
		}
	}

	restart() {
		this.state = this._freshState();
		this.startCountdown();
	}

	update(dt: number) {
		const s = this.state;

		if (s.countdownValue > 0)
		{
			s.countdownTimer += dt;
			if (s.countdownTimer >= 1)
			{
				s.countdownValue--;
				s.countdownTimer = 0;
				if (s.countdownValue <= 0)
				{
					s.isPaused = false;
				}
			}
			return;
		}
		if (s.isPaused || s.isGameOver)
		{
			return;
		}
		s.clock += dt;

		s.leftPaddle.y = clamp(s.leftPaddle.y + s.leftPaddle.intention * s.leftPaddle.speed * dt,
			PADDLE_HEIGHT / 2, WORLD_HEIGHT - PADDLE_HEIGHT / 2);
		s.rightPaddle.y = clamp(s.rightPaddle.y + s.rightPaddle.intention * s.rightPaddle.speed * dt,
			PADDLE_HEIGHT / 2, WORLD_HEIGHT - PADDLE_HEIGHT / 2);
		
		if (s.clock >= s.nextPowerUpAt)
		{
			spawnPowerUp(s);
			scheduleNextPowerUp(s);
		}

		pruneExpiredPowerUps(s);

		const leftX = PADDLE_MARGIN;
		const rightX = WORLD_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;

		for (let i = s.powerUps.length - 1; i >= 0; i--)
		{
			const pu = s.powerUps[i];
			let picked = false;
			for (const b of s.balls)
			{
				const dx = b.x - pu.x;
				const dy = b.y - pu.y;
				if (Math.hypot(dx, dy) <= b.radius + pu.radius)
				{
					s.powerUps.splice(i, 1);
					activateSplit(s, b);
					picked = true;
					break;
				}
			}
			if (picked)
			{
				continue;
			}
		}

		for (const b of s.balls)
		{
			b.x += b.vx * dt;
			b.y += b.vy * dt;
			bounceOnWalls(b);
			if (b.lastPaddleHit === 'left' && b.x - b.radius > leftX + PADDLE_WIDTH + 2)
			{
				b.lastPaddleHit = '';
			}
			if (b.lastPaddleHit === 'right' && b.x + b.radius < rightX - 2)
			{
				b.lastPaddleHit = '';
			}
			const hitL = checkPaddleCollision(b, leftX, s.leftPaddle.y, true);
			const hitR = checkPaddleCollision(b, rightX, s.rightPaddle.y, false);
			if (hitL || hitR)
			{
				const curr = Math.max(1e-6, Math.hypot(b.vx, b.vy));
				let target = Math.min(curr * BALL_SPEED_INCREASE, BALL_MAX_SPEED);

				const side: Side | '' = hitL ? 'left' : hitR ? 'right' : '';
				if (side)
				{
					const sm = s.smash[side];
					const smashRecent = (s.clock - sm.lastSmashAt) <= SMASH_TIMING_WINDOW;
					if (smashRecent)
					{
						target = Math.min(target * SMASH_SPEED_MULTIPLIER, BALL_MAX_SPEED);
					}
				}

				const norm = Math.max(1e-6, Math.hypot(b.vx, b.vy));
				const k = target / norm;
				b.vx *= k;
				b.vy *= k;
				s.leftPaddle.speed = Math.min(s.leftPaddle.speed * PADDLE_SPEED_INCREASE, PADDLE_MAX_SPEED);
				s.rightPaddle.speed = Math.min(s.rightPaddle.speed * PADDLE_SPEED_INCREASE, PADDLE_MAX_SPEED);
			}
		}
		if (s.balls.length > 1)
		{
			for (let i = 0; i < s.balls.length; i++)
			{
				for (let j = i + 1; j < s.balls.length; j++)
				{
					resolveBallBallCollision(s.balls[i], s.balls[j]);
				}
			}
		}
		if (s.splitActive && s.clock >= s.splitEndsAt)
		{
			endSplit(s);
		}
		const removed: number[] = [];
		for (let i = 0; i < s.balls.length; i++)
		{
			const b = s.balls[i];
			if (b.x + b.radius <= 0)
			{
				s.score.right++;
				removed.push(i);
			}
			else if (b.x - b.radius >= WORLD_WIDTH)
			{
				s.score.left++;
				removed.push(i);
			}
		}
		for (let i = removed.length - 1; i >= 0; i--)
		{
			s.balls.splice(removed[i], 1);
		}
		if (s.score.left >= SCORE_TO_WIN || s.score.right >= SCORE_TO_WIN)
		{
			s.isGameOver = true;
			s.isPaused = true;
			s.winner = s.score.left >= SCORE_TO_WIN ? 'left' : 'right';
			return;
		}
		if (s.balls.length === 0)
		{
			s.balls = [newBall((Math.random() < 0.5 ? -1 : 1) * BALL_INITIAL_SPEED, 0)];
			s.leftPaddle.speed = PADDLE_SPEED;
			s.rightPaddle.speed = PADDLE_SPEED;
			s.splitActive = false;
			s.splitEndsAt = 0;
			scheduleNextPowerUp(s);
		}
	}

	publicState(): PublicState {
		const s = this.state;
		return {
			leftPaddle: {...s.leftPaddle},
			rightPaddle: {...s.rightPaddle},
			balls: s.balls.map(({x, y, vx, vy, radius}) => ({x, y, vx, vy, radius})),
			score: {...s.score},
			isPaused: s.isPaused,
			isGameOver: s.isGameOver,
			winner: s.winner,
			countdownValue: s.countdownValue,
			powerUps: s.powerUps.map(({x, y, radius}) => ({x, y, radius})),
			splitActive: s.splitActive,
			clock: s.clock,
			smash: {
				cooldown: SMASH_COOLDOWN,
				animDuration: SMASH_ANIM_DURATION,
				left: {
					cooldownRemaining: Math.max(0, s.smash.left.availableAt - s.clock),
					lastSmashAt: s.smash.left.lastSmashAt
				},
				right: {
					cooldownRemaining: Math.max(0, s.smash.right.availableAt - s.clock),
					lastSmashAt: s.smash.right.lastSmashAt
				}
			}
		};
	}
}


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/physics.ts
═══════════════════════════════════════════════════════
import { PADDLE_HEIGHT, PADDLE_WIDTH, MAX_BOUNCE_DEG, WORLD_HEIGHT, BALL_MAX_SPEED } from "./constants";
import { clamp } from "./helpers";
import type { Ball } from "./types";

export const checkPaddleCollision = (
	ball: Ball,
	paddleX: number,
	paddleY: number,
	isLeftPaddle: boolean
): boolean => {
	const paddleName = isLeftPaddle ? 'left' : 'right';
	if (ball.lastPaddleHit === paddleName)
	{
		return false;
	}

	const speedBefore = Math.max(1e-6, Math.hypot(ball.vx, ball.vy));
	const rectLeft = paddleX;
	const rectRight = paddleX + PADDLE_WIDTH;
	const rectTop = paddleY - PADDLE_HEIGHT / 2;
	const rectBottom = paddleY + PADDLE_HEIGHT / 2;

	const cx = clamp(ball.x, rectLeft, rectRight);
	const cy = clamp(ball.y, rectTop, rectBottom);

	let nx = ball.x - cx;
	let ny = ball.y - cy;

	const r = ball.radius;
	const dist2 = nx * nx + ny * ny;
	if (dist2 > r * r) 
	{
		return false;
	}

	let dist = Math.sqrt(dist2);
	if (dist === 0)
	{
		const midX = (rectLeft + rectRight) / 2;
		const midY = (rectTop + rectBottom) / 2;
		const penX = Math.min(Math.abs(ball.x - rectLeft), Math.abs(rectRight - ball.x));
		const penY = Math.min(Math.abs(ball.y - rectTop), Math.abs(rectBottom - ball.y));
		if (penX < penY)
		{
			nx = ball.x < midX ? -1 : 1;
			ny = 0;
		}
		else
		{
			nx = 0;
			ny = ball.y < midY ? -1 : 1;
		}
		dist = 0;
	}
	else
	{
		nx /= dist;
		ny /= dist;
	}

	const penetration = r - dist + 0.01;
	ball.x += nx * penetration;
	ball.y += ny * penetration;

	const MAX_BOUNCE_RAD = (MAX_BOUNCE_DEG * Math.PI) / 180;
	const rel = clamp((ball.y - paddleY) / (PADDLE_HEIGHT / 2), -1, 1);
	const angle = rel * MAX_BOUNCE_RAD;
	const dir = isLeftPaddle ? 1 : -1;
	ball.vx = Math.cos(angle) * speedBefore * dir;
	ball.vy = Math.sin(angle) * speedBefore;
	ball.lastPaddleHit = paddleName;
	return true;
};

export const resolveBallBallCollision = (a: Ball, b: Ball) => {
	const dx = b.x - a.x;
	const dy = b.y - a.y;
	const dist = Math.max(1e-6, Math.hypot(dx, dy));
	const minDist = a.radius + b.radius;
	if (dist >= minDist)
	{
		return;
	}
	const nx = dx / dist;
	const ny = dy / dist;
	const tx = -ny;
	const ty = nx;
	
	const va_n = a.vx * nx + a.vy * ny;
	const va_t = a.vx * tx + a.vy * ty;
	const vb_n = b.vx * nx + b.vy * ny;
	const vb_t = b.vx * tx + b.vy * ty;

	const va_n_after = vb_n; 
	const vb_n_after = va_n;

	a.vx = va_n_after * nx + va_t * tx;
	a.vy = va_n_after * ny + va_t * ty;
	b.vx = vb_n_after * nx + vb_t * tx;
	b.vy = vb_n_after * ny + vb_t * ty;

	const overlap = minDist - dist + 0.5;
	a.x -= nx * overlap * 0.5;
	a.y -= ny * overlap * 0.5;
	b.x += nx * overlap * 0.5;
	b.y += ny * overlap * 0.5;
};

export const bounceOnWalls = (b: Ball) => {
	if (b.y - b.radius <= 0)
	{
		b.y = b.radius;
		b.vy = Math.abs(b.vy);
	}
	else if (b.y + b.radius >= WORLD_HEIGHT)
	{
		b.y = WORLD_HEIGHT - b.radius;
		b.vy = -Math.abs(b.vy);
	}
};


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/types.ts
═══════════════════════════════════════════════════════
export type Side = 'left' | 'right';

export type Ball = {
	x: number;
	y: number;
	vx: number;
	vy: number;
	radius: number;
	lastPaddleHit: '' | 'left' | 'right';
};

export type PowerUp = {
	id: number;
	x: number;
	y: number;
	radius: number;
	expiresAt: number;
};

export type SmashSideState = {
	availableAt: number;
	lastPressAt: number;
	lastSmashAt: number;
};

export type GameState = {
	leftPaddle: {speed: number; y: number; intention: number};
	rightPaddle: {speed: number; y: number; intention: number};
	balls: Ball[];
	score: { left: number; right: number};
	isPaused: boolean;
	isGameOver: boolean;
	winner: '' | 'left' | 'right';
	clock: number;
	countdownValue: number;
	countdownTimer: number;
	powerUps: PowerUp[];
	nextPowerUpAt: number;
	splitActive: boolean;
	splitEndsAt: number;

	smash: {
		left: SmashSideState;
		right: SmashSideState;
	}
};


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/powerups.ts
═══════════════════════════════════════════════════════
import { WORLD_WIDTH, WORLD_HEIGHT, POWERUP_MIN_DELAY_SEC,
	POWERUP_EXTRA_RANDOM_SEC, POWERUP_LIFETIME_SEC, SPLIT_DURATION_SEC, 
	POWERUP_RADIUS, MAX_BALLS_ON_FIELD, SPLIT_SPAWN_PER_PICKUP, SPLIT_SPREAD_DEG,
	POWERUP_MAX_ON_SCREEN} from "./constants";
import { length2, scheduleAfter } from "./helpers";
import type { Ball, GameState } from "./types";

let PU_ID = 1;

export const scheduleNextPowerUp = (state: GameState) => {
	state.nextPowerUpAt = scheduleAfter(state.clock, POWERUP_MIN_DELAY_SEC, POWERUP_EXTRA_RANDOM_SEC);
};

export const spawnPowerUp = (state: GameState) => {
	if (state.powerUps.length >= POWERUP_MAX_ON_SCREEN)
	{
		return;
	}
	const margin = 150;
	state.powerUps.push({
		id: PU_ID++,
		x: margin + Math.random() * (WORLD_WIDTH - 2 * margin),
		y: margin + Math.random() * (WORLD_HEIGHT - 2 * margin),
		radius: POWERUP_RADIUS,
		expiresAt: state.clock + POWERUP_LIFETIME_SEC
	});
};

export const pruneExpiredPowerUps = (state: GameState) => {
	state.powerUps = state.powerUps.filter(p => p.expiresAt > state.clock);
}

export const activateSplit = (state: GameState, fromBall?: Ball) => {
	const spreadRad = (SPLIT_SPREAD_DEG * Math.PI) / 180;
	state.splitActive = true;
	state.splitEndsAt = Math.max(state.splitEndsAt, state.clock + SPLIT_DURATION_SEC);
	if (state.balls.length === 0)
	{
		return ;
	}
	const canAdd = Math.max(0, MAX_BALLS_ON_FIELD - state.balls.length);
	const toAdd = Math.min(SPLIT_SPAWN_PER_PICKUP, canAdd);
	if (toAdd <= 0)
	{
		return;
	}
	const src = fromBall ?? state.balls[0];
	const speed = Math.max(1e-6, length2(src.vx, src.vy));
	const base = Math.atan2(src.vy, src.vx);

	const makeAtAngle = (angle : number): Ball => ({
		...src,
		vx: Math.cos(angle) * speed,
		vy: Math.sin(angle) * speed,
		lastPaddleHit: src.lastPaddleHit
	});

	for (let i = 0; i < toAdd; i++)
	{
		const offset = (Math.random() * 2 - 1) * spreadRad;
		state.balls.push(makeAtAngle(base + offset));
	}
};

export const endSplit = (state: GameState) => {
	state.splitActive = false;
	if (state.balls.length > 1)
	{
		let keep = 0;
		let best = -Infinity;
		for (let i = 0; i < state.balls.length; i++)
		{
			const k = Math.abs(state.balls[i].vx);
			if (k > best)
			{
				best = k;
				keep = i;
			}
		}
		state.balls = [state.balls[keep]];
		scheduleNextPowerUp(state);
	}
};


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/helpers.ts
═══════════════════════════════════════════════════════
export const clamp = (v: number, min: number, max: number) =>
	Math.max(min, Math.min(max, v));
export const length2 = (x: number, y: number) => Math.sqrt(x * x + y * y);
export const scheduleAfter = (now: number, min: number, rand: number) =>
	now + min + Math.random() * rand;


═══════════════════════════════════════════════════════
FILE: ./apps/gameback/game/engine/constants.ts
═══════════════════════════════════════════════════════
export const WORLD_WIDTH = 1920
export const WORLD_HEIGHT = 1080;

export const PADDLE_WIDTH = 15;
export const PADDLE_HEIGHT = 100;
export const PADDLE_MARGIN = 30;
export const PADDLE_SPEED = 400;
export const PADDLE_SPEED_INCREASE = 1.05;
export const PADDLE_MAX_SPEED = 1600;


export const BALL_RADIUS = 15;
export const BALL_INITIAL_SPEED = 600;
export const BALL_SPEED_INCREASE = 1.05;
export const BALL_MAX_SPEED = 1500;
export const MAX_BOUNCE_DEG = 45;

export const SCORE_TO_WIN = 11;

export const POWERUP_RADIUS = 35;
export const POWERUP_MIN_DELAY_SEC = 6;
export const POWERUP_EXTRA_RANDOM_SEC = 6;
export const POWERUP_LIFETIME_SEC = 9;
export const SPLIT_DURATION_SEC = 10;
export const POWERUP_MAX_ON_SCREEN = 5;

export const MAX_BALLS_ON_FIELD = 10;
export const SPLIT_SPAWN_PER_PICKUP = 1;
export const SPLIT_SPREAD_DEG = 20;

export const SMASH_COOLDOWN = 3;
export const SMASH_TIMING_WINDOW = 0.2;
export const SMASH_SPEED_MULTIPLIER = 1.6;
export const SMASH_ANIM_DURATION = 0.12;

export const SERVER_TICK_HZ = 240;
export const SERVER_DT = 1 / SERVER_TICK_HZ;
export const BROADCAST_HZ = 240;


═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/TounamentQuickPlay.ts
═══════════════════════════════════════════════════════
import { FastifyInstance } from 'fastify'
import { RoomManager } from './RoomManager'
import { Player, ClientMessage, ServerMessage } from './types'
import { v4 as uuidv4 } from 'uuid'


export function handleTournamentQuickPlay(fastify: FastifyInstance)
{
	fastify.post('/tournament-match', (connection, request) => {

	})
}



═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/server.ts
═══════════════════════════════════════════════════════
import Fastify from 'fastify'
import websocket from '@fastify/websocket'
import { handleQuickPlay } from './quickplay'
import { handleTournamentQuickPlay } from './TounamentQuickPlay'

const fastify = Fastify({
	logger: true
})

await fastify.register(websocket)

fastify.addHook('onRequest', async (request, reply) => {
    console.log('=== REQUÊTE REÇUE ===')
    console.log('URL:', request.url)
    console.log('Method:', request.method)
    console.log('Headers:', JSON.stringify(request.headers, null, 2))
    console.log('====================')
})


fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

handleQuickPlay(fastify);
handleTournamentQuickPlay(fastify)

fastify.listen({ port: 3030, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/types.ts
═══════════════════════════════════════════════════════
export interface Player
{
	id: string;
	username: string;
	socket: any;
	roomId ?: string;
	isReady: boolean;
}

export interface Room
{
	id: string;
	players: Player[];
	status: 'waiting' | 'playing' | 'finished';
	createdAt: Date;
}

export type ClientMessage = 
	| { type : 'join_quickplay'; username: string }
	| { type : 'player_ready' }
	| { type : 'player_input' ; input: any};

export type ServerMessage = 
	| { type: 'waiting_for_opponent' }
	| { type: 'game_start'; roomId: string; playerNumber: 1 | 2 }
	| { type: 'opponent_disconnected' }
	| { type: 'error'; message: string }



═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/quickplay.ts
═══════════════════════════════════════════════════════
import { FastifyInstance } from 'fastify'
import { RoomManager } from './RoomManager'
import { Player, ClientMessage, ServerMessage } from './types'
import { v4 as uuidv4 } from 'uuid'

export const roomManager = new RoomManager()

const isDevelopment = process.env.NODE_ENV === 'development'
const agent = isDevelopment ? new https.Agent({ rejectUnauthorized: false }) : undefined

export function handleQuickPlay(fastify: FastifyInstance)
{
	fastify.get('/ws', { websocket: true }, (connection, request) => {
		console.log(`New WebSocket connexion /quickplay/ws`)

		let currentPlayer: Player | null = null

		connection.on('message', (rawMessage) => {
			try
			{
				const msg: ClientMessage = JSON.parse(rawMessage.toString())
				console.log(`Message received: `, msg)

				switch (msg.type)
				{
					case 'join_quickplay':
						handleJoinQuickplay(msg.username)
						break
					case 'player_ready':
						handlePlayerReady()
						break
					case 'player_input':
						handlePlayerInput(msg.input)
						break
					default:
						sendError(`Unknown message type`)
				}
			}
			catch (err)
			{
				console.log(`Parse error:`, err)
				sendError(`Invalid input`)
			}
		})

		connection.on('close', () => {
			console.log(`Disconnection of ${currentPlayer?.username || 'unknown player'}`)
			if (currentPlayer)
			{
				roomManager.removePlayerFromRoom(currentPlayer)
				roomManager.debugRooms();
			}
		})

		async function handleJoinQuickplay(username: string)
		{
			if (currentPlayer)
			{
				sendError(`You are in the room already`)
				return
			}

			currentPlayer = {
				id: uuidv4(),
				username: username,
				socket: connection,
				isReady: false
			}

			console.log(`New player: ${username} (${currentPlayer.id})`)

			const room = roomManager.findOrCreateRoom(currentPlayer)

			if (room.status === `waiting`)
			{
				sendMessage({ type: `waiting_for_opponent`})
				console.log(`${username} is waiting for opposant in room ${room.id}`)
			}
			else if (room.status === `playing`)
			{
				const player1 = room.players[0]
				const player2 = room.players[1]

				const host = process.env.VITE_HOST
				const create_endpoint = process.env.VITE_CREATEGAME_ENDPOINT
				const game_endpoint = process.env.VITE_GAME_ENDPOINT
				const fetchURL = (host && create_endpoint) ? `https://${host}${create_endpoint}`
								: `https://localhost:8443/gameback/create`
				try {
					console.log(fetchURL)
					await fetch(fetchURL, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							roomId: room.id,
							player1: { id: player1.id, username: player1.username },
							player2: { id: player2.id, username: player2.username },
						}),
						agent: agent
					})
					console.log(`Game initialized in gameback for room ${room.id}`)
				} 
				catch (err)
				{
					console.log(`failed to initialize room ${room.id}`, err)
				}
                const baseGameWs = (host && game_endpoint) ? 
                                        `wss://${host}${game_endpoint}/${room.id}` :
                                        `wss://localhost:8443/gameback/game/${room.id}`;
                const urlFor = (p: Player) => `${baseGameWs}?playerId=${encodeURIComponent(p.id)}&username=${encodeURIComponent(p.username)}`

				player1.socket.send(JSON.stringify({
					type: `game_start`,
					roomId: room.id,
					playerNumber: 1,
					gameServerURL: urlFor(player1)
				}))

				player2.socket.send(JSON.stringify({
					type: `game_start`,
					roomId: room.id,
					playerNumber: 2,
					gameServerURL: urlFor(player2)
				}))

				console.log(`Game starde in room ${room.id}!`)
				console.log(`- Player 1: ${player1.username}`)
				console.log(`- Player 2: ${player2.username}`)
			}

			roomManager.debugRooms()
		}

		function handlePlayerReady()
		{
			if (!currentPlayer)
			{
				sendError(`You must join a game first to be ready`)
				return
			}

			currentPlayer.isReady = true
			console.log(`${currentPlayer.username} is ready`)
		}

		function handlePlayerInput(input: any)
		{
			if (!currentPlayer || !currentPlayer.roomId)
			{
				sendError(`You are not in a game session`)
				return
			}
			console.log(`Input of ${currentPlayer.username}: `, input)

			// TODO
		}

		function sendMessage(message: ServerMessage)
		{
			try
			{
				connection.send(JSON.stringify(message))
			}
			catch (err)
			{
				console.error(`Response sending error:`, err)
			}
		}

		function sendError(errorMessage: string)
		{
			sendMessage({ type: 'error', message: errorMessage })
		}
	})
}



═══════════════════════════════════════════════════════
FILE: ./apps/quickplayback/RoomManager.ts
═══════════════════════════════════════════════════════
import type { Room, Player } from "./types";
import { v4 as uuidv4 } from 'uuid'

export class RoomManager
{
	private rooms: Map<string, Room> = new Map();
	private waitingRoom: Room | null = null

	public findOrCreateRoom(player: Player) : Room
	{
		if (this.waitingRoom && this.waitingRoom.players.length === 1)
		{
			this.waitingRoom.players.push(player)
			player.roomId = this.waitingRoom.id

			const completedRoom = this.waitingRoom
			this.waitingRoom = null
			completedRoom.status = 'playing'

			console.log(`Room ${completedRoom.id} is complete with 2 players`)
			return completedRoom
		}

		const newRoom: Room = {
			id: uuidv4(),
			players: [player],
			status: 'waiting',
			createdAt: new Date()
		}

		player.roomId = newRoom.id
		this.rooms.set(newRoom.id, newRoom)
		this.waitingRoom = newRoom

		console.log(`Created new room ${newRoom.id}, waiting for a second player...`)
		return newRoom
	}

	public getRoom(roomId: string): Room | undefined
	{
		return (this.rooms.get(roomId))
	}

	public removePlayerFromRoom(player: Player): void
	{
		if (!player.roomId) return

		const room = this.rooms.get(player.roomId)
		if (!room) return

		room.players = room.players.filter(p => p.id !== player.id)
		console.log(`Player ${player.username} removed from the room`)

		if (room.players.length === 0 && room.status === 'waiting')
		{
			this.rooms.delete(room.id)
			if (this.waitingRoom?.id === room.id)
			{
				this.waitingRoom = null
			}
			console.log(`Room ${room.id} deleted (empty)`)
		}
		else if (room.players.length === 1)
		{
			const remainingPlayer = room.players[0]
			this.sendToPlayer(remainingPlayer, { type: 'opponent_disconnected' })

			room.status = 'waiting'
			this.waitingRoom = room
			console.log(`Room ${room.id} waiting for a new player (one disconnected)`)
		}
	}

	private sendToPlayer(player: Player, message: any): void
	{
		try
		{
			player.socket.send(JSON.stringify(message))
		}
		catch (err)
		{
			console.error(`Error while sending message to ${player.username}:`, err)
		}
	}

	public broadcastToRoom(roomId: string, message: any): void
	{
		const room = this.rooms.get(roomId)
		if (!room) return

		room.players.forEach(player => {
			this.sendToPlayer(player, message)
		})
	}

	public debugRooms(): void
	{
		console.log('=== ÉTAT DES ROOMS ===');
		console.log(`Rooms actives: ${this.rooms.size}`);
		console.log(`Room en attente: ${this.waitingRoom?.id || 'aucune'}`);
		this.rooms.forEach(room => {
		console.log(`Room ${room.id}: ${room.players.length} joueurs, status: ${room.status}`);
		});
		console.log('=====================');
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/types/index.ts
═══════════════════════════════════════════════════════
export interface Game
{
	id?: number;
	player1_name: string;
	player2_name: string;
	player1_score: number;
	player2_score: number;
	duration: number; // secondes
	status: 'active' | 'finished';
	started_at?: string;
	finished_at?: string | null;
}

export interface CreateGameRequest
{
	player1_name: string;
	player2_name: string;
}

export interface UpdateGameRequest
{
	player1_score?: number;
	player2_score?: number;
	duration?: number;
	status?: 'active' | "finished";
	finished_at?: string;
}

export interface GlobalMessage
{
	id?: number;
	username: string;
	content: string;
	timestamp?: string;
}

export interface GameMessage
{
	id?: number;
	game_id: number;
	username: string;
	content: string;
	timestamp?: string;
}

export interface CreateMessageRequest
{
	username: string;
	content: string;
}

export interface CreateGameMessageRequest extends CreateMessageRequest
{
	game_id: number;
}

export interface ApiResponse<T>
{
	success: boolean;
	data?: T;
	error?: string;
}

export interface PaginatedResponse<T>
{
	success: boolean;
	data: T[];
	pagination: {
		total: number;
		page: number;
		limit: number;
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/database/connection.ts
═══════════════════════════════════════════════════════
import * as sqlite3 from 'sqlite3';
import * as path from 'path';
import * as fs from 'fs';
import { rejects } from 'assert';

interface DatabaseInterface {
	connect(): Promise<void>;
	init(): Promise<void>;
	getDb(): sqlite3.Database;
}

class Database implements DatabaseInterface
{
	private db: sqlite3.Database | null = null;

	async connect(): Promise<void> 
	{
		const dbPath = path.join(__dirname, '../../data/transcendence.db');

		const dataDir = path.dirname(dbPath)
		if (!fs.existsSync(dataDir))
		{
			fs.mkdirSync(dataDir, {recursive: true})
		}

		return new Promise((resolve, reject) => {
			this.db = new sqlite3.Database(dbPath, (err: Error | null) => {
				if (err)
				{
					reject(err);
				}
				else
				{
					console.log('Connected to SQlite db');
					resolve();
				}
			})
		})
	}

	async init(): Promise<void>
	{
		if (!this.db)
		{
			throw new Error('Db not connected.');
		}

		const schemaPath = path.join(__dirname, 'schema.sql')
		const schema = fs.readFileSync(schemaPath, 'utf8')

		return new Promise((resolve, reject) => {
			this.db!.exec(schema, (err: Error | null) => {
				if (err)
				{
					reject(err)
				}
				else
				{
					console.log('Db schema initialized')
					resolve()
				}
			})
		})
	}

	getDb(): sqlite3.Database {
		if (!this.db)
		{
			throw new Error('Db not connected.');
		}
		return this.db
	}
}

export default new Database;



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/server.ts
═══════════════════════════════════════════════════════
import Fastify, { FastifyInstance } from 'fastify'
import cors from '@fastify/cors'
import database from './database/connection'

const fastify: FastifyInstance = Fastify({
	logger: true
})

fastify.register(cors, {
	origin: true,
	credentials: true
})

declare module 'fastify'
{
	interface FastifyInstance
	{
		db: import('sqlite3').Database
	}
}

fastify.register(require('./routes/games'), { prefix: '/api/games' })
fastify.register(require('./routes/messages'), { prefix: '/api/messages' })

fastify.get('/health', async (request, reply) => {
	return {
		status: 'ok',
		timestamp: new Date().toISOString(),
		service: 'database'
	}
})

fastify.setErrorHandler((error, request, reply) => {
	fastify.log.error(error)
	reply.status(500).send({
		success: false,
		error: 'Internal server error'
	})
})

const start = async (): Promise<void> => {
	try
	{
		await database.connect()
		await database.init()

		// Adding db to fastify instance
		fastify.decorate('db', database.getDb())

		await fastify.listen({
			port: 3020,
			host: '0.0.0.0'
		})
		console.log('Database API service running on port 3020')
	}
	catch (err)
	{
		fastify.log.error(err)
		process.exit(1)
	}
}

process.on('SIGINT', async () => {
	console.log('Shutting down database API service...')
	await fastify.close()
	process.exit()
})

start()



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/routes/messages.ts
═══════════════════════════════════════════════════════
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { 
  GlobalMessage, 
  GameMessage, 
  CreateMessageRequest,
  CreateGameMessageRequest,
  ApiResponse 
} from '../types';

async function messagesRoutes(fastify: FastifyInstance) {

  // GET /api/messages/global => Recuperer les messages global
	fastify.get('/global', async (request: FastifyRequest<{ 
		Querystring: { limit?: string } 
	}>, reply: FastifyReply) => {
		const limit = parseInt(request.query.limit || '50');
		
		return new Promise<ApiResponse<GlobalMessage[]>>((resolve, reject) => {
		const query = 'SELECT * FROM global_messages ORDER BY timestamp DESC LIMIT ?';
		
		fastify.db.all(query, [limit], (err, rows: GlobalMessage[]) => {
			if (err)
			{
				fastify.log.error(err);
				reply.status(500);
				resolve({ success: false, error: 'Database error' });
			}
			else
			{
				resolve({ success: true, data: rows.reverse() });
			}
		});
		});
	});

	// POST /api/messages/global => Poster un message global
	fastify.post('/global', async (request: FastifyRequest<{ 
		Body: CreateMessageRequest 
	}>, reply: FastifyReply) => {
		const { username, content } = request.body;
		
		return new Promise<ApiResponse<GlobalMessage>>((resolve, reject) => {
		const query = 'INSERT INTO global_messages (username, content) VALUES (?, ?)';
		
		fastify.db.run(query, [username, content], function(err) {
			if (err)
			{
				fastify.log.error(err);
				reply.status(500);
				resolve({ success: false, error: 'Failed to create message' });
			}
			else
			{
				const selectQuery = 'SELECT * FROM global_messages WHERE id = ?';
				fastify.db.get(selectQuery, [this.lastID], (err, row: GlobalMessage) => {
					if (err)
					{
						reply.status(500);
						resolve({ success: false, error: 'Message created but failed to retrieve' });
					}
					else
					{
						reply.status(201);
						resolve({ success: true, data: row });
					}
				});
			}
		});
		});
	});

	// GET /api/messages/game/:gameId => Recup les messages d'une partie
	fastify.get('/game/:gameId', async (request: FastifyRequest<{ 
		Params: { gameId: string } 
	}>, reply: FastifyReply) => {
		const { gameId } = request.params;
		
		return new Promise<ApiResponse<GameMessage[]>>((resolve, reject) => {
			const gameQuery = 'SELECT finished_at FROM games WHERE id = ? AND status = "finished"';
			
			fastify.db.get(gameQuery, [gameId], (err, game: { finished_at?: string }) => {
				if (err)
				{
					fastify.log.error(err);
					reply.status(500);
					resolve({ success: false, error: 'Database error' });
					return;
				}
				
				if (game?.finished_at)
				{
					const finishedTime = new Date(game.finished_at).getTime();
					const now = Date.now();
					const tenMinutes = 10 * 60 * 1000;
					
					if (now - finishedTime > tenMinutes)
					{
						resolve({ success: true, data: [] });
						return;
					}
				}
				
				const messagesQuery = 'SELECT * FROM game_messages WHERE game_id = ? ORDER BY timestamp ASC';
				fastify.db.all(messagesQuery, [gameId], (err, rows: GameMessage[]) => {
					if (err)
					{
						fastify.log.error(err);
						reply.status(500);
						resolve({ success: false, error: 'Database error' });
					}
					else
					{
						resolve({ success: true, data: rows });
					}
				});
			});
		});
	});

	// POST /api/messages/game/:gameId - Poster un message dans une partie
	fastify.post('/game/:gameId', async (request: FastifyRequest<{ 
		Params: { gameId: string },
		Body: CreateMessageRequest 
	}>, reply: FastifyReply) => {
		const { gameId } = request.params;
		const { username, content } = request.body;
		
		return new Promise<ApiResponse<GameMessage>>((resolve, reject) => {
			const query = 'INSERT INTO game_messages (game_id, username, content) VALUES (?, ?, ?)';
			
			fastify.db.run(query, [gameId, username, content], function(err) {
				if (err)
				{
					fastify.log.error(err);
					reply.status(500);
					resolve({ success: false, error: 'Failed to create message' });
				}
				else
				{
					const selectQuery = 'SELECT * FROM game_messages WHERE id = ?';
					fastify.db.get(selectQuery, [this.lastID], (err, row: GameMessage) => {
						if (err)
						{
							reply.status(500);
							resolve({ success: false, error: 'Message created but failed to retrieve' });
						}
						else
						{
							reply.status(201);
							resolve({ success: true, data: row });
						}
					});
				}
			});
		});
	});
}

module.exports = messagesRoutes;



═══════════════════════════════════════════════════════
FILE: ./apps/database/src/routes/games.ts
═══════════════════════════════════════════════════════
import {
	FastifyInstance,
	FastifyRequest,
	FastifyReply
} from 'fastify'
import {
	Game,
	CreateGameRequest,
	UpdateGameRequest,
	ApiResponse
} from '../types'

async function gamesRoutes(fastify: FastifyInstance)
{
	interface SqliteRunResult
	{
		lastID: number;
		changes: number;
	}

	// GET /api/games => GET toutes les parties
	fastify.get('/', async (request: FastifyRequest, reply: FastifyReply) => {
		return new Promise<ApiResponse<Game[]>>((resolve, reject) => {
			const query = 'SELECT * FROM games ORDER BY started_at DESC'

			fastify.db.all(query, (err, rows: Game[]) => {
				if (err)
				{
					fastify.log.error(err);
					reply.status(500);
					resolve({ success: false, error: 'Database error' });
				}
				else 
				{
					resolve({ success: true, data: rows });
				}
			})
		})
	})

	// GET /api/games/:id => GET une partie via id
	fastify.get('/:id', async (request: FastifyRequest<{ Params : {id: string} }>,
		reply: FastifyReply) => {
		const { id } = request.params

		return new Promise<ApiResponse<Game>>((resolve, reject) => {
			const query = 'SELECT * FROM games WHERE id = ?'

			fastify.db.get(query, [id], (err, row: Game) => {
				if (err)
				{
					fastify.log.error(err)
					reply.status(500)
					resolve({success: false, error: 'Database error'})
				}
				else if (!row)
				{
					reply.status(404)
					resolve({success: false, error: 'Game not found'})
				}
				else
				{
					resolve({success: true, data: row})
				}
			})
		})
	})

	// POST /api/games => Creer une nouvelle partie
	fastify.post('/', async (request: FastifyRequest<{ Body: CreateGameRequest }>,
		reply: FastifyReply) => {
		const { player1_name, player2_name } = request.body

		return new Promise<ApiResponse<Game>>((resolve, reject) => {
			const query = `
				INSERT INTO games (player1_name, player2_name, player1_score, player2_score, duration, status)
				VALUES (?, ?, 0, 0, 0, 'active')
			`

			fastify.db.run(query, [player1_name, player2_name], function (this: SqliteRunResult, err: Error) {
				if (err)
				{
					fastify.log.error(err)
					reply.status(500)
					resolve({success: false, error: 'Failed to create game'})
				}
				else
				{
					const selectedQuery = 'SELECT * FROM games WHERE is = ?'
					fastify.db.get(selectedQuery, [this.lastID], (err, row: Game) => {
						if (err)
						{
							reply.status(500)
							resolve({success: false, error: 'Game created but failed to retrieve'})
						}
						else
						{
							reply.status(201)
							resolve({success: true, data: row})
						}
					})
				}
			})
		})
	})

	// PUT /api/games/:id => Mettre a jour une partie
	fastify.put('/:id', async (request: FastifyRequest<{
		Params: {id: string}
		Body: UpdateGameRequest
	}>, reply: FastifyReply) => {
		const { id } = request.params
		const updates = request.body

		const fields = Object.keys(updates).map(key => `${key} = ?`).join(', ')
		const values = Object.values(updates)

		if (fields.length === 0)
		{
			reply.status(400)
			return {success: false, error: 'No fields to update'}
		}

		return new Promise<ApiResponse<Game>>((resolve, reject) => {
			const query = `UPDATE games SET ${fields} WHERE id = ?`

			fastify.db.run(query, [...values, id], function(this: SqliteRunResult, err: Error) {
				if (err)
				{
					fastify.log.error(err)
					reply.status(500)
					resolve({success: false, error: 'Failed to update game'})
				}
				else if (this.changes === 0)
				{
					reply.status(404)
					resolve({success: false, error: 'Game not found'})
				}
				else
				{
					const selectQuery = `SELECT * FROM games WHERE id = ?`
					fastify.db.get(selectQuery, [id], (err, row: Game) => {
						if (err)
						{
							reply.status(500)
							resolve({success: false, error: 'Game updated but failed to retrieve'})
						}
						else 
						{
							resolve({success: true, data: row})
						}
					})
				}
			})
		})
	})
}

module.exports = gamesRoutes;



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/vite.config.ts
═══════════════════════════════════════════════════════
import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
	server: {
		host: '0.0.0.0',
		port: 5173,
		allowedHosts: true
	},
	plugins: [
		tailwindcss(),
	],
})



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/simpleAuth/SimpleAuth.ts
═══════════════════════════════════════════════════════
import { v4 as uuidv4 } from 'uuid'

class CookieManager {
    static setCookie(name: string, value: string | null, days: number = 7): void
	{
        const expires = new Date();
        expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Strict`;
    }

    static getCookie(name: string): string | null
	{
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++)
		{
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }

    static deleteCookie(name: string): void
	{
        document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
    }
}

export class SimpleAuth
{
    private static readonly COOKIE_NAME = 'player_session';
    private playerId: string | null;

    constructor()
	{
        this.playerId = this.getOrCreatePlayerId();
    }

    private getOrCreatePlayerId(): string | null
	{
        let playerId = CookieManager.getCookie(SimpleAuth.COOKIE_NAME);
        
        if (!playerId)
		{
            playerId = uuidv4();
            CookieManager.setCookie(SimpleAuth.COOKIE_NAME, playerId, 30);
            console.log('New player ID created:', playerId);
        }
		else
		{
            console.log('Existing player ID found:', playerId);
        }
        
        return playerId;
    }

    getPlayerId(): string | null
	{
        return this.playerId;
    }

    renewSession(): void
	{
        CookieManager.setCookie(SimpleAuth.COOKIE_NAME, this.playerId, 30);
    }

    logout(): void
	{
        CookieManager.deleteCookie(SimpleAuth.COOKIE_NAME);
        this.playerId = uuidv4();
        CookieManager.setCookie(SimpleAuth.COOKIE_NAME, this.playerId, 30);
    }
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/PongGame.ts
═══════════════════════════════════════════════════════
import type { Component } from "./types";
import { WSClient, type PublicState } from "../net/wsClient";
import { Button } from "./Button";

export class PongGame implements Component {
	private el: HTMLElement;
	private canvas: HTMLCanvasElement;
	private ctx: CanvasRenderingContext2D;
	private startBtn: HTMLButtonElement;
	private net = new WSClient();

	private state: PublicState = {
		leftPaddle: {y: 1080 / 2, speed: 0, intention: 0},
		rightPaddle: {y: 1080 / 2, speed: 0, intention: 0},
		balls: [],
		score: {left: 0, right: 0},
		isPaused: true,
		isGameOver: false,
		winner: '',
		countdownValue: 0,
		powerUps: [],
		splitActive: false,
		clock: 0,
		smash: {
			cooldown: 0,
			animDuration: 0.12,
			left: {cooldownRemaining: 0, lastSmashAt: -1e9},
			right: {cooldownRemaining: 0, lastSmashAt: -1e9}
		}
	};

	private WORLD_WIDTH = 1920;
	private WORLD_HEIGHT = 1080;
	private PADDLE_WIDTH = 15;
	private PADDLE_HEIGHT = 100;
	private PADDLE_MARGIN = 30;

	private onResize = () => {

	};

	private onKeyDown = (e: KeyboardEvent) => {
		switch (e.key) {
			case 'w':
			case 'W':
				this.keys.w = true;
				break;
			case 's':
			case 'S':
				this.keys.s = true;
				break;
			case 'ArrowUp':
				this.keys.up = true;
				e.preventDefault();
				break;
			case 'ArrowDown':
				this.keys.down = true;
				e.preventDefault();
				break;
			case ' ':
				this.net.smash();
				e.preventDefault();
				break;
			case 'p':
			case 'P':
			case 'Escape':
				if (this.state.isPaused)
					this.net.resume();
				else
					this.net.pause();
				e.preventDefault();
				break;
		}
		this.sendIntent();
	};

	private onKeyUp = (e: KeyboardEvent) => {
		switch (e.key) {
			case 'w':
			case 'W':
				this.keys.w = false;
				break;
			case 's':
			case 'S':
				this.keys.s = false;
				break;
			case 'ArrowUp':
				this.keys.up = false;
				break;
			case 'ArrowDown':
				this.keys.down = false;
				break;
		}
		this.sendIntent();
	};

	private keys = { w: false, s: false, up: false, down: false };
	private animationFrameId: number | null = null;

	constructor(element: HTMLElement) {
		this.el = element;

		const canvas = this.el.querySelector('#pong-canvas') as HTMLCanvasElement | null;
		const startBtn = this.el.querySelector('#startBtn') as HTMLButtonElement | null;
		if (!canvas || !startBtn)
		{
			throw new Error('PongGame: canvas or button not found in the component.');
		}
		this.canvas = canvas;
		const ctx = this.canvas.getContext('2d');
		if (!ctx)
		{
			throw new Error('PongGame: 2D context not found.');
		}
		this.ctx = ctx;
		this.startBtn = startBtn;

		this.net.onState = (s) => {
			Object.assign(this.state, s);
			this.render();
		};
		this.net.onCountdown = (v) => {
			this.state.countdownValue = v;
			this.render();
		};
		this.net.onGameOver = () => {
			this.startBtn.textContent = 'Replay';
			this.render();
		};
        const storedUrl = sessionStorage.getItem('gameWsURL');
        if (storedUrl)
        {
            this.net.connect(storedUrl);
        }
        else
        {
            const host = import.meta.env.VITE_HOST;
            const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
            const roomId = window.location.pathname.split('/').pop();
            const fallback = (host && endpoint && roomId) ? `wss://${host}${endpoint}/${roomId}` : undefined;
            this.net.connect(fallback);
        }

		this.startBtn.addEventListener('click', this.handleStartClick);

		window.addEventListener('resize', this.onResize);
   		window.addEventListener('keydown', this.onKeyDown);
    	window.addEventListener('keyup', this.onKeyUp);

		this.setupCanvas();
    	this.render();
		this.startAnimationLoop();
	}

	private startAnimationLoop() {
		const animate = () => {
			this.render();
			this.animationFrameId = requestAnimationFrame(animate);
		};
		animate();
	}

	private smashOffsetX(side: 'left' | 'right'): number {
		const smash = this.state.smash;
		if (!smash)
		{
			return (0);
		}
		const last = side === 'left' ? smash.left.lastSmashAt : smash.right.lastSmashAt;
		const dur = smash.animDuration;
		const dt = Math.max(0, this.state.clock - last);
		if (dt <= 0 || dt > dur)
		{
			return (0);
		}
		const t = dt / dur;
		const amp = 24;
		const dir = side === 'left' ? 1 : -1;

		return (dir * amp * Math.sin(Math.PI * t));
	}

	private handleStartClick = () => {
		console.log('handleStartClickWaf');
    	this.net.resume();
  	};

	private setupCanvas() {
		const container = this.canvas.parentElement;
		if (!container) return;
		const W = this.WORLD_WIDTH, H = this.WORLD_HEIGHT;
		const containerWidth = container.clientWidth * 0.9;
		const containerHeight = window.innerHeight * 0.8;
		const scaleX = containerWidth / W;
		const scaleY = containerHeight / H;
		const scale = Math.min(scaleX, scaleY);
		const displayWidth = Math.floor(W * scale);
		const displayHeight = Math.floor(H * scale);
		const dpr = window.devicePixelRatio || 1;

		this.canvas.width = W * dpr;
		this.canvas.height = H * dpr;
		this.ctx.resetTransform();
		this.ctx.scale(dpr, dpr);

		this.canvas.style.width = displayWidth + 'px';
		this.canvas.style.height = displayHeight + 'px';
		this.canvas.style.display = 'block';
		this.canvas.style.margin = '20px auto';
		this.canvas.style.border = '2px solid #333';
	}

	private sendIntent() {
		const up = (this.keys.w || this.keys.up);
		const down = (this.keys.s || this.keys.down);
		this.net.sendInput(!!up, !!down);
	}

	private drawCooldownDonut(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, thickness: number, progress: number) {
		const start = -Math.PI / 2;
		const end = start + progress * Math.PI * 2;

		ctx.strokeStyle = '#444';
		ctx.lineWidth = thickness;
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2);
		ctx.stroke();

		if (progress > 0)
		{
			ctx.strokeStyle = progress >= 1 ? '#00e676' : '#ffcc00';
			ctx.lineWidth = thickness;
			ctx.beginPath();
			ctx.arc(x, y, r, start, end);
			ctx.stroke();
		}
	}

	private render() {
		const ctx = this.ctx;
		const W = this.WORLD_WIDTH, H = this.WORLD_HEIGHT;

		ctx.fillStyle = '#000000ff';
		ctx.fillRect(0, 0, W, H);

		ctx.strokeStyle = '#fff';
		ctx.setLineDash([10, 10]);
		ctx.beginPath();
		ctx.moveTo(W / 2, 0);
		ctx.lineTo(W / 2, H);
		ctx.stroke();
		ctx.setLineDash([]);

		const leftX = this.PADDLE_MARGIN + this.smashOffsetX('left');
		const rightX = (W - this.PADDLE_MARGIN - this.PADDLE_WIDTH) + this.smashOffsetX('right');

		ctx.fillStyle = '#fff';
		ctx.fillRect(leftX, this.state.leftPaddle.y - this.PADDLE_HEIGHT / 2, this.PADDLE_WIDTH, this.PADDLE_HEIGHT);
		ctx.fillRect(rightX - this.PADDLE_WIDTH, this.state.rightPaddle.y - this.PADDLE_HEIGHT / 2, this.PADDLE_WIDTH, this.PADDLE_HEIGHT);

		for (const powerUp of this.state.powerUps)
		{
			ctx.beginPath();
			ctx.fillStyle = '#ffcc00';
			ctx.arc(powerUp.x, powerUp.y, powerUp.radius, 0, Math.PI * 2);
        	ctx.fill();
        	ctx.strokeStyle = '#333';
        	ctx.lineWidth = 3;
        	ctx.stroke();
		}

		ctx.fillStyle = '#fff';
		for (const b of this.state.balls) {
		ctx.beginPath();
		ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
		ctx.fill();
		}

		ctx.fillStyle = '#fff';
		ctx.font = '48px monospace';
		ctx.textAlign = 'center';
		ctx.fillText(String(this.state.score.left), W / 2 - 100, 60);
		ctx.fillText(String(this.state.score.right), W / 2 + 100, 60);

		if ((this.net.side === 'left' || this.net.side === 'right') && (this.state as any).smash) 
		{
			const smash = this.state.smash;
			const mine = this.net.side === 'left' ? smash.left : smash.right;
			const progress = mine.cooldownRemaining > 0 ? Math.max(0, Math.min(1, 1 - (mine.cooldownRemaining / smash.cooldown))) : 1;
			this.drawCooldownDonut(ctx, 60, 60, 28, 10, progress);
			ctx.fillStyle = '#fff';
			ctx.font = '16px monospace';
			ctx.textAlign = 'left';
			if (mine.cooldownRemaining > 0) {
			ctx.fillText(mine.cooldownRemaining.toFixed(1) + 's', 95, 66);
			}
			ctx.textAlign = 'center';
		}

		if (this.state.countdownValue > 0) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			ctx.fillStyle = '#fff';
			ctx.font = '120px monospace';
			ctx.fillText(String(this.state.countdownValue), W / 2, H / 2);
		} 
		else if (this.state.isGameOver) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			ctx.fillStyle = '#fff';
			ctx.font = '72px monospace';
			ctx.fillText('GAME OVER', W / 2, H / 2 - 40);
			ctx.font = '36px monospace';
			ctx.fillText(`${this.state.winner} wins`, W / 2, H / 2 + 10);
			ctx.font = '24px monospace';
			ctx.fillText('Click "Replay" to restart', W / 2, H / 2 + 60);
		} 
		else if (this.state.isPaused) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			ctx.fillStyle = '#fff';
			ctx.font = '72px monospace';
			ctx.fillText('PAUSED', W / 2, H / 2);
			ctx.font = '24px monospace';
			ctx.fillText('Press P, SPACE or ESC to resume', W / 2, H / 2 + 60);
		}
	}

	cleanup(): void {
		if (this.animationFrameId !== null)
		{
			cancelAnimationFrame(this.animationFrameId);
			this.animationFrameId = null;
		}
		this.startBtn.removeEventListener('click', this.handleStartClick);
		window.removeEventListener('resize', this.onResize);
		window.removeEventListener('keydown', this.onKeyDown);
		window.removeEventListener('keyup', this.onKeyUp);
	}
}

export function Pong(): string { 
	return `
		<div class="container ml-auto mr-auto flex flex-col items-center" data-component="pong-game">
			<canvas id="pong-canvas"></canvas>
			${Button({
				children: "Start",
				variant: "danger",
				size: "lg",
				className: "font-bold ",
				id: "startBtn",
			})}
		</div>
	`;
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/VolumeControl.ts
═══════════════════════════════════════════════════════
import { gsap } from "gsap";

interface VolumeControlProps {
    initialVolume?: number;
    className?: string;
}

export function VolumeControl({ 
    initialVolume = 50,
    className = '' 
}: VolumeControlProps = {}): string {
    // Setup après le rendu
    setTimeout(() => {
        let holdTimer: any = null;
        let chargeLevel = 0;
        const speaker = document.getElementById('volume-speaker');
        const volumeTrack = document.getElementById('volume-track');
        const volumeBall = document.getElementById('volume-ball');
        
        if (!speaker || !volumeTrack || !volumeBall) {
            console.log('Volume control elements not found');
            return;
        }

        // Position initiale
        const initialPos = (initialVolume / 100) * volumeTrack.offsetWidth;
        gsap.set(volumeBall, { x: initialPos });
        
        // Mouse down - commence à charger ET reset la boule
        speaker.addEventListener('mousedown', () => {
            chargeLevel = 0;
            
            // Reset la position de la boule au début
            gsap.set(volumeBall, { 
                x: 0,
                y: 0,
                scale: 1
            });
            
            holdTimer = setInterval(() => {
                chargeLevel = Math.min(100, chargeLevel + 2);
                
                // Vibration du speaker
                gsap.to(speaker, {
                    scale: 1 + (chargeLevel / 200),
                    duration: 0.1
                });
            }, 20);
        });

        // Mouse up - lance la boule avec physique réaliste
        speaker.addEventListener('mouseup', () => {
            if (holdTimer) {
                clearInterval(holdTimer);
                
                // Position finale basée sur la charge
                const finalPosition = (chargeLevel / 100) * volumeTrack.offsetWidth;
                const jumpHeight = 20 + (chargeLevel / 4);
                
                // Mouvement horizontal linéaire
                gsap.fromTo(volumeBall,
                    { x: 0 },
                    { 
                        x: finalPosition,
                        duration: 0.6,
                        ease: "none"
                    }
                );
                
                // Mouvement vertical parabolique
                gsap.fromTo(volumeBall,
                    { y: 0 },
                    {
                        y: -jumpHeight,
                        duration: 0.3,
                        ease: "power2.out",
                        yoyo: true,
                        repeat: 1,
                        immediateRender: false
                    }
                );
                
                gsap.to(speaker, {
                    scale: 1,
                    duration: 0.3
                });
                
                chargeLevel = 0;
            }
        });

        // Mouse leave - annule la charge
        speaker.addEventListener('mouseleave', () => {
            if (holdTimer) {
                clearInterval(holdTimer);
                holdTimer = null;
                
                gsap.to(speaker, {
                    scale: 1,
                    duration: 0.3
                });
                
                chargeLevel = 0;
            }
        });
    }, 0);

    return `
        <div class="flex items-center gap-3 ${className}">
            <!-- Speaker sans fond -->
            <div 
                id="volume-speaker"
                class="w-8 h-8 flex items-center justify-center cursor-pointer select-none"
            >
                <!-- Icône speaker -->
                <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217z"/>
                </svg>
            </div>

            <!-- Container avec padding pour la trajectoire -->
            <div class="relative flex-1 py-6">
                <!-- Ligne de volume -->
                <div 
                    id="volume-track"
                    class="h-[2px] bg-white/50 rounded-full relative"
                >
                    <!-- Boule -->
                    <div 
                        id="volume-ball"
                        class="absolute top-1/2 -translate-y-1/2 w-3 h-3 bg-white rounded-full"
                        style="left: 0; transform: translateY(-50%);"
                    ></div>
                </div>
            </div>
        </div>
    `;
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/index.ts
═══════════════════════════════════════════════════════
import { ChatComponant } from './Chat';
import { PongGame } from './PongGame';
import { ComponentRegistry } from './ComponantManager';
import { JoinTournamentComponent } from './JoinTournament';

export function registerComponents(): void
{
    ComponentRegistry.register('chat', ChatComponant)
    ComponentRegistry.register('pong-game', PongGame)
    ComponentRegistry.register('joinTournament', JoinTournamentComponent)
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/Header.ts
═══════════════════════════════════════════════════════
import type { ComponentProps } from './types';
import { Button } from './Button';

interface HeaderProps extends ComponentProps {
    isLogged?: boolean
}

export function Header({ 
	className = '',
	isLogged = false
}: HeaderProps): string {

	const baseClass = `
		container flex justify-between
		gap-4 py-4 px-8 mt-4 ml-auto mr-auto
		rounded-xl
		bg-orange-600
		${className}
	`.replace(/\s+/g, ' ').trim();
	
	return `
		<header class="${baseClass}">
			<h1 class="text-2xl text-white">Pongers!</h1>
			${isLogged ? 
				Button({
					children: "Profile",
					id: "profileBtn",
					variant: "secondary",
					size: "md",
					href: ""
				})
					:
				Button({
					children: "Login",
					id: "loginBtn",
					variant: "secondary",
					size: "md",
					href: "/login"
				})
			}
		</header>
	`;
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/Button.ts
═══════════════════════════════════════════════════════
import type { ComponentProps } from './types';
import { renderChildren } from './types';

// ============= BUTTON DE BASE =============
interface ButtonProps extends ComponentProps {
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
    size?: 'sm' | 'md' | 'lg';
    href?: string;
}

export function Button({ 
    children, 
    variant = 'primary', 
    size = 'md',
    href,
    className = '',
    id
}: ButtonProps): string {
    const variants = {
        primary: 'bg-blue-500 hover:bg-blue-600 text-white',
        secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-800',
        danger: 'bg-red-500 hover:bg-red-600 text-white',
		default: ''
    };
    
    const sizes = {
        sm: 'px-3 py-1 text-sm',
        md: 'px-4 py-2',
        lg: 'px-6 py-3 text-lg'
    };
    
    const baseClass = `
        ${variants[variant]}
        ${sizes[size]}
        rounded-lg font-medium transition-colors cursor-pointer
		relative block w-fit
        ${className}
    `.replace(/\s+/g, ' ').trim();
    
    const content = renderChildren(children);
    
    if (href) {
        return `<a href="${href}" id=${id} class="${baseClass}">${content}</a>`;
    }
    
    return `<button id=${id} class="${baseClass}">${content}</button>`;
}

// ============= SETTINGS BUTTON =============
interface SettingsButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
}

export function SettingsButton({ 
    className = '', 
    size = 'md' 
}: SettingsButtonProps = {}): string {
    return Button({
        children: "⚙️",
        variant: "default",
        size: size,
        href: "/settings",
        className: className,
        id: "settings-button"
    });
}

// ============= SKIN BUTTON =============
interface SkinButtonProps extends ButtonProps {
    showLabel?: boolean;
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
}

export function SkinButton({ 
    className = '', 
    size = 'md',
    showLabel = true,
    variant = 'default'
}: SkinButtonProps = {}): string {
    const buttonContent = showLabel ? "🎨" : "🎨";
    
    return Button({
        children: buttonContent,
        variant: variant,
        size: size,
        href: "/customization",
        className: className,
        id: "skin-button"
    });
}

// ============= COFFEE BUTTON =============
interface CoffeeButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
    showIcon?: boolean;
}

export function CoffeeButton({ 
    className = '', 
    size = 'md',
    showIcon = true
}: CoffeeButtonProps = {}): string {
    const content = showIcon ? "☕ Buy me a Coffee" : "Buy me a Coffee";
    
    return Button({
        children: content,
        variant: "default",
        size: size,
        href: "/cafe",
        className: `bg-yellow-500 hover:bg-yellow-600 ${className}`,
        id: "coffee-button"
    });
}

// ============= BACK BUTTON =============
interface BackButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
    text?: string;
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
}

export function BackButton({ 
    className = '', 
    size,
    text = "←",
    variant = 'default'
}: BackButtonProps = {}): string {
    return `
        <button 
            onclick="history.back()" 
            class="
                ${variant === 'primary' ? 'bg-blue-500 hover:bg-blue-600 text-white' : ''}
                ${variant === 'secondary' ? 'bg-gray-200 hover:bg-gray-300 text-gray-800' : ''}
                ${variant === 'danger' ? 'bg-red-500 hover:bg-red-600 text-white' : ''}
                ${size === 'sm' ? 'px-3 py-1 text-sm' : ''}
                ${size === 'md' ? 'px-4 py-2' : ''}
                ${size === 'lg' ? 'px-6 py-3 text-lg' : ''}
                rounded-lg font-medium transition-colors cursor-pointer
                relative block w-fit
                ${className}
            "
            id="back-button"
        >
            ${text}
        </button>
    `;
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/Chat.ts
═══════════════════════════════════════════════════════
import type { ComponentProps, Component } from "./types";

interface GlobalChatProps extends ComponentProps
{
	type: 'global' | 'game' | 'private'
}

export class ChatComponant implements Component
{
	private element: HTMLElement
	private ws: WebSocket
	private type: string
	private statusElem: HTMLElement | null
	private chatHistory: HTMLDivElement
	private chatInput: HTMLInputElement

	constructor(element: HTMLElement)
	{
		const host = import.meta.env.VITE_HOST
		const endpoint = import.meta.env.VITE_CHAT_ENDPOINT
		const wsUrl = (host && endpoint) ? `wss://${host}${endpoint}`
					: 'wss://localhost:8443/chatback/ws';

        this.element = element;
        this.type = element.getAttribute('data-chat-type') || 'global';
		this.ws = new WebSocket(wsUrl);
		this.statusElem = element.querySelector('h2');
		this.chatHistory = element.querySelector('.history') as HTMLDivElement
		this.chatInput = element.querySelector('input') as HTMLInputElement
        this.init();
    }

	private sendMessage = (msg: string): void => {
			const trimedMsg = msg.trim();
			if (this.ws && trimedMsg)
			{
				this.ws.send(trimedMsg)
			}
		}


	private handleKeyDown = (e: KeyboardEvent): void => {
		if (e.key === 'Enter' && !e.shiftKey)
		{
			e.preventDefault();
			const msg = this.chatInput.value;
			this.sendMessage(msg);
			this.chatInput.value = ''
		}
	}

	private init(): void
	{		
		console.log("init")
		this.ws.onopen = () => {
			this.ws.send('hi from client');
			this.statusElem!.innerHTML = 'Connecté au chat!';
		};
		
		this.ws.onmessage = (event) => {
			this.chatHistory!.innerHTML += `<p class="p-4 block bg-red-400 text-white rounded-xl w-fit">` + event.data + '</p>';
		};
		
		this.ws.onerror = () => {
			this.statusElem!.innerHTML = 'Erreur de connexion';
		};

		this.chatInput?.addEventListener("keydown", this.handleKeyDown)
    }
    
    cleanup(): void
	{
        this.chatInput.removeEventListener('keydown', this.handleKeyDown)
		if (this.ws && this.ws.readyState === WebSocket.OPEN) {
			this.ws.close();
		}
    }
}

export function Chat({
	className = '',
	type = 'global'
} : GlobalChatProps) {
	const chatClasses = `${className}
	${type == 'global' ? `` : ``}
	`;


	return `
		<div class="${chatClasses}"
			data-component="chat"
			data-chat-type=${type}	
		>
			<h2 class="text-3xl">Connexion en cours...</h2>
			<div class="history mt-4 flex flex-col gap-4"></div>
			<input type="text" id="chatInput" name="chatInput"
				placeholder="Tapez votre message..."
				class="border-2 rounded-md p-4 w-full mt-4" />
		<div>
	`
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/JoinTournament.ts
═══════════════════════════════════════════════════════
import type { ComponentProps, Component } from "./types";

interface JoinTournamentProps extends ComponentProps
{
	slots: number
}

export class JoinTournamentComponent implements Component
{
	private element: HTMLElement
	private slots: string | null

	constructor(element: HTMLElement)
	{

		this.element = element;
		this.slots = element.getAttribute('data-slots')
		this.init();
	}

	private init(): void
	{

	}
	
	cleanup(): void
	{

	}
}

export function JoinTournament({
	className = 'px-32 py-16 border-2 border-red-400 rounded-2xl cursor-pointer',
	slots
} : JoinTournamentProps) {
	const chatClasses = `${className}`

	return `
		<button class="${chatClasses}"
			data-component="joinTournament"
			data-slots=${slots}	
		>
			${slots} Players
			<span></span>
		<button>
	`
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/types.ts
═══════════════════════════════════════════════════════
export interface ComponentProps {
    children?: string | string[];
    className?: string;
    id?: string;
    [key: string]: any;
}

export function renderChildren(children?: string | string[]): string {
    if (!children) return '';
    return Array.isArray(children) ? children.join('') : children;
}

export interface Component
{
    cleanup(): void;
}


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/components/ComponantManager.ts
═══════════════════════════════════════════════════════
import type { Component } from "./types";

type ComponentConstructor = new (element: HTMLElement) => Component;

export class ComponentRegistry
{
    private static components: Map<string, ComponentConstructor> = new Map();

    static register(name: string, constructor: ComponentConstructor): void
    {
        this.components.set(name, constructor);
    }

    static get(name: string): ComponentConstructor | undefined
    {
        return this.components.get(name);
    }
}

export class ComponentManager
{
    private instances: Map<HTMLElement, Component> = new Map();
    
    scanAndMount(): void
    {
        const components = document.querySelectorAll('[data-component]');
        console.log(components)
        
        components.forEach(element => {
            const componentName = element.getAttribute('data-component');
            if (!componentName) return;
            
            const ComponentClass = ComponentRegistry.get(componentName);
            
            if (ComponentClass && !this.instances.has(element as HTMLElement))
            {
                const instance = new ComponentClass(element as HTMLElement);
                this.instances.set(element as HTMLElement, instance);
            }
        });
    }
    
    cleanupAll(): void
    {
        this.instances.forEach(instance => instance.cleanup());
        this.instances.clear();
    }
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/vite-env.d.ts
═══════════════════════════════════════════════════════
/// <reference types="vite/client" />



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/GameView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { Pong } from "../components/PongGame";
import { gsap } from "gsap";
import { BackButton } from "../components/Button";

 export const GameView: ViewFunction = () => {
	// Animation d'entrée
	setTimeout(() => {
		const tl = gsap.timeline();
		
		// Récupérer les positions data-x et data-y
		const stars = document.querySelectorAll('.star-particle');
		stars.forEach((star) => {
			const targetX = parseFloat(star.getAttribute('data-x') || '0');
			const targetY = parseFloat(star.getAttribute('data-y') || '0');
			
			gsap.fromTo(star,
				{ 
					x: 0,
					y: 0,
					scale: 0.1,
					opacity: 1
				},
				{ 
					x: targetX,
					y: targetY,
					scale: 1,
					opacity: 1,
					duration: 4,
					ease: "power2.out"
				}
			);
		});
		
		// Faire disparaître la transition après l'animation
		tl.to("#space-transition", 
			{ 
				opacity: 0,
				duration: 1,
				delay: 2, // Attendre que les étoiles soient parties
				onComplete: () => {
					const transition = document.getElementById('space-transition');
					if (transition) transition.style.display = 'none';
				}
			}
		)
		.fromTo("#game-content", 
			{ opacity: 0, scale: 0.8 },
			{ opacity: 1, scale: 1, duration: 0.5, ease: "back.out" },
			"-=0.5"
		);
	}, 0);
	
	return `
		<div id="space-transition" class="fixed inset-0 z-50 bg-[#04071A] overflow-hidden">
			${Array.from({length: 300}, (_) => {
				const angle = Math.random() * Math.PI * 2;
				const distance = Math.random() * 1500 + 500;
				const x = Math.cos(angle) * distance;
				const y = Math.sin(angle) * distance;
				const size = Math.random() * 4 + 1;
				
				return `
					<div 
						class="star-particle absolute bg-white rounded-full"
						style="
							width: ${size}px;
							height: ${size}px;
							left: 50%;
							top: 50%;
							transform: translate(-50%, -50%);
							box-shadow: 0 0 ${size * 2}px rgba(255, 255, 255, 0.8);
						"
						data-x="${x}"
						data-y="${y}"
					></div>
				`;
			}).join('')}
			
			<!-- Lignes de vitesse -->
			${Array.from({length: 50}, (_) => {
				const angle = Math.random() * Math.PI * 2;
				const length = Math.random() * 200 + 100;
				const distance = Math.random() * 800;
				
				return `
					<div 
						class="absolute bg-gradient-to-r from-transparent via-white to-transparent opacity-30"
						style="
							width: ${length}px;
							height: 1px;
							left: 50%;
							top: 50%;
							transform: translate(-50%, -50%) 
									  rotate(${angle}rad) 
									  translateX(${distance}px);
						"
					></div>
				`;
			}).join('')}
		</div>
		<div id="game-content">
			${BackButton()}
			${Pong()}
		</div>
	`

};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/TournamentView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types"
import { Header } from "../components/Header";
import { JoinTournament } from "../components/JoinTournament";
import { wsTournament } from "../net/wsTournament";

export const TournamentView: ViewFunction = () => {
	return `
		${Header({isLogged: false})}
		<div class="relative">
			<div class="mt-16 flex flex-col gap-4 items-center">
				<input type="text" name="username" id="usernameInput" value="Anon"
					class="px-8 py-4 border-b-cyan-300 border-2 rounded-xl"/>
				${JoinTournament({slots: 4})}
				${JoinTournament({slots: 8})}
				${JoinTournament({slots: 16})}
			</div>
			<div id="countdown" style="display: none;"class="absolute -translate-1/2 left-1/2 top-1/2 px-8 py-4 text-white bg-gray-950 rounded-xl">
				<h2>Tournament is starting...</h2>
				<div id="countdown-text" class="text-center text-4xl py-4">waf</div>
			</div>
		</div>
	`
}

export const tournamentLogic = (): (() => void) => {
	const tournamentBtns = document.querySelectorAll('[data-component="joinTournament"]')
	const net = new wsTournament(tournamentBtns);
	const usernameInput = document.getElementById("usernameInput") as HTMLInputElement;
	
	net.connect();

	const handleJoinTournament = (e: Event) => {
		const username = usernameInput.value;
		const target = e.target as HTMLElement
		const id = target?.getAttribute('data-tournament-id')

		net.join(id, username)
	}

	tournamentBtns.forEach(tournamentBtn => {
		tournamentBtn.addEventListener("click", handleJoinTournament)
	})

	
	// === FONCTION DE CLEANUP ===
	return (): void => {
		net.close()
		tournamentBtns.forEach(tournamentBtn => {
			tournamentBtn.removeEventListener("click", handleJoinTournament)
		})
	};
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/CreateAccountView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { 
	Button,
	BackButton
	 } from "../components/Button";

 export const CreateAccountView: ViewFunction = () => {
	return `
		<!-- Fond étoilé -->
		<div class="fixed inset-0 bg-[#04071A] overflow-hidden">
			<!-- Étoiles -->
			${Array.from({length: 150}, (_, i) => `
			<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			<!-- Étoiles normales -->
			${Array.from({length: 150}, (_, i) => `
				<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			
			<!-- Étoiles qui scintillent fort -->
			${Array.from({length: 50}, (_) => `
				<div 
					class="absolute"
					style="
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
					"
				>
					<div class="w-[4px] h-[4px] bg-white rounded-full"></div>
				</div>
			`).join('')}
			
			<style>
				@keyframes strong-sparkle {
					0%, 100% {
						opacity: 0.3;
						filter: blur(0px);
					}
					50% {
						opacity: 1;
						filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
					}
				}
			</style>
			
			

		<!-- BackButton -->
		<div class="relative z-10 p-8">
			${BackButton()}
		</div>

		<!-- Fenêtre centrale -->
		<div class="fixed inset-0 flex items-center justify-center z-10 px-8">
    		<div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-8 w-full max-w-6xl min-h-[600px] shadow-2xl flex">
				<!-- Côté gauche avec le formulaire -->
				<div class="absolute top-8 left-8">
					${BackButton({
						size: "lg",
						className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
					})}
				</div>
				<div class="w-1/2 border-r border-white/20 p-8 flex items-center justify-center">
					<img 
						src="/sprites/dancing-cat.gif" 
						alt="Animation"
						class="w-full h-full object-contain rounded"
					/>
				</div>
				
				<!-- Côté droit avec le formulaire -->
				<div class="w-1/2 px-8 flex flex-col justify-center items-center">
					<h1 class="text-4xl font-bold mb-4 text-white">Hello !</h1>
					<h2 class="text-2xl font-bold mb-8 text-white/80 text-center">Create your account</h2>

					<form action="/create" method="POST" id="createform">
						<div class="mb-4">
							<label for="username" class="block mb-2 text-white/70">Username:</label>
							<input 
								type="text" 
								id="username" 
								name="username"
								placeholder="Enter username"
								required
								class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
							>
						</div>
						<div class="mb-6">
							<label for="password" class="block mb-2 text-white/70">Password:</label>
							<input 
								type="password" 
								id="password" 
								name="password"
								placeholder="Enter password"
								required
								class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
							>
						</div>
						<div class="mb-6">
							<label for="confirmpassword" class="block mb-2 text-white/70">Confirm your password:</label>
							<input 
								type="confirmpassword" 
								id="confirmpassword" 
								name="confirmpassword"
								placeholder="Confirm your password"
								required
								class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
							>
						</div>
						<button type="submit" class="w-full py-2 mb-4 text-center bg-[#101C69]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20">
							Submit
						</button>


					</form>

					${Button({
						children: "Login",
						variant: "default",
						size: "sm",
						href: "/login",
						className: "w-full text-center text-white/80"
					})} 
				</div>
			</div>
		</div>
	`;
};
	


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/StartGameView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { 
	Button,
	BackButton,
	SettingsButton
		} from "../components/Button";  // Ajoute BackButton
import { gsap } from "gsap";

export const StartGameView: ViewFunction = () => {
    // Animation GSAP après le rendu
    setTimeout(() => {
        // Timeline pour contrôler toute l'animation
        const tl = gsap.timeline();
        
        // Variables pour le contrôle du vaisseau
        let mouseY = window.innerHeight / 2;
        const spaceship = document.getElementById("spaceship");
        
        // 1. Suivre la souris
        document.addEventListener('mousemove', (e) => {
            mouseY = e.clientY;
            
            if (spaceship) {
                // Position relative au centre de l'écran
                const centerY = window.innerHeight / 2;
                const offsetY = mouseY - centerY;
                
                // Limiter le mouvement (max 300px du centre)
                const clampedY = Math.max(-300, Math.min(200, offsetY));
                
                // Animation fluide vers la position de la souris
                gsap.to("#spaceship", {
                    y: clampedY,
                    duration: 0.3,  // Délai pour un mouvement plus smooth
                    ease: "power2.out"
                });
            }
        });
        
        // 2. Fonction pour créer un projectile
        function createProjectile() {
            const spaceship = document.getElementById("spaceship");
            const gameAnimation = document.getElementById("game-animation");
            
            if (!spaceship || !gameAnimation) return;
            
            const rect = spaceship.getBoundingClientRect();
            
            const projectile = document.createElement("div");
            projectile.className = "absolute bg-yellow-400";
            projectile.style.cssText = `
                width: 10px;
                height: 4px;
                left: ${rect.right}px;
                top: ${rect.top + rect.height/2}px;
                border-radius: 1px;
            `;
            
            gameAnimation.appendChild(projectile);
            
            gsap.to(projectile, {
                x: window.innerWidth,
                duration: 2,
                ease: "none",
                onComplete: () => {
                    projectile.remove();
                }
            });
        }
        
        // 3. Tir avec la barre espace
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();  // Empêche le scroll
                createProjectile();
            }
        });
        
        // 4. Tir automatique toutes les secondes
        const shootInterval = setInterval(createProjectile, 1000);
        
        // 5. Animation du background
        tl.to("#stars-bg", {
            x: "-80%",
            duration: 3,
            ease: "power2.out"
        })
        
        // 6. Faire apparaître les boutons
        .to("#menu-buttons", {
            opacity: 1,
            pointerEvents: "auto",
            duration: 1,
            ease: "power2.out",
        });
    }, 0);
    
    return `
        <!-- Instructions de contrôle EN BAS À GAUCHE -->
        <div class="fixed bottom-4 left-4 text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white">
            <p>🖱️ Souris : Contrôler l'avion</p>
            <p>Espace : Tirer</p>
        </div>
        
        <!-- Canvas pour l'animation -->
        <div id="game-animation" class="fixed inset-0 w-full h-full bg-[#04071A] overflow-hidden">
            <!-- Background étoilé -->
            <div id="stars-bg" class="absolute inset-0 w-[200%]">
                ${Array.from({length: 100}, (_, i) => `
                    <div 
                        class="absolute bg-white rounded-full ${i % 5 === 0 ? 'animate-pulse' : ''}"
                        style="
                            width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                            height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                            left: ${Math.random() * 100}%;
                            top: ${Math.random() * 100}%;
                            opacity: ${0.3 + Math.random() * 0.7};
                            ${i % 5 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
                        "
                    ></div>
                `).join('')}
            </div>
            
            <!-- Avion -->
            <div id="spaceship" class="absolute" style="
                width: 128px;
                height: 128px;
                top: 50%;
                left: 20%;
                transform: translate(-50%, -50%);
            ">
                <img 
                    src="/sprites/spaceship.png" 
                    alt="spaceship"
                    class="w-full h-full"
                    style="image-rendering: pixelated;"
                />
            </div>
        </div>

        <!-- Container des boutons -->
		<div id="menu-buttons" class="fixed inset-0 flex flex-col items-center justify-center opacity-0 pointer-events-none">

			<div class="absolute top-8 left-8">
				${BackButton({
					size: "lg",
					className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
				})}
			</div>

			<div class="absolute top-8 right-8">
			${SettingsButton({
				size: "lg",
				className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
			})}
			</div>
		

			<!-- Texte central qui change -->
			<div id="center-text" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white/70 text-4xl font-bold text-center">
				Choisissez votre destination !
			</div>

			<div class="absolute right-0 top-0 w-1/3 h-full">
				<!-- Bouton Quickplay -->
				<a href="/game" 
				class="absolute block w-[350px] h-[250px]" 
				style="top: 10%; right: 30%;"
				onmouseover="document.getElementById('center-text').textContent = '⚡ Partie Rapide'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/blackhole.png" 
						alt="Quickplay"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
				
				<!-- Bouton Tournament -->
				<a href="/tournament" 
				class="absolute block w-[900px] h-[800px]" 
				style="top: 65%; right: 50%;"
				onmouseover="document.getElementById('center-text').textContent = '🏆 Mode Tournoi'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/earth.png" 
						alt="Tournament"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
				
				<!-- Bouton Skin -->
				<a href="/skin" 
				class="absolute block w-[125px] h-[125px]" 
				style="top: 65%; right: 175px;"
				onmouseover="document.getElementById('center-text').textContent = '🎨 Personnalisation'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/satellite.png" 
						alt="Skin"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
		</div>

    `;
};




═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/LoginView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { 
	Button,
	BackButton
	 } from "../components/Button";

 export const LoginView: ViewFunction = () => {
	return `
		<!-- Fond étoilé -->
		<div class="fixed inset-0 bg-[#04071A] overflow-hidden">
			<!-- Étoiles -->
			${Array.from({length: 150}, (_, i) => `
			<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			<!-- Étoiles normales -->
			${Array.from({length: 150}, (_, i) => `
				<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			
			<!-- Étoiles qui scintillent fort -->
			${Array.from({length: 50}, (_) => `
				<div 
					class="absolute"
					style="
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
					"
				>
					<div class="w-[4px] h-[4px] bg-white rounded-full"></div>
				</div>
			`).join('')}
			
			<style>
				@keyframes strong-sparkle {
					0%, 100% {
						opacity: 0.3;
						filter: blur(0px);
					}
					50% {
						opacity: 1;
						filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
					}
				}
			</style>
			
			

		<!-- BackButton -->
		
		<!-- Fenêtre centrale -->
		<div class="fixed inset-0 flex items-center justify-center z-10 px-8">
		<div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-8 w-full max-w-6xl min-h-[600px] shadow-2xl flex">
		<!-- Côté gauche avec le formulaire -->
			<div class="w-1/2 border-r border-white/20 p-8 flex items-center justify-center">
				<div class="absolute top-8 left-8">
					${BackButton({
						size: "lg",
						className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
					})}
				</div>
					<img 
						src="/sprites/cat.gif" 
						alt="Animation"
						class="w-full h-full object-contain rounded"
					/>
			</div>
			<!-- Côté droit avec le formulaire -->
			<div class="w-1/2 px-8 flex flex-col justify-center items-center">
				<h1 class="text-4xl font-bold mb-4 text-white">Hello !</h1>
				<h2 class="text-2xl font-bold mb-8 text-white/80 text-center">Login your account</h2>

				<form action="/login" method="POST" id="loginForm">
					<div class="mb-4">
						<label for="username" class="block mb-2 text-white/70">Username:</label>
						<input 
							type="text" 
							id="username" 
							name="username"
							placeholder="Enter your username"
							required
							class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
						>
					</div>
					<div class="mb-6">
						<label for="password" class="block mb-2 text-white/70">Password:</label>
						<input 
							type="password" 
							id="password" 
							name="password"
							placeholder="Enter your password"
							required
							class="w-full p-2 rounded bg-[#101C69]/40 border border-white/20 text-white placeholder:text-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
						>
					</div>
					<button type="submit" class="w-full py-2 mb-4 text-center bg-[#101C69]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20">
						Submit
					</button>
				</form>

				${Button({
					children: "Create account",
					variant: "default",
					size: "sm",
					href: "/create",
					className: "w-full text-center text-white/80"
				})} 
			</div>
		</div>
	`;
};
	


═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/TestView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { Header } from "../components/Header";

export const TestView: ViewFunction = () => {
	return `
		${Header({ isLogged: false })}
		<div class="container mx-auto p-6 max-w-4xl">
			<h1 class="text-3xl font-bold text-gray-800 mb-6">Test Client QuickPlay</h1>
			
			<!-- Status de connexion -->
			<div id="connection-status" class="p-4 mb-4 rounded-lg border bg-gray-100 text-gray-800">
				Non connecté
			</div>
			
			<!-- Contrôles de connexion -->
			<div class="mb-6 p-4 bg-white rounded-lg shadow-sm border">
				<h3 class="text-lg font-semibold mb-3">Connexion</h3>
				<div class="flex flex-wrap gap-3 items-center">
					<input 
						type="text" 
						id="username" 
						placeholder="Nom d'utilisateur" 
						value="TestPlayer"
						class="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
					>
					<button 
						id="connect-btn" 
						class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
					>
						Se connecter
					</button>
					<button 
						id="disconnect-btn" 
						class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500"
					>
						Se déconnecter
					</button>
				</div>
			</div>
			
			<!-- Contrôles de jeu -->
			<div class="mb-6 p-4 bg-white rounded-lg shadow-sm border">
				<h3 class="text-lg font-semibold mb-3">Actions de jeu</h3>
				<div class="flex flex-wrap gap-3">
					<button 
						id="join-quickplay-btn" 
						class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500"
					>
						Rejoindre QuickPlay
					</button>
					<button 
						id="player-ready-btn" 
						class="px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500"
					>
						Je suis prêt
					</button>
					<button 
						id="send-input-btn" 
						class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500"
					>
						Envoyer Input Test
					</button>
				</div>
			</div>
			
			<!-- Messages reçus -->
			<div class="mb-6">
				<h3 class="text-lg font-semibold mb-3">Messages reçus :</h3>
				<div 
					id="messages" 
					class="h-64 overflow-y-auto border border-gray-300 rounded-lg p-4 bg-gray-50 font-mono text-sm"
				></div>
			</div>
			
			<!-- Infos de debug -->
			<div class="p-4 bg-white rounded-lg shadow-sm border">
				<h3 class="text-lg font-semibold mb-3">Infos de debug :</h3>
				<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
					<div class="flex justify-between">
						<span class="font-medium">Room ID:</span>
						<span id="room-id" class="text-gray-600">-</span>
					</div>
					<div class="flex justify-between">
						<span class="font-medium">Player Number:</span>
						<span id="player-number" class="text-gray-600">-</span>
					</div>
				</div>
			</div>
		</div>
	`;
};

export const initWebSocket = (): (() => void) => {
	let ws: WebSocket | null = null;
	let roomId: string | null = null;
	let playerNumber: string | null = null;

	// Références aux éléments DOM
	const connectBtn = document.getElementById('connect-btn') as HTMLButtonElement;
	const disconnectBtn = document.getElementById('disconnect-btn') as HTMLButtonElement;
	const joinQuickplayBtn = document.getElementById('join-quickplay-btn') as HTMLButtonElement;
	const playerReadyBtn = document.getElementById('player-ready-btn') as HTMLButtonElement;
	const sendInputBtn = document.getElementById('send-input-btn') as HTMLButtonElement;

	// === EVENT LISTENERS ===
	
	const handleConnect = (): void => {
		if (ws) {
			addMessage('Déjà connecté!', 'error');
			return;
		}

		ws = new WebSocket(`wss://${import.meta.env.VITE_HOST}${import.meta.env.VITE_QUICK_ENDPOINT}`);
		
		ws.onopen = function() {
			addMessage('Connecté au serveur!', 'success');
			updateStatus('Connecté', 'connected');
		};
		
		ws.onmessage = function(event) {
			const message = JSON.parse(event.data);
			handleServerMessage(message);
		};
		
		ws.onclose = function() {
			addMessage('Connexion fermée', 'error');
			updateStatus('Déconnecté', 'error');
			ws = null;
			roomId = null;
			playerNumber = null;
            sessionStorage.removeItem('gameWsURL');
			updateDebugInfo();
		};
		
		ws.onerror = function(error) {
			addMessage('Erreur WebSocket: ' + error, 'error');
		};
	};

	const handleDisconnect = (): void => {
		if (ws) {
			ws.close();
		}
	};

	const handleJoinQuickplay = (): void => {
		if (!ws) {
			addMessage('Pas connecté!', 'error');
			return;
		}
		
		const usernameInput = document.getElementById('username') as HTMLInputElement;
		const username = usernameInput.value || 'TestPlayer';
		const message = {
			type: 'join_quickplay',
			username: username
		};
		
		ws.send(JSON.stringify(message));
		addMessage('Demande de quickplay envoyée...', 'info');
	};

	const handlePlayerReady = (): void => {
		if (!ws) {
			addMessage('Pas connecté!', 'error');
			return;
		}
		
		ws.send(JSON.stringify({ type: 'player_ready' }));
		addMessage('Signal "prêt" envoyé', 'info');
	};

	const handleSendInput = (): void => {
		if (!ws) {
			addMessage('Pas connecté!', 'error');
			return;
		}
		
		ws.send(JSON.stringify({ 
			type: 'player_input', 
			input: { action: 'move', direction: 'up' }
		}));
		addMessage('Input test envoyé', 'info');
	};

	// Attacher les event listeners
	connectBtn?.addEventListener('click', handleConnect);
	disconnectBtn?.addEventListener('click', handleDisconnect);
	joinQuickplayBtn?.addEventListener('click', handleJoinQuickplay);
	playerReadyBtn?.addEventListener('click', handlePlayerReady);
	sendInputBtn?.addEventListener('click', handleSendInput);

	// === FONCTIONS UTILITAIRES ===

	function handleServerMessage(message: any): void {
		addMessage('Reçu: ' + JSON.stringify(message), 'server');
		
		switch(message.type) {
			case 'waiting_for_opponent':
				updateStatus('En attente d\'un adversaire...', 'waiting');
				break;
				
			case 'game_start':
				roomId = message.roomId;
				playerNumber = message.playerNumber;
                const wsUrl: string | undefined = message.gameServerURL;
                if (wsUrl)
                {
                    console.log('[TestView] storing gameWsURL', wsUrl);
                    sessionStorage.setItem('gameWsURL', wsUrl);
                }
				updateStatus(`Partie démarrée! Vous êtes le joueur ${playerNumber}`, 'playing');
				updateDebugInfo();
				console.log(window.router)
				window.router.navigate(`/game/${roomId}`)
				break;
				
			case 'opponent_disconnected':
				updateStatus('Adversaire déconnecté', 'waiting');
				break;
				
			case 'error':
				updateStatus('Erreur: ' + message.message, 'error');
				break;
		}
	}

	function addMessage(text: string, type: string): void {
		const messages = document.getElementById('messages');
		if (!messages) return;

		const time = new Date().toLocaleTimeString();
		const div = document.createElement('div');
		div.innerHTML = `<strong class="text-gray-600">[${time}]</strong> ${text}`;
		
		// Couleurs selon le type avec Tailwind
		switch(type) {
			case 'error':
				div.className = 'text-red-600 mb-1';
				break;
			case 'server':
				div.className = 'text-blue-600 mb-1';
				break;
			case 'success':
				div.className = 'text-green-600 mb-1';
				break;
			case 'info':
			default:
				div.className = 'text-gray-800 mb-1';
				break;
		}
		
		messages.appendChild(div);
		messages.scrollTop = messages.scrollHeight;
	}

	function updateStatus(text: string, type: string): void {
		const status = document.getElementById('connection-status');
		if (!status) return;

		status.textContent = text;
		
		// Classes Tailwind selon le statut
		switch(type) {
			case 'connected':
				status.className = 'p-4 mb-4 rounded-lg border bg-blue-100 text-blue-800 border-blue-300';
				break;
			case 'waiting':
				status.className = 'p-4 mb-4 rounded-lg border bg-yellow-100 text-yellow-800 border-yellow-300';
				break;
			case 'playing':
				status.className = 'p-4 mb-4 rounded-lg border bg-green-100 text-green-800 border-green-300';
				break;
			case 'error':
				status.className = 'p-4 mb-4 rounded-lg border bg-red-100 text-red-800 border-red-300';
				break;
			default:
				status.className = 'p-4 mb-4 rounded-lg border bg-gray-100 text-gray-800';
				break;
		}
	}

	function updateDebugInfo(): void {
		const roomIdElement = document.getElementById('room-id');
		const playerNumberElement = document.getElementById('player-number');
		
		if (roomIdElement) roomIdElement.textContent = roomId || '-';
		if (playerNumberElement) playerNumberElement.textContent = playerNumber || '-';
	}

	// === FONCTION DE CLEANUP ===
	return (): void => {
		console.log('Nettoyage du WebSocket test...');
		
		// Fermer la connexion WebSocket
		if (ws) {
			ws.close();
			ws = null;
		}
		
		// Retirer tous les event listeners
		connectBtn?.removeEventListener('click', handleConnect);
		disconnectBtn?.removeEventListener('click', handleDisconnect);
		joinQuickplayBtn?.removeEventListener('click', handleJoinQuickplay);
		playerReadyBtn?.removeEventListener('click', handlePlayerReady);
		sendInputBtn?.removeEventListener('click', handleSendInput);
		
		// Reset des variables
		roomId = null;
		playerNumber = null;
	};
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/HomeView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types";
import { Header } from "../components/Header";
import { VolumeControl } from "../components/VolumeControl";
import { 
    Button,
    SkinButton,
    SettingsButton,
	CoffeeButton
} from "../components/Button";


export const HomeView: ViewFunction = () => {
    return `
		${Header({ isLogged: false })}
        <div class="container ml-auto mr-auto">
            <h1 class="text-9xl text-amber-300">Pong</h1>
			${Button({ // -> syntax pour appeler la fonction creer dans les composants
				children: "Start game",
				variant: "primary",
				size: "lg",
				href: "/startgame",
				className: "flex justify-center align-center"
			})} 
			${SkinButton()}
			${SettingsButton()}
			${CoffeeButton()}
			<div class="fixed bottom-4 right-4 z-20 bg-black/50 backdrop-blur-sm rounded-lg">
            ${VolumeControl({ 
                initialVolume: 0,
                className: "w-32"
            })}
        </div>
        </div>
    `;
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/views/BracketView.ts
═══════════════════════════════════════════════════════
import type { ViewFunction } from "../router/types"
import { Header } from "../components/Header";

interface Match {
    id: string;
    tournamentId: string;
    round: number;
    position: number;
    player1?: { id: string; username: string; };
    player2?: { id: string; username: string; };
    winner?: { id: string; username: string; };
    status: 'pending' | 'ready' | 'in_progress' | 'finished';
}

interface Tournament {
    id: string;
    name: string;
    status: 'registration' | 'in_progress' | 'finished';
    maxPlayers: number;
    currentPlayers: any[];
    bracket: Match[];
    currentRound: number;
    winner?: { id: string; username: string; };
}

export const BracketView: ViewFunction = () => {
	return `
		${Header({isLogged: false})}
        <div class="relative container ml-auto mr-auto">
            <div id="tournament-loading" class="text-center p-8">
                <div>Chargement du tournoi...</div>
            </div>
            <div id="tournament-content" style="display: none;">
                <div id="tournament-header" class="mb-6"></div>
                <div id="tournament-brackets"></div>
            </div>
            <div id="tournament-error" style="display: none;" class="text-center p-8 text-red-500">
                <div>Erreur lors du chargement du tournoi</div>
            </div>
        </div>
	`
}

export const bracketLogic = (params: { id: string }): (() => void) => {
	const tournamentId = params.id;

    const fetchTournamentData = async (): Promise<void> => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/tournamentback/tournament/${tournamentId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const tournament: Tournament = await response.json();
			console.log(tournament)
            displayTournament(tournament);
            
        } catch (error) {
            console.error('Erreur lors de la récupération du tournoi:', error);
            showError();
        }
    };

	const displayTournament = (tournament: Tournament): void => {
        hideLoading();
        showContent();

        const headerElement = document.getElementById('tournament-header');
        if (headerElement) {
            headerElement.innerHTML = `
                <div class="bg-gray-800 p-4 rounded-lg mb-4">
                    <h2 class="text-2xl font-bold text-white mb-2">Tournoi ${tournament.name}</h2>
                    <div class="text-gray-300">
                        <span class="mr-4">Statut: <span class="text-blue-400">${getStatusText(tournament.status)}</span></span>
                        <span class="mr-4">Round actuel: <span class="text-green-400">${tournament.currentRound}</span></span>
                        ${tournament.winner ? `<span>Gagnant: <span class="text-yellow-400">${tournament.winner.username}</span></span>` : ''}
                    </div>
                </div>
            `;
        }

        const bracketsElement = document.getElementById('tournament-brackets');
        if (bracketsElement) {
            bracketsElement.innerHTML = generateBracketsHTML(tournament.bracket);
        }
		
    };

	const generateBracketsHTML = (matches: Match[]): string => {
        if (matches.length === 0) {
            return '<div class="text-center p-8 text-gray-500">Aucun match disponible</div>';
        }

        const matchesByRound = matches.reduce((acc, match) => {
            if (!acc[match.round]) {
                acc[match.round] = [];
            }
            acc[match.round].push(match);
            return acc;
        }, {} as Record<number, Match[]>);

        let html = '<div class="brackets-container">';
        
        Object.keys(matchesByRound).sort((a, b) => parseInt(a) - parseInt(b)).forEach(round => {
            const roundMatches = matchesByRound[parseInt(round)];
            html += `
                <div class="round mb-8">
                    <h3 class="text-xl font-semibold mb-4 ">Round ${round}</h3>
                    <div class="matches grid gap-4">
            `;
            
            roundMatches.forEach(match => {
                html += generateMatchHTML(match);
            });
            
            html += `
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        return html;
    };

	const generateMatchHTML = (match: Match): string => {
        const getStatusColor = (status: string): string => {
            switch (status) {
                case 'ready': return 'bg-blue-600';
                case 'in_progress': return 'bg-yellow-600';
                case 'finished': return 'bg-green-600';
                default: return 'bg-gray-600';
            }
        };

        return `
            <div class="match bg-gray-800 p-4 rounded-lg border-2 ${match.winner ? 'border-green-500' : 'border-gray-600'}">
                <div class="match-header mb-2">
                    <span class="text-sm ${getStatusColor(match.status)} text-white px-2 py-1 rounded">
                        ${getStatusText(match.status)}
                    </span>
                </div>
                <div class="players">
                    <div class="player ${match.winner?.id === match.player1?.id ? 'winner' : ''} p-2 mb-1 rounded ${match.winner?.id === match.player1?.id ? 'bg-green-700' : 'bg-gray-700'}">
                        <span class="text-white">${match.player1?.username || 'En attente...'}</span>
                        ${match.winner?.id === match.player1?.id ? '<span class="text-yellow-400 ml-2">👑</span>' : ''}
                    </div>
                    <div class="vs text-center text-gray-400 text-sm">VS</div>
                    <div class="player ${match.winner?.id === match.player2?.id ? 'winner' : ''} p-2 mt-1 rounded ${match.winner?.id === match.player2?.id ? 'bg-green-700' : 'bg-gray-700'}">
                        <span class="text-white">${match.player2?.username || 'En attente...'}</span>
                        ${match.winner?.id === match.player2?.id ? '<span class="text-yellow-400 ml-2">👑</span>' : ''}
                    </div>
                </div>
            </div>
        `;
    };

	const getStatusText = (status: string): string => {
        switch (status) {
            case 'registration': return 'Inscription';
            case 'in_progress': return 'En cours';
            case 'finished': return 'Terminé';
            case 'ready': return 'Prêt';
            case 'pending': return 'En attente';
            default: return status;
        }
    };

    const hideLoading = (): void => {
        const loading = document.getElementById('tournament-loading');
        if (loading) loading.style.display = 'none';
    };

    const showContent = (): void => {
        const content = document.getElementById('tournament-content');
        if (content) content.style.display = 'block';
    };

    const showError = (): void => {
        hideLoading();
        const error = document.getElementById('tournament-error');
        if (error) error.style.display = 'block';
    };

    fetchTournamentData();

    const pollInterval = setInterval(fetchTournamentData, 5000);

	// === FONCTION DE CLEANUP ===
	return (): void => {
		clearInterval(pollInterval);
	};
};



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/router/Router.ts
═══════════════════════════════════════════════════════
import type { Route, CleanupFunction, RouteParams } from './types';
import { ComponentManager } from '../components/ComponantManager'
import { HomeView } from '../views/HomeView';
import { TestView, initWebSocket } from '../views/TestView';
import { GameView } from '../views/GameView';
import { StartGameView } from '../views/StartGameView';
import { LoginView } from '../views/LoginView';
import { CreateAccountView } from '../views/CreateAccountView';
import { tournamentLogic, TournamentView } from '../views/TournamentView';
import { BracketView, bracketLogic } from '../views/BracketView';

export class Router {
    private routes: Route[];
	private currentCleanup: CleanupFunction | null = null;
    private componentManager: ComponentManager;
    
    constructor()
    {
        this.routes = [];
        this.componentManager = new ComponentManager();
        this.setupRoutes();
		this.setupLinkInterception();
		this.setupHistoryNavigation();
    }
    
    private setupRoutes(): void
    {
        this.routes.push({
            path: '/',
            view: HomeView,
            title: 'Accueil'
        });

		this.routes.push({
            path: '/test',
            view: TestView,
			onMount: initWebSocket,
            title: 'Test'
        });

		this.routes.push({
            path: '/game/:roomId',
            view: GameView,
            title: 'Test'
        });

        this.routes.push({
            path: '/tournament',
            view: TournamentView,
            onMount: tournamentLogic,
            title: 'Tournament'
        });

        this.routes.push({
            path: '/tournament/:id',
            view: BracketView,
            onMount: bracketLogic,
            title: 'Tounament brackets'
        });

		this.routes.push({
            path: '/startgame',
            view: StartGameView,
            title: 'Test'
        });

		this.routes.push({
            path: '/login',
            view: LoginView,
            title: 'Test'
        });

		this.routes.push({
            path: '/create',
            view: CreateAccountView,
            title: 'Test'
        });

        this.compileRoutes();
    }

    private compileRoutes(): void {
        this.routes.forEach(route => {
            if (route.path.includes(':'))
            {
                const paramNames: string[] = [];
                
                const regexPattern = route.path.replace(/:([^/]+)/g, (match, paramName) => {
                    paramNames.push(paramName);
                    return '([^/]+)';
                });

                route.regex = new RegExp(`^${regexPattern}$`);
                route.paramNames = paramNames;
            }
        });
    }

	private setupLinkInterception(): void
    {
		document.addEventListener('click', (e: MouseEvent) => {
			const target = e.target as HTMLElement;
			const link = target.closest('a');
			
			if (link && link instanceof HTMLAnchorElement)
            {
				const href = link.getAttribute('href');
				
				if (!href) return;
				
				if (this.isExternalLink(href))
                {
					return;
				}
				
				e.preventDefault();
				this.navigateTo(href);
			}
		});
	}

	private isExternalLink(href: string): boolean
    {
		return /^(https?:\/\/|mailto:|tel:|ftp:)/.test(href);
	}

	private setupHistoryNavigation(): void
    {
        window.addEventListener('popstate', () => {
            this.navigate(window.location.pathname, false);
        });
    }

	public navigateTo(path: string): void
    {
        if (window.location.pathname !== path)
        {
            window.history.pushState({}, '', path);
            this.navigate(path);
        }
    }
    
    public navigate(path: string, updateHistory: boolean = true): void {
        this.cleanup();
        
        const matchResult = this.findRoute(path);
        if (matchResult) {
            const { route, params } = matchResult;
            
            const htmlContent = route.view(params);
            const app = document.getElementById('app');
            if (app) {
                app.innerHTML = htmlContent;
            }
            
            document.title = route.title || 'Transcendence';
            
            if (updateHistory && window.location.pathname !== path) {
                window.history.pushState({}, '', path);
            }
            
            this.componentManager.scanAndMount();

            if (route.onMount) {
                const cleanup = route.onMount(params);
                if (cleanup && typeof cleanup === 'function') {
                    this.currentCleanup = cleanup;
                }
            }
        } else {
            this.show404();
        }
    }

	private cleanup(): void
    {
        this.componentManager.cleanupAll();

        if (this.currentCleanup)
        {
            this.currentCleanup();
            this.currentCleanup = null;
        }
    }
    
    private findRoute(path: string): { route: Route; params: RouteParams } | undefined {
        for (const route of this.routes)
        {
            if (!route.regex && route.path === path)
            {
                return { route, params: {} };
            }
            
            if (route.regex && route.paramNames)
            {
                const match = path.match(route.regex);
                if (match)
                {
                    const params: RouteParams = {};
                    
                    route.paramNames.forEach((paramName, index) => {
                        params[paramName] = match[index + 1];
                    });
                    
                    return { route, params };
                }
            }
        }
        
        return undefined;
    }
    
    private show404(): void
    {
        document.getElementById('app')!.innerHTML = '<h1>Erm... This page does not exist.</h1>';
    }
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/router/types.ts
═══════════════════════════════════════════════════════

export interface Route
{
	path: string;
	view: ViewFunction;
	onMount?: (params?: RouteParams) => CleanupFunction | void;
	title?: string;
	regex?: RegExp;
    paramNames?: string[];
}

export type ViewFunction = (params?: RouteParams) => string;
export type CleanupFunction = () => void;
export type RouteParams = Record<string, string>;



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/main.ts
═══════════════════════════════════════════════════════
import './style.css'
import { Router } from './router/Router';
import { registerComponents } from './components';
import { SimpleAuth } from './simpleAuth/SimpleAuth'

declare global {
    interface Window {
        router: Router;
        simpleAuth: SimpleAuth;
    }
}

registerComponents(); 

const auth = new SimpleAuth()
window.simpleAuth = auth;

const router = new Router();

const currentPath = window.location.pathname;
router.navigate(currentPath);

window.router = router;



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/net/wsTournament.ts
═══════════════════════════════════════════════════════

export interface registration
{
	id: string;
	name: string;
	currentPlayerCount: number;
}


type ServerMsg = 
	| {type: 'update', registrations: registration[]}
	| {type: 'tournament_started', tournamentId: string}
	| {type: 'error', message: string}

export type ClientMessage =
	| {type: 'join', tournamentId: string | null, username: string, playerId: string}

export class wsTournament {
	private ws?: WebSocket | null = null;
	private tournamentBtns;
	private id: string | null

	constructor(elems: NodeListOf<Element>)
	{
		this.tournamentBtns = elems
		this.id = window.simpleAuth.getPlayerId()
	}

	connect(url?: string) {
		const host = import.meta.env.VITE_HOST
		const endpoint = import.meta.env.VITE_TOURNAMENT_WS_ENDPOINT
		const defaultUrl = (host && endpoint) ? `wss://${host}${endpoint}`
					: 'wss://localhost:8443/tournamentback/ws';
		console.log(`tournament ws link: `, defaultUrl)
		this.ws = new WebSocket(url ?? defaultUrl);

		this.ws.onmessage = (ev) => {
			const msg = JSON.parse(ev.data) as ServerMsg;
			console.log(msg)
			switch (msg.type)
			{
				case 'update':
					this.tournamentBtns.forEach(btn => {
						const span: HTMLSpanElement | null = btn.querySelector("span");
						msg.registrations.forEach(tournament => {
							const slots = btn.getAttribute('data-slots')
							if (tournament.name === slots + 'p')
							{
								span!.innerText = `${tournament.currentPlayerCount}/${slots}`
								btn.setAttribute("data-tournament-id", tournament.id)
							}
						})
					})
					break

				case 'tournament_started':
                    this.startCountdownAndRedirect(msg.tournamentId);
                    break;

			}
		};

		this.ws.onopen = () => {
            console.log('WebSocket connected with player ID:', window.simpleAuth.getPlayerId());
            window.simpleAuth.renewSession();
        };
	}

	private startCountdownAndRedirect(tournamentId: string): void {
		const countdownModal = document.getElementById('countdown');
		const countdownText = document.getElementById('countdown-text');
		
		if (!countdownModal || !countdownText) return;

		let count = 3;
		countdownModal.style.display = 'block';
		countdownText.textContent = count.toString();

		const countdownInterval = setInterval(() => {
			count--;
			
			if (count > 0) {
				countdownText.textContent = count.toString();
			} else {
				clearInterval(countdownInterval);
				countdownModal.style.display = 'none';
				window.location.href = `/tournament/${tournamentId}`;
			}
		}, 1000);
	}

	join(tournamentId: string | null, username: string) {
		const msg: ClientMessage = {
			type: 'join',
			tournamentId: tournamentId,
			username: username,
			playerId: this.id as string
		}
		this.ws?.send(JSON.stringify(msg))
	}

	close(): void
	{
		if (this.ws) {
			this.ws.close();
			this.ws = null;
		}
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/frontend/src/net/wsClient.ts
═══════════════════════════════════════════════════════
export type PublicState = {
	leftPaddle: {y: number; speed: number; intention: number};
	rightPaddle: {y: number; speed: number; intention: number};
	balls: {x: number; y: number; vx: number; vy: number; radius: number}[];
	score: {left: number; right: number};
	isPaused: boolean;
	isGameOver: boolean;
	winner: '' | 'left' | 'right';
	countdownValue: number;
	powerUps: {x: number, y: number, radius: number}[];
	splitActive: boolean;
	clock: number;
	smash: {
		cooldown: number;
		animDuration: number;
		left: {cooldownRemaining: number; lastSmashAt: number};
		right: {cooldownRemaining: number; lastSmashAt: number};
	};
};

type ServerMsg = 
	| {type: 'welcome'; side: 'left' | 'right'}
	| {type: 'state'; state: PublicState; serverTime: number}
	| {type: 'countdown'; value: number}
	| {type: 'paused' | 'resumed'}
	| {type: 'gameover'; winner: 'left' | 'right'}
	| {type: 'pong'; t: number};

export class WSClient {
	private ws?: WebSocket;
	side: 'left' | 'right' = 'left';

	onState?: (s: PublicState) => void;
	onCountdown?: (v: number) => void;
	onGameOver?: (w: 'left' | 'right') => void;

	connect(url?: string) {
		const host = import.meta.env.VITE_HOST
		const endpoint = import.meta.env.VITE_GAME_ENDPOINT
		const defaultUrl = (host && endpoint) ? `wss://${host}${endpoint}`
					: undefined;
		const finalUrl = url ?? defaultUrl;
        if (!finalUrl)
        {
            console.warn('WSClient: no URL provided and no defaultUrl');
            return;
        }
        console.log('WSClient: connecting to', finalUrl);
        this.ws = new WebSocket(finalUrl);

		this.ws.onmessage = (ev) => {
			console.log(ev.data)
			const msg = JSON.parse(ev.data) as ServerMsg;
			switch (msg.type) {
				case 'welcome':
					console.log('Welcome from server');
					this.side = msg.side; 
					break;
				case 'state':
					this.onState?.(msg.state);
					break;
				case 'countdown':
					this.onCountdown?.(msg.value);
					break;
				case 'gameover':
					this.onGameOver?.(msg.winner);
					break;
			}
		};
	}
	sendInput(up: boolean, down: boolean) {
		this.ws?.send(JSON.stringify({type: 'input', up, down}));
	}
	pause() {
		this.ws?.send(JSON.stringify({type: 'pause'}));
	}
	resume() {
		this.ws?.send(JSON.stringify({type: 'resume'}));
	}
	smash() {
		this.ws?.send(JSON.stringify({type: 'smash'}));
	}
}



═══════════════════════════════════════════════════════
FILE: ./apps/tournamentback/tournament.ts
═══════════════════════════════════════════════════════
import { FastifyInstance } from 'fastify'
import { TournamentManager } from './TournamentManager'
import { Player, ClientMessage, ServerMessage } from './types'
import { v4 as uuidv4 } from 'uuid'
import https from 'https'

const tournamentManager = new TournamentManager()
tournamentManager.initTournaments()

const isDevelopment = process.env.NODE_ENV === 'development'
const agent = isDevelopment ? new https.Agent({ rejectUnauthorized: false }) : undefined

export function handleTournament(fastify: FastifyInstance)
{
	fastify.get('/ws', { websocket: true }, (connection, request) => {
		console.log(`New WebSocket connexion /tournamentback/ws`)
		let currentPlayerId: string | null = null;

		sendMessage({type: 'update', registrations: tournamentManager.getCurrentRegistrations()})

		connection.on('message', (rawMessage) => {
			try
			{
				const msg: ClientMessage = JSON.parse(rawMessage.toString())
				console.log(`Message received: `, msg)

				switch (msg.type)
				{
					case 'join':
						currentPlayerId = msg.playerId;
						handleJoinTournament(msg, connection)
						break
					default:
						sendError(`Unknown message type`)
				}
			}
			catch (err)
			{
				console.log(`Parse error:`, err)
				sendError(`Invalid input`)
			}
		})

        connection.on('close', () => {
            console.log('WebSocket connection closed');
            if (currentPlayerId)
			{
                tournamentManager.removePlayerConnection(currentPlayerId);
                const removed = tournamentManager.removePlayerFromAllRegistrations(currentPlayerId);
                if (removed)
				{
                    console.log(`Player ${currentPlayerId} removed from all registrations due to connection close`);
                }
            }
        });

		function handleJoinTournament(msg: ClientMessage, socket: WebSocket)
		{
			tournamentManager.setPlayerConnection(msg.playerId, socket);

			const newPlayer : Player= {
				id: msg.playerId,
				username: msg.username,
				currentTournament: msg.tournamentId,
				isEleminated: false,
			}
			tournamentManager.registerPlayer(msg.tournamentId, newPlayer);

			const success = tournamentManager.registerPlayer(msg.tournamentId, newPlayer);
            if (success)
			{
                console.log(`Player ${msg.username} (${msg.playerId}) switched to tournament ${msg.tournamentId}`)
            }
			else
			{
                sendError(`Cannot join tournament: tournament full or unavailable`)
            }
		}

		function sendMessage(message: ServerMessage)
		{
			try
			{
				connection.send(JSON.stringify(message))
			}
			catch (err)
			{
				console.error(`Response sending error:`, err)
			}
		}

		function sendError(errorMessage: string)
		{
			sendMessage({ type: 'error', message: errorMessage })
		}
	})

	fastify.get('/tournament/:id/brackets', async (request, reply) => {
        const { id } = request.params as { id: string };
        
        const brackets = tournamentManager.getTournamentBrackets(id);
        
        if (!brackets)
		{
            return reply.status(404).send({ error: 'Tournament not found' });
        }
        
        return { tournamentId: id, brackets };
    });

    fastify.get('/tournament/:id', async (request, reply) => {
        const { id } = request.params as { id: string };
        
        const tournament = tournamentManager.getTournamentDetails(id);
        
        if (!tournament)
		{
            return reply.status(404).send({ error: 'Tournament not found' });
        }
        
        return tournament;
    });
}



═══════════════════════════════════════════════════════
FILE: ./apps/tournamentback/server.ts
═══════════════════════════════════════════════════════
import Fastify from 'fastify'
import websocket from '@fastify/websocket'
import { handleTournament } from './tournament'

const fastify = Fastify({
	logger: true
})

await fastify.register(websocket)

fastify.addHook('onRequest', async (request, reply) => {
    console.log('=== REQUÊTE REÇUE ===')
    console.log('URL:', request.url)
    console.log('Method:', request.method)
    console.log('Headers:', JSON.stringify(request.headers, null, 2))
    console.log('====================')
})


fastify.get('/', function (request, reply)
	{
		reply.send({ hello: 'world' })
	}
)

handleTournament(fastify);

fastify.listen({ port: 3040, host: '0.0.0.0'}, function (err, address)
	{
		if (err)
		{
			fastify.log.error(err)
			process.exit(1)
		}	
		fastify.log.info(`server listening on ${address}`)
	}
)



═══════════════════════════════════════════════════════
FILE: ./apps/tournamentback/types.ts
═══════════════════════════════════════════════════════
export interface Player
{
	id: string;
	username: string;
	currentTournament?: string;
	isEleminated: boolean;
}

export interface PlayerConnection {
    playerId: string;
    ws: WebSocket;
    connectedAt: Date;
}

export interface Match
{
	id: string;
	tournamentId: string;
	round: number;
	position: number;
	player1?: Player;
	player2?: Player;
	winner?: Player;
	roomId?: string;
	status: 'pending' | 'ready' | 'in_progress' | 'finished';
	scheduledAt?: Date;
	finishedAt?: Date;
}

export interface Tournament
{
	id: string;
	name: string;
	status: 'registration' | 'in_progress' | 'finished';
	maxPlayers: number;
	currentPlayers: Player[];
	bracket: Match[];
	currentRound: number;
	winner?: Player;
	createdAt: Date;
	StartedAt?: Date;
	finishedAt?: Date;
}

export interface registration
{
	id: string;
	name: string;
	currentPlayerCount: number;
}

export type ClientMessage =
	| {type: 'join', tournamentId: string, username: string, playerId: string}

export type ServerMessage = 
	| {type: 'update', registrations: registration[]}
	| {type: 'tournament_started', tournamentId: string}
	| {type: 'error', message: string}



═══════════════════════════════════════════════════════
FILE: ./apps/tournamentback/TournamentManager.ts
═══════════════════════════════════════════════════════
import type { ClientMessage, ServerMessage, Match, Player, PlayerConnection, registration, Tournament } from "./types";
import { v4 as uuidv4 } from 'uuid'

export class TournamentManager
{
	private tournaments = new Map<string, Tournament>()
	private playerConnections = new Map<string, PlayerConnection>();

	initTournaments(): void
	{
		this.createTournament("4p", 4);
		this.createTournament("8p", 8);
		this.createTournament("16p", 16);
	}

	getCurrentRegistrations(): registration[]
	{
		let currentRegistrations: registration[] = []

		this.tournaments.forEach(tournament => {
			if ('registration' === tournament.status)
			{
				const registration: registration = {
					id: tournament.id,
					name: tournament.name,
					currentPlayerCount: tournament.currentPlayers.length
				}
				currentRegistrations.push(registration)
			}
		})

		return currentRegistrations;
	}

	createTournament(name: string, maxPlayers: number): Tournament
	{
		const tournament: Tournament = {
			id: uuidv4(),
			name,
			status: 'registration',
			maxPlayers,
			currentPlayers: [],
			bracket: [],
			currentRound: 0,
			createdAt: new Date()
		}

		this.tournaments.set(tournament.id, tournament);
		return tournament;
	}

    registerPlayer(tournamentId: string, newPlayer: Player): boolean
	{
        const tournament = this.tournaments.get(tournamentId);
        if (!tournament || tournament.status !== 'registration') return false;
        if (tournament.currentPlayers.length >= tournament.maxPlayers) return false;

        this.removePlayerFromOtherRegistrations(newPlayer.id, tournamentId);

        const isPlayerInTournament = tournament.currentPlayers.some(
            player => player.id === newPlayer.id
        );
        
        if (!isPlayerInTournament)
		{
            tournament.currentPlayers.push(newPlayer);
        }

        if (tournament.currentPlayers.length === tournament.maxPlayers)
		{
            this.startTournament(tournamentId);
            this.notifyTournamentStart(tournamentId);
        }

        this.updateAllRegistrations();
        return true;
    }

	removePlayerFromRegistration(playerId: string): boolean
	{
		for (const [_, tournament] of this.tournaments)
		{
			if (tournament.status === 'registration')
			{
				const playerIndex = tournament.currentPlayers.findIndex(p => p.id === playerId);
				if (playerIndex !== -1)
				{
					tournament.currentPlayers.splice(playerIndex, 1);

					console.log(`Player ${playerId} removed from tournament ${tournament.name}`);
					this.updateAllRegistrations();
					return true;
				}
			}
		}
		return false;
	}

	removePlayerFromOtherRegistrations(playerId: string, excludeTournamentId: string): void
	{
		for (const [tournamentId, tournament] of this.tournaments)
		{
			if (tournament.status === 'registration' && tournamentId !== excludeTournamentId)
			{
				const playerIndex = tournament.currentPlayers.findIndex(p => p.id === playerId);
				if (playerIndex !== -1)
				{
					tournament.currentPlayers.splice(playerIndex, 1);
					console.log(`Player ${playerId} removed from tournament ${tournament.name} (switching tournaments)`);
				}
			}
		}
	}

	removePlayerFromAllRegistrations(playerId: string): boolean
	{
		let removed = false;
		for (const [_, tournament] of this.tournaments)
		{
			if (tournament.status === 'registration')
			{
				const playerIndex = tournament.currentPlayers.findIndex(p => p.id === playerId);
				if (playerIndex !== -1)
				{
					tournament.currentPlayers.splice(playerIndex, 1);
					console.log(`Player ${playerId} removed from tournament ${tournament.name}`);
					removed = true;
				}
			}
		}
		if (removed)
		{
			this.updateAllRegistrations();
		}
		return removed;
	}

	startTournament(tournamentId: string): void
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return;

		const shuffledPlayers = this.shuffleArray([... tournament.currentPlayers])

		const firstRoundMatches: Match[] = [];
		for (var i = 0; i < shuffledPlayers.length; i += 2)
		{
			const match: Match = {
				id: uuidv4(),
				tournamentId,
				round: 1,
				position: Math.floor(i / 2),
				player1: shuffledPlayers[i],
				player2: shuffledPlayers[i + 1],
				status: 'ready'
			};
			firstRoundMatches.push(match);
		}

		tournament.bracket = firstRoundMatches;
		tournament.status = 'in_progress';
		tournament.currentRound = 1;
		tournament.StartedAt = new Date();

		this.createTournament(tournament.name, tournament.maxPlayers)

		//this.startNextMatch(tournamentId);
	}

	async startNextMatch(tournamentId: string): Promise<void>
	{
		const tournament = this.tournaments.get(tournamentId)
		if (!tournament) return;

		const nextMatch = tournament.bracket.find(m => {
			m.status === 'ready' &&
			m.round === tournament.currentRound &&
			m.player1 && m.player2
		})

		if (!nextMatch)
		{
			this.checkRoundCompletion(tournamentId);
			return;
		}

		try
		{
			const response = await fetch('https://localhost:8443/quickplay/tournament-match', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json'},
				body: JSON.stringify({
					matchId: nextMatch.id,
					player1: nextMatch.player1,
					player2: nextMatch.player2,
					tournamentId: tournament.id
				})
			})

			const { roomId } = await response.json();
			nextMatch.roomId = roomId;
			nextMatch.status = 'in_progress'

			console.log(`Match started: ${nextMatch.player1?.username} vs ${nextMatch.player2?.username}`)
			this.notifyPlayers(nextMatch, {type: 'match_ready'});
		}
		catch (err)
		{
			console.error('Failed to create  tournament match:', err);
		}
	}

	onMatchFinished(matchId: string, winnerId: string): void
	{
		const match = this.findMatchById(matchId);
		if (match === null) return;

		const tournament = this.tournaments.get(match.tournamentId)
		if (!tournament) return;

		match.winner = match.player1?.id === winnerId ? match.player1 : match.player2
		match.status = 'finished'
		match.finishedAt = new Date();

		console.log(`Match finished: ${match.winner?.username} wins!`)

		this.checkRoundCompletion(match.tournamentId);
	}

	checkRoundCompletion(tournamentId: string): void
	{
		const tournament = this.tournaments.get(tournamentId)
		if (!tournament) return;

		const currentRoundMatches = tournament.bracket.filter(m => m.round === tournament.currentRound);
		const finishedMatches = currentRoundMatches.filter(m => m.status === 'finished');

		if (finishedMatches.length === currentRoundMatches.length)
		{
			if (finishedMatches.length === 1 && tournament.currentRound > 1)
			{
				tournament.winner = finishedMatches[0].winner;
				tournament.status = 'finished';
				tournament.finishedAt = new Date();

				console.log(`Tournament finished! Winner: ${tournament.winner?.username}`);
				this.notifyTournamentEnd(tournament);
				return
			}

			this.createNextRound(tournament, finishedMatches);
		}

		this.startNextMatch(tournamentId);
	}

	createNextRound(tournament: Tournament, previousMatches: Match[]): void
	{
		const nextRound = tournament.currentRound + 1;
		const winners = previousMatches.map(m => m.winner!).filter(Boolean)

		const nextRoundMatches: Match[] = [];
		for (let i = 0; i < winners.length; i += 2)
		{
			if (winners[i + 1])
			{
				const match: Match = {
					id: uuidv4(),
					tournamentId: tournament.id,
					round: nextRound,
					position: Math.floor(i / 2),
					player1: winners[i],
					player2: winners[i + 1],
					status: 'ready'
				};
				nextRoundMatches.push(match)
			}
		}

		tournament.bracket.push(...nextRoundMatches);
		tournament.currentRound = nextRound;

		console.log(`Round ${nextRound} created with ${nextRoundMatches.length} matches`);
	}

    notifyTournamentEnd(tournament: Tournament): void
	{
        const message = { type: 'tournamentEnd', winner: `${tournament.winner?.username}` };
        
        tournament.currentPlayers.forEach(player => {
            const connection = this.getPlayerConnection(player.id);
            if (connection && connection.ws.readyState === connection.ws.OPEN)
			{
                try
				{
                    connection.ws.send(JSON.stringify(message));
                }
				catch (err)
				{
                    console.error("Error notifying player:", err);
                }
            }
        });
    }

    notifyPlayers(match: Match, message: object): void
	{
        if (match.player1)
		{
            const connection1 = this.getPlayerConnection(match.player1.id);
            if (connection1 && connection1.ws.readyState === connection1.ws.OPEN)
			{
                try
				{
                    connection1.ws.send(JSON.stringify(message));
                }
				catch (err)
				{
                    console.error("Error notifying player1:", err);
                }
            }
        }

        if (match.player2)
		{
            const connection2 = this.getPlayerConnection(match.player2.id);
            if (connection2 && connection2.ws.readyState === connection2.ws.OPEN)
			{
                try
				{
                    connection2.ws.send(JSON.stringify(message));
                }
				catch (err)
				{
                    console.error("Error notifying player2:", err);
                }
            }
        }
    }

	notifyTournamentStart(tournamentId: string): void
	{
        const tournament = this.tournaments.get(tournamentId);
        if (!tournament) return;

        const message = {
            type: 'tournament_started',
            tournamentId: tournamentId
        };

        console.log(`Notifying ${tournament.currentPlayers.length} players that tournament ${tournament.name} has started`);

        tournament.currentPlayers.forEach(player => {
            const connection = this.getPlayerConnection(player.id);
            if (connection && connection.ws.readyState === connection.ws.OPEN)
			{
                try
				{
                    connection.ws.send(JSON.stringify(message));
                }
				catch (err)
				{
                    console.error(`Error notifying player ${player.username}:`, err);
                }
            }
        });
	}

    updateAllRegistrations(): void
	{
        const registrations = this.getCurrentRegistrations();
        const updateMsg: ServerMessage = { type: 'update', registrations };

        this.tournaments.forEach(tournament => {
            if (tournament.status === 'registration')
			{
                tournament.currentPlayers.forEach(player => {
                    const connection = this.getPlayerConnection(player.id);
                    if (connection && connection.ws.readyState === connection.ws.OPEN)
					{
                        try
						{
                            connection.ws.send(JSON.stringify(updateMsg));
                        }
						catch (err)
						{
                            console.error("Error updating player:", err);
                        }
                    }
                });
            }
        });
    }

	findMatchById(id: string) : Match | null
	{
		let match: Match | undefined;
		this.tournaments.forEach(tournament => {
			match = tournament.bracket.find(m => {
				m.id === id;
			})
		})

		if (match != undefined)
			return match
		return null;
	}

	cleanupClosedConnections(): void
	{
        for (const [playerId, connection] of this.playerConnections)
		{
            if (connection.ws.readyState === connection.ws.CLOSED)
			{
                this.playerConnections.delete(playerId);
                console.log(`Cleaned up closed connection for player ${playerId}`);
            }
        }
    }

	setPlayerConnection(playerId: string, ws: WebSocket): void
	{
		this.playerConnections.set(playerId, {
			playerId,
			ws,
			connectedAt: new Date()
		});
    }

    removePlayerConnection(playerId: string): void
	{
        this.playerConnections.delete(playerId);
    }

    getPlayerConnection(playerId: string): PlayerConnection | undefined
	{
        return this.playerConnections.get(playerId);
    }

	getTournamentBrackets(tournamentId: string): Match[] | null
	{
		const tournament = this.tournaments.get(tournamentId);
		if (!tournament) return null;
		
		return tournament.bracket;
	}

	getTournamentDetails(tournamentId: string): Tournament | null
	{
		const tournament = this.tournaments.get(tournamentId);
		return tournament || null;
	}

	private shuffleArray<T>(array: T[]): T[]
	{
		const shuffled = [...array];

		for (let i = shuffled.length - 1; i > 0; i--)
		{
			const randIdx = Math.floor(Math.random() * (i + 1));
			[shuffled[i], shuffled[randIdx]] = [shuffled[randIdx], shuffled[i]]
		}

		return shuffled
	}
}
