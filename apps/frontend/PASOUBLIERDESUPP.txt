
// ==============================================
// üìÑ ./vite.config.ts
// ==============================================
import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
	server: {
		host: '0.0.0.0',
		port: 5173,
		allowedHosts: true
	},
	plugins: [
		tailwindcss(),
	],
})

// ==============================================
// üìÑ ./src/simpleAuth/SimpleAuth.ts
// ==============================================
import { v4 as uuidv4 } from 'uuid'

class CookieManager {
    static setCookie(name: string, value: string | null, days: number = 7): void
	{
        const expires = new Date();
        expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Strict`;
    }

    static getCookie(name: string): string | null
	{
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++)
		{
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }

    static deleteCookie(name: string): void
	{
        document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
    }
}

export class SimpleAuth
{
    private static readonly COOKIE_NAME = 'player_session';
    private static readonly USERNAME_KEY = 'player_username';
    private playerId: string | null;
    private username: string = 'Anon';

    constructor()
	{
        this.playerId = this.getOrCreatePlayerId();
        this.username = localStorage.getItem(SimpleAuth.USERNAME_KEY) || 'Anon';
    }

    setUsername(username: string): void {
        this.username = username;
        localStorage.setItem(SimpleAuth.USERNAME_KEY, username);
    }

    private getOrCreatePlayerId(): string | null
	{
        let playerId = CookieManager.getCookie(SimpleAuth.COOKIE_NAME);
        
        if (!playerId)
		{
            playerId = uuidv4();
            CookieManager.setCookie(SimpleAuth.COOKIE_NAME, playerId, 30);
            console.log('New player ID created:', playerId);
        }
		else
		{
            console.log('Existing player ID found:', playerId);
        }
        
        return playerId;
    }

    getPlayerId(): string | null
	{
        return this.playerId;
    }

    getUsername(): string {
        return (this.username);
    }

    renewSession(): void
	{
        CookieManager.setCookie(SimpleAuth.COOKIE_NAME, this.playerId, 30);
    }

    logout(): void
	{
        CookieManager.deleteCookie(SimpleAuth.COOKIE_NAME);
        this.playerId = uuidv4();
        CookieManager.setCookie(SimpleAuth.COOKIE_NAME, this.playerId, 30);
    }
}

// ==============================================
// üìÑ ./src/components/PongGame/PongGame.ts
// ==============================================
import type { Component } from "../types";
import { WSClient, type PublicState } from "../../net/wsClient";
import type { TimeoutStatus } from "./types";
import { PongRenderer } from "./PongRenderer";
import { PongInputHandler } from "./PongInput";
import { PongParticleSystem } from "./PongParticles";
import { PongAssets } from "./PongAssets";
import { WORLD_HEIGHT, WORLD_WIDTH } from "./constants";
import { DebugPanel, type DebugPanelCallbacks } from "../DebugPanel";
import { PongAI } from "./PongAI";
import { LocalTournamentManager } from "../../utils/localTournamentManager";

type LocalGameConfig = {
	roomId: string;
	left: { id: string; username: string; selectedSkill?: 'smash' | 'dash' };
	right: { id: string; username: string; selectedSkill?: 'smash' | 'dash' };
};

class GameStatsMonitor {
	private fpsFrames: number[] = [];
	private lastFrameTime: number = performance.now();
	private pingTimes: number[] = [];
	private currentFPS: number = 0;
	
	recordFrame(): void {
		const now = performance.now();
		const delta = now - this.lastFrameTime;
		this.lastFrameTime = now;
		
		if (delta > 0) {
			const fps = 1000 / delta;
			this.fpsFrames.push(fps);
			
			if (this.fpsFrames.length > 60) {
				this.fpsFrames.shift();
			}
			
			const avgFps = this.fpsFrames.reduce((a, b) => a + b, 0) / this.fpsFrames.length;
			this.currentFPS = Math.round(avgFps);
		}
	}
	
	getCurrentFPS(): number {
		return this.currentFPS;
	}
	
	addPing(ping: number): void {
		this.pingTimes.push(ping);
		if (this.pingTimes.length > 10) {
			this.pingTimes.shift();
		}
	}
	
	getAveragePing(): number {
		if (this.pingTimes.length === 0) return 0;
		const avg = this.pingTimes.reduce((a, b) => a + b, 0) / this.pingTimes.length;
		return Math.round(avg);
	}
}

export class PongGame implements Component {
	private el: HTMLElement;
	private canvas: HTMLCanvasElement;

	private net: WSClient;
	private secondaryNet?: WSClient;
	private renderer: PongRenderer;
	private input: PongInputHandler;
	private particles: PongParticleSystem;
	private assets: PongAssets;
	private debugPanel?: DebugPanel;
	private debugContainer?: HTMLDivElement;
	private isLocalMode = false;
	private localConfig?: LocalGameConfig;
	private leftController?: WSClient;
	private rightController?: WSClient;
	private aiNet?: WSClient;
	private statsMonitor: GameStatsMonitor;
	private lastPingTime: number = 0;
	private statsUpdateInterval: number | null = null;
    private aiControllers: { left?: PongAI; right?: PongAI } = {};

	private state: PublicState = {
		leftPaddle: {y: WORLD_HEIGHT / 2, speed: 0, intention: 0},
		rightPaddle: {y: WORLD_HEIGHT / 2, speed: 0, intention: 0},
		balls: [],
		score: {left: 0, right: 0},
		isPaused: true,
		isGameOver: false,
		winner: '',
		countdownValue: 0,
		powerUps: [],
		splitActive: false,
		clock: 0,
		blackoutLeft: false,
		blackoutRight: false,
		blackoutLeftIntensity: 0,
		blackoutRightIntensity: 0,
		blackholeActive: false,
		blackholeCenterX: 0,
		blackholeCenterY: 0,
		blackholeProgress: 0,
		selectedSkills: {
			left: 'smash',
			right: 'smash'
		},
		skillStates: {
			left: {cooldownRemaining: 0, lastActivationAt: -1e9},
			right: {cooldownRemaining: 0, lastActivationAt: -1e9}
		}
	};

	private timeoutStatus: TimeoutStatus = {
		leftActive: false,
		leftRemainingMs: 0,
		rightActive: false,
		rightRemainingMs: 0
	};

	private animationFrameId: number | null = null;
	private lastScore = { left: 0, right: 0 };
	private lastBallPositions: Array<{x: number; y: number; vx: number; vy: number}> = [];
	private isDebugMode: boolean = false;
	private gameOverHandled: boolean = false;

	constructor(element: HTMLElement) {
		this.el = element;

		const canvas = this.el.querySelector('#pong-canvas') as HTMLCanvasElement | null;
		if (!canvas)
		{
			throw new Error('PongGame: canvas not found in the component.');
		}
		this.canvas = canvas;

		this.net = new WSClient();
		this.localConfig = this.loadLocalConfig();
		if (this.localConfig) {
			this.secondaryNet = new WSClient();
			this.isLocalMode = true;
		}

		this.renderer = new PongRenderer(this.canvas, this.net);
		this.particles = new PongParticleSystem();
		this.assets = new PongAssets();
		this.input = new PongInputHandler(this.net, this.secondaryNet);
		this.statsMonitor = new GameStatsMonitor();

		this.setupNetworkHandlers();
		if (this.secondaryNet) {
			this.setupSecondaryNetworkHandlers();
		}
		this.setupEventHandlers();
		this.connectToServer();
		this.startAnimationLoop();
        this.startStatsMonitoring();

		this.setupAIHooks();
	}

	private startStatsMonitoring(): void {
		// Mettre √† jour l'affichage des stats toutes les 500ms
		this.statsUpdateInterval = setInterval(() => {
			this.updateStatsDisplay();
		}, 500) as unknown as number;
		
		// Envoyer des pings toutes les 2 secondes
		this.pingInterval = setInterval(() => {
			this.sendPing();
		}, 2000) as unknown as number;
	}
	
	private sendPing(): void {
		this.lastPingTime = performance.now();
		this.net.sendPing();
	}
	
	private updateStatsDisplay(): void {
		// FPS
		const fps = this.statsMonitor.getCurrentFPS();
		const fpsElement = document.getElementById('fps-value');
		if (fpsElement) {
			fpsElement.textContent = fps.toString();
			fpsElement.className = fps >= 55 ? 'stat-good' : fps >= 30 ? 'stat-medium' : 'stat-bad';
		}
		
		// Ping
		const ping = this.statsMonitor.getAveragePing();
		const pingElement = document.getElementById('ping-value');
		if (pingElement) {
			pingElement.textContent = ping > 0 ? `${ping}ms` : '--ms';
			pingElement.className = ping < 50 ? 'stat-good' : ping < 100 ? 'stat-medium' : 'stat-bad';
		}
		
		// Connection status
		const wsState = this.net['ws']?.readyState;
		const statusElement = document.getElementById('connection-status');
		const wsIndicator = document.getElementById('ws-indicator');
		const connectionIndicator = document.getElementById('connection-indicator');
		
		if (statusElement && wsIndicator && connectionIndicator) {
			if (wsState === WebSocket.OPEN) {
				statusElement.textContent = 'CONNECTION: STABLE';
				wsIndicator.className = 'w-2 h-2 bg-green-400 rounded-full animate-pulse';
				connectionIndicator.className = 'status-indicator w-3 h-3 bg-green-400 rounded-full';
			} else if (wsState === WebSocket.CONNECTING) {
				statusElement.textContent = 'CONNECTION: CONNECTING...';
				wsIndicator.className = 'w-2 h-2 bg-yellow-400 rounded-full animate-pulse';
				connectionIndicator.className = 'status-indicator w-3 h-3 bg-yellow-400 rounded-full';
			} else {
				statusElement.textContent = 'CONNECTION: DISCONNECTED';
				wsIndicator.className = 'w-2 h-2 bg-red-400 rounded-full animate-pulse';
				connectionIndicator.className = 'status-indicator w-3 h-3 bg-red-400 rounded-full';
			}
		}
	}

	private setupNetworkHandlers(): void {
		this.net.onState = (s: PublicState) => {
			const currentBallPositions = s.balls.map(b => ({
				x: b.x,
				y: b.y,
				vx: b.vx,
				vy: b.vy
			}))
			if (s.score.left > this.lastScore.left)
			{
				const lastBall = this.lastBallPositions.find(b => b.x > WORLD_WIDTH - 100);
				if (lastBall)
				{
					this.particles.createGoalExplosion(
						lastBall.x,
						lastBall.y,
						lastBall.vx,
						lastBall.vy
					);
				}
				this.triggerScreenShake();
			}
			if (s.score.right > this.lastScore.right)
			{
				const lastBall = this.lastBallPositions.find(b => b.x < 100);
				if (lastBall)
				{
					this.particles.createGoalExplosion(
						lastBall.x,
						lastBall.y,
						lastBall.vx,
						lastBall.vy
					);
				}
				this.triggerScreenShake();
			}
			this.lastBallPositions = currentBallPositions;
			this.lastScore = {left: s.score.left, right: s.score.right};

			for (const ball of s.balls) {
				this.particles.createTrail(ball.x, ball.y, ball.vx, ball.vy);
			}

			Object.assign(this.state, s);
			if (this.debugPanel && this.isDebugMode) 
			{
				this.debugPanel.updateStats(s, this.particles.getParticles().length);
			}
		};

		this.net.onPaused = () => {
			this.state.isPaused = true;
			this.timeoutStatus = {
				leftActive: false,
				leftRemainingMs: 0,
				rightActive: false,
				rightRemainingMs: 0
			};
		};

		this.net.onTimeoutStatus = (status) => {
			this.timeoutStatus = {
				leftActive: status.left.active,
				leftRemainingMs: status.left.remainingMs,
				rightActive: status.right.active,
				rightRemainingMs: status.right.remainingMs
			};
		};

		this.net.onCountdown = (v: number) => {
			this.state.countdownValue = v;
		};

		this.net.onGameOver = (winner, isTournament, tournamentId) => {
			if (this.gameOverHandled) {
				console.log('Game over already handled, skipping...');
				return;
			}
			this.gameOverHandled = true;
			
			console.log('Game Over!', {winner, isTournament, tournamentId});
			this.particles.createExplosion(
				this.canvas.width / 2,
				this.canvas.height / 2,
				30
			);
			
			const forfeitBtn = document.getElementById('forfeit-btn') as HTMLButtonElement;
			if (forfeitBtn) {
				forfeitBtn.disabled = true;
			}
			
			if (isTournament && tournamentId)
			{
				this.handleTournamentGameOver(winner, tournamentId);
			}
			else
			{
				this.handleQuickplayGameOver(winner);
			}
		};

		this.net.onPong = (serverTime: number) => {
			const roundTripTime = performance.now() - this.lastPingTime;
			this.statsMonitor.addPing(roundTripTime);
		};

		this.net.onWelcome = this.createWelcomeHandler(this.net);
	}

	private enableDebugMode(): void {
		this.isDebugMode = true;
		console.log('Debug Mode Enabled!');

		const container = document.createElement('div');
		container.id = 'debug-panel-container';
		container.style.marginTop = '16px';

		this.canvas.insertAdjacentElement('afterend', container);
		this.debugContainer = container;

		const callbacks: DebugPanelCallbacks = {
			onActivatePowerUp: (type) => this.debugActivatePowerUp(type),
			onClearPowerUps: () => this.debugClearPowerUps(),
			onScoreChange: (side, amount) => this.debugChangeScore(side, amount),
			onResetScore: () => this.debugResetScore(),
			onSetScore: (left, right) => this.debugSetScore(left, right),
			onBallControl: (action) => this.debugBallControl(action),
			onBallSpeedControl: (action) => this.debugBallSpeedControl(action),
			onTimeControl: (action) => this.debugTimeControl(action),
			onToggleOverlay: () => {},
			onChangeSkill: (side, skill) => this.debugChangeSkill(side, skill)
		};

		this.debugPanel = new DebugPanel(container, callbacks);
		this.debugPanel.open();
	}

	private debugActivatePowerUp(type: 'split' | 'blackout' | 'blackhole' | 'random'): void {
		const types = ['split', 'blackout', 'blackhole'] as const;
		const finalType = type === 'random' ? types[Math.floor(Math.random() * types.length)] : type;
		this.net.debugActivatePowerUp(finalType);
	}

	private debugClearPowerUps(): void {
		this.net.debugClearPowerUps();
	}

	private debugChangeScore(side: 'left' | 'right', amount: number): void {
		this.net.debugScoreChange(side, amount);
	}

	private debugResetScore(): void {
		this.net.debugResetScore();
	}

	private debugSetScore(left: number, right: number): void {
		this.net.debugSetScore(left, right);
	}

	private debugBallControl(action: 'add' | 'remove' | 'reset'): void {
		this.net.debugBallControl(action);
	}

	private debugBallSpeedControl(action: 'multiply' | 'divide' | 'freeze'): void {
		this.net.debugBallSpeed(action);
	}

	private debugTimeControl(action: 'slow' | 'fast' | 'normal'): void {
		const scale = action === 'slow' ? 0.5 : action === 'fast' ? 2 : 1;
		this.net.debugTimeScale(scale);
	}

	private debugChangeSkill(side: 'left' | 'right', skill: 'smash' | 'dash'): void {
		this.net.debugChangeSkill(side, skill);
	}

	private triggerScreenShake(): void 
	{
		const canvas = this.canvas;
		const originalTransform = canvas.style.transform;
		
		let shakeIntensity = 8;
		let shakeCount = 0;
		const maxShakes = 10;
		
		const shake = () => {
			if (shakeCount >= maxShakes) {
				canvas.style.transform = originalTransform;
				return;
			}
			
			const x = (Math.random() - 0.5) * shakeIntensity;
			const y = (Math.random() - 0.5) * shakeIntensity;
			canvas.style.transform = `translate(${x}px, ${y}px)`;
			
			shakeIntensity *= 0.85;
			shakeCount++;
			
			setTimeout(shake, 40);
		};
		
		shake();
	}

	private handleTournamentGameOver(winner: 'left' | 'right', tournamentId: string) {
		const amILeft = this.net.side === 'left';
		const didIWin = (amILeft && winner === 'left') || (!amILeft && winner === 'right');

		this.state.isGameOver = true;
		this.state.winner = winner;

		const message = didIWin
			? 'Victoire ! Redirection vers les brackets...'
			: 'D√©faite... Redirection vers les brackets...';

		console.log(message);

		setTimeout(() => {
			sessionStorage.removeItem('gameWsURL');
			window.router.navigate(`/tournament/${tournamentId}`);
		}, 3000);
	}

	private handleLocalTournamentGameOver(winner: 'left' | 'right') {
		this.state.isGameOver = true;
		this.state.winner = winner;

		// R√©cup√©rer l'ID du match et la config
		const matchId = sessionStorage.getItem('localTournamentMatch');
		const configStr = sessionStorage.getItem('localGameConfig');

		if (!matchId || !configStr) {
			console.error('Missing local tournament match data');
			return;
		}

		try {
			const config = JSON.parse(configStr);

			// D√©terminer l'ID du gagnant
			const winnerId = winner === 'left' ? config.left.id : config.right.id;

			// Enregistrer le r√©sultat
			const updatedTournament = LocalTournamentManager.recordMatchResult(matchId, winnerId);

			if (updatedTournament) {
				console.log('Match result recorded:', { matchId, winnerId });

				// Afficher un overlay de victoire
				const overlay = document.createElement('div');
				overlay.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50';
				overlay.innerHTML = `
					<div class="bg-[#0C154D]/90 border-2 border-blue-400 rounded-lg p-8 text-center max-w-md">
						<h2 class="text-4xl font-bold mb-4 text-blue-400">
							üèÜ ${winner === 'left' ? config.left.username : config.right.username} WINS!
						</h2>
						<p class="text-white/80 text-xl mb-6">
							Score: ${this.state.score.left} - ${this.state.score.right}
						</p>
						<p class="text-blue-300 text-sm">
							Retour au bracket dans <span id="countdown-timer">3</span> secondes...
						</p>
					</div>
				`;

				document.body.appendChild(overlay);

				// D√©compte dynamique
				let countdown = 3;
				const countdownEl = document.getElementById('countdown-timer');
				const countdownInterval = setInterval(() => {
					countdown--;
					if (countdownEl) {
						countdownEl.textContent = countdown.toString();
					}
					if (countdown <= 0) {
						clearInterval(countdownInterval);
					}
				}, 1000);

				// Nettoyer et rediriger
				setTimeout(() => {
					clearInterval(countdownInterval);
					overlay.remove(); // Supprimer l'overlay du DOM
					sessionStorage.removeItem('gameWsURL');
					sessionStorage.removeItem('localGameConfig');
					sessionStorage.removeItem('localTournamentMatch');
					window.router.navigate('/local-tournament-bracket');
				}, 3000);
			}
		} catch (error) {
			console.error('Error handling local tournament game over:', error);
		}
	}

	private handleQuickplayGameOver(winner: 'left' | 'right') {
		// V√©rifier si c'est un match de tournoi local
		const isLocalTournament = sessionStorage.getItem('localTournamentMatch');
		if (isLocalTournament) {
			this.handleLocalTournamentGameOver(winner);
			return;
		}

		const amILeft = this.net.side === 'left';
		const didIWin = (amILeft && winner === 'left') || (!amILeft && winner === 'right');

		this.state.isGameOver = true;
		this.state.winner = winner;

		const overlay = document.createElement('div');
		overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="bg-[#0C154D]/90 border-2 border-white/20 rounded-lg p-8 text-center max-w-md">
				<h2 class="text-4xl font-bold mb-4 ${didIWin ? 'text-green-400' : 'text-red-400'}">
					${didIWin ? 'üèÜ VICTOIRE !' : 'üíÄ D√âFAITE'}
				</h2>
				<p class="text-white/80 text-xl mb-6">
					Score: ${this.state.score.left} - ${this.state.score.right}
				</p>
				<button 
					id="return-to-lobby"
					class="px-6 py-3 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg text-white font-semibold transition-all cursor-pointer"
				>
					Retour au lobby
				</button>
			</div>
		`;
		
		document.body.appendChild(overlay);

		overlay.addEventListener('click', (e) => {
			const target = e.target as HTMLElement;
			if (target.id === 'return-to-lobby' || target.closest('#return-to-lobby')) {
				console.log('Return to lobby clicked');
				e.stopPropagation();
				sessionStorage.removeItem('gameWsURL');
				document.body.removeChild(overlay);
				window.router?.navigateTo('/play');
			}
		});
	}

	private setupEventHandlers(): void {
		window.addEventListener('resize', this.handleResize);
		window.addEventListener('pong:togglePause', this.handleTogglePause);

		if (!this.isLocalMode) {
			const forfeitBtn = document.getElementById('forfeit-btn');
			if (forfeitBtn) {
				forfeitBtn.addEventListener('click', this.handleForfeit);
			}
		} else {
			// Cacher le bouton forfeit en mode local
			const forfeitBtn = document.getElementById('forfeit-btn');
			if (forfeitBtn) {
				forfeitBtn.style.display = 'none';
			}
		}

		this.input.attach();
	}

	private connectToServer(): void {
		const storedUrl = sessionStorage.getItem('gameWsURL');
		let urlToUse = storedUrl ?? undefined;
		if (!urlToUse) {
			const host = import.meta.env.VITE_HOST;
			const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
			const roomId = window.location.pathname.split('/').pop();
			if (host && endpoint && roomId) {
				urlToUse = `wss://${host}${endpoint}/${roomId}`;
			}
		}

		const leftId = this.isLocalMode ? this.localConfig?.left.id : undefined;
		this.net.connect(urlToUse, leftId ? { playerId: leftId } : undefined);

		if (this.isLocalMode && this.secondaryNet) {
			const rightId = this.localConfig?.right.id;
			if (urlToUse && rightId) {
				this.secondaryNet.connect(urlToUse, { playerId: rightId });
			} else {
				console.warn('PongGame: missing URL or right player ID for local secondary controller');
			}
		}

		// If an AI opponent was requested (QuickPlay vs AI), connect AI WebSocket directly and start AI
		try {
			const aiPlayerId = sessionStorage.getItem('aiPlayerId');
			const aiSide = (sessionStorage.getItem('aiSide') as 'left' | 'right' | null) || null;
			if (urlToUse && aiPlayerId && aiSide) {
				this.aiNet = new WSClient();
				this.aiNet.onWelcome = this.createWelcomeHandler(this.aiNet);
				this.aiNet.connect(urlToUse, { playerId: aiPlayerId });
				this.enableAI(aiSide, this.aiNet, 1);
				// Clear once consumed
				sessionStorage.removeItem('aiPlayerId');
				sessionStorage.removeItem('aiSide');
			}
		} catch (e) {
			console.warn('PongGame: failed to setup AI opponent', e);
		}
	}

	private setupSecondaryNetworkHandlers(): void {
		if (!this.secondaryNet) {
			return;
		}
    this.secondaryNet.onWelcome = this.createWelcomeHandler(this.secondaryNet);
	}

	private createWelcomeHandler(client: WSClient) {
		return (side: 'left' | 'right' | 'spectator', playerNames?: {left?: string; right?: string}) => {
			console.log('Welcome received:', { side, playerNames });

			const resolvedLeftName = playerNames?.left ?? this.localConfig?.left.username;
			const resolvedRightName = playerNames?.right ?? this.localConfig?.right.username;

			const updateNames = () => {
				const leftNameEl = document.getElementById('player-left-name');
				const rightNameEl = document.getElementById('player-right-name');

				if (leftNameEl && resolvedLeftName) {
					leftNameEl.textContent = resolvedLeftName;
				}
				if (rightNameEl && resolvedRightName) {
					rightNameEl.textContent = resolvedRightName;
				}

				if ((!leftNameEl || !rightNameEl) && (resolvedLeftName || resolvedRightName)) {
					setTimeout(updateNames, 100);
				}
			};

			updateNames();

			if (this.isLocalMode) {
				if (side === 'left') {
					this.leftController = client;
				} else if (side === 'right') {
					this.rightController = client;
				}

				if (this.leftController && this.rightController) {
					this.input.setControllers(this.leftController, this.rightController);
				}
			}

			if (!this.isDebugMode) {
				const username = window.simpleAuth?.getUsername?.();
				if (username === 'admindebug') {
					this.enableDebugMode();
				}
			}


		};
	}

	private handleResize = (): void => {
		this.renderer.setupCanvas();
	};

	private handleTogglePause = (): void => {
		if (this.state.isPaused) 
		{
			this.net.resume();
		} 
		else 
		{
			this.net.pause();
		}
	};

	private handleForfeit = (): void => {
		if (this.state.isGameOver) {
			return;
		}
		
		const confirmed = confirm('Are you sure you want to forfeit this game?');
		if (confirmed) {
			this.net.forfeit();
		}
	};

	private enableAI(side: 'left' | 'right', ws: WSClient, hz?: number): void {
		if (this.aiControllers[side]) {
			this.aiControllers[side]?.stop();
		}
		const ai = new PongAI(() => this.state, side, ws, { hz: hz ?? 1, deadZone: 24, hysteresis: 10, minHoldTicks: 0 });
		ai.start();
		this.aiControllers[side] = ai;
		console.log(`Pong AI enabled for ${side} at ${hz ?? 1} Hz`);
	}

	private disableAI(side?: 'left' | 'right'): void {
		if (side) {
			this.aiControllers[side]?.stop();
			this.aiControllers[side] = undefined;
			console.log(`Pong AI disabled for ${side}`);
			return;
		}
		// disable both
		this.aiControllers.left?.stop();
		this.aiControllers.right?.stop();
		this.aiControllers = {};
		console.log('Pong AI disabled for both sides');
	}

	private setupAIHooks(): void {
		try {
			// Support toggling via custom events (for debugging/tools)
			window.addEventListener('pong:enableAI', ((ev: Event) => {
				const detail = (ev as CustomEvent<{ side: 'left' | 'right' | 'both'; hz?: number }>).detail;
				if (!detail) return;
				const hz = detail.hz ?? 1;
				const ws = this.aiNet ?? this.net;
				if (detail.side === 'both') {
					this.enableAI('left', ws, hz);
					this.enableAI('right', ws, hz);
				} else {
					this.enableAI(detail.side, ws, hz);
				}
			}) as EventListener);
			window.addEventListener('pong:disableAI', ((ev: Event) => {
				const detail = (ev as CustomEvent<{ side?: 'left' | 'right' }>).detail;
				this.disableAI(detail?.side);
			}) as EventListener);
		} catch {}
	}

	private smashOffsetX = (side: 'left' | 'right'): number => {
		const skillType = side === 'left' ? this.state.selectedSkills.left : this.state.selectedSkills.right;
		if (skillType !== 'smash') 
		{
			return 0;
		}

		const skillState = side === 'left' ? this.state.skillStates.left : this.state.skillStates.right;
		const dur = 0.12;
		const dt = Math.max(0, this.state.clock - skillState.lastActivationAt);

		if (dt <= 0 || dt > dur) 
		{
			return 0;
		}

		const t = dt / dur;
		const amp = 24;
		const dir = side === 'left' ? 1 : -1;

		return (dir * amp * Math.sin(Math.PI * t));
	};

	private startAnimationLoop(): void {
		const animate = (): void => {
			this.statsMonitor.recordFrame();
			this.particles.update();
			this.renderer.render(
				this.state,
				this.timeoutStatus,
				this.particles,
				this.net.side,
				this.smashOffsetX,
				this.isLocalMode ? { showLeftSkill: true, showRightSkill: true } : undefined
			);
			this.animationFrameId = requestAnimationFrame(animate);
		};
		animate();
	}

	private loadLocalConfig(): LocalGameConfig | undefined {
		const raw = sessionStorage.getItem('localGameConfig');
		if (!raw) {
			return undefined;
		}
		try {
			return JSON.parse(raw) as LocalGameConfig;
		} catch (err) {
			console.warn('PongGame: failed to parse local game config', err);
			return undefined;
		}
	}

	cleanup(): void {
		console.log('PongGame: cleaning up...');
		if (this.animationFrameId !== null) {
			cancelAnimationFrame(this.animationFrameId);
			this.animationFrameId = null;
		}
		if (this.statsUpdateInterval !== null) {
			clearInterval(this.statsUpdateInterval);
			this.statsUpdateInterval = null;
		}
		if (this.pingInterval !== null) {
			clearInterval(this.pingInterval);
			this.pingInterval = null;
		}
		window.removeEventListener('resize', this.handleResize);
		window.removeEventListener('pong:togglePause', this.handleTogglePause);
		
		if (!this.isLocalMode) {
			const forfeitBtn = document.getElementById('forfeit-btn');
			if (forfeitBtn) {
				forfeitBtn.removeEventListener('click', this.handleForfeit);
			}
		}
		this.input.detach();
		this.particles.clear();
		this.disableAI();
		this.net.cleanup();
		if (this.debugPanel) {
			this.debugPanel.cleanup();
			this.debugPanel = undefined;
		}
		if (this.secondaryNet) {
			this.secondaryNet.cleanup();
			this.secondaryNet = undefined;
		}
		if (this.aiNet) {
			this.aiNet.cleanup();
			this.aiNet = undefined;
		}
		if (this.isLocalMode) {
			sessionStorage.removeItem('localGameConfig');
		}
		if (this.debugContainer && this.debugContainer.parentNode) {
			this.debugContainer.parentNode.removeChild(this.debugContainer);
			this.debugContainer = undefined;
		}
	}
}

export function Pong(): string {
	return '';
}

// ==============================================
// üìÑ ./src/components/PongGame/PongParticles.ts
// ==============================================
import type { Particle } from "./types";
import { TRAIL_THRESHOLD, BALL_MAX_SPEED } from "./constants";

export class PongParticleSystem {
	private particles: Particle[] = [];

	addParticle(particle: Particle): void {
		this.particles.push(particle);
	}

	createExplosion(x: number, y: number, count: number = 10): void {
		for (let i = 0; i < count; i++)
		{
			const angle = (Math.PI * 2 * i) / count;
			const speed = 2 + Math.random() * 3;
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * speed,
				vy: Math.sin(angle) * speed,
				life: 1,
				size: 3 + Math.random() * 3,
				color: '#FFFFFF'
			});
		}
	}

	createGoalExplosion(x: number, y: number, ballVx: number, ballVy: number): void {
		const speed = Math.hypot(ballVx, ballVy);
		const dirX = speed > 0 ? ballVx / speed : 1;
		const dirY = speed > 0 ? ballVy / speed : 0;

		const mainAngle = Math.atan2(dirY, dirX);
		
		for (let i = 0; i < 80; i++) 
		{
			const angleVariation = (Math.random() - 0.5) * Math.PI * 0.15;
			const angle = mainAngle + angleVariation;
			
			const particleSpeed = 12 + Math.random() * 15;
			const size = 4 + Math.random() * 6;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 1.0,
				size: size,
				color: '#FFFFFF'
			});
		}

		for (let i = 0; i < 60; i++) 
		{
			const angleVariation = (Math.random() - 0.5) * Math.PI * 0.25;
			const angle = mainAngle + angleVariation;
			const particleSpeed = 8 + Math.random() * 12;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 1.0,
				size: 3 + Math.random() * 5,
				color: '#FFFFFF'
			});
		}

		for (let i = 0; i < 40; i++) 
		{
			const angleVariation = (Math.random() - 0.5) * Math.PI * 0.4;
			const angle = mainAngle + angleVariation;
			const particleSpeed = 5 + Math.random() * 8;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 0.9,
				size: 2 + Math.random() * 4,
				color: '#FFFFFF'
			});
		}

		for (let i = 0; i < 15; i++) 
		{
			const angleVariation = (Math.random() - 0.5) * Math.PI * 0.2;
			const angle = mainAngle + angleVariation;
			const particleSpeed = 10 + Math.random() * 12;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 1.0,
				size: 8 + Math.random() * 10,
				color: '#FFFFFF'
			});
		}

		const starCount = 12;
		for (let i = 0; i < starCount; i++) 
		{
			const angle = (Math.PI * 2 * i) / starCount;
			const particleSpeed = 8 + Math.random() * 6;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 0.6,
				size: 5 + Math.random() * 5,
				color: '#FFFFFF'
			});
		}

		for (let i = 0; i < 30; i++) 
		{
			const angle = Math.random() * Math.PI * 2;
			const particleSpeed = Math.random() * 3;
			
			this.particles.push({
				x,
				y,
				vx: Math.cos(angle) * particleSpeed,
				vy: Math.sin(angle) * particleSpeed,
				life: 1.2,
				size: 1 + Math.random() * 3,
				color: '#FFFFFF'
			});
		}
	}

	createTrail(x: number, y: number, vx: number, vy: number): void {
		const speed = Math.hypot(vx, vy);
		if (speed < TRAIL_THRESHOLD)
		{
			return;
		}
		const nx = -vx / speed;
		const ny = -vy / speed;

		this.particles.push({
			x: x + nx * 10,
			y: y + ny * 10,
			vx: 0,
			vy: 0,
			life: 0.5,
			size: 8 + (speed / 1500) * 7,
			color: `rgba(255, 255, 255, ${0.3 + (speed / BALL_MAX_SPEED) * 0.4})`
		});
	}

	update(dt: number = 0.016): void {
		for (let i = this.particles.length - 1; i >= 0; i--)
		{
			const p = this.particles[i];
			p.x += p.vx;
			p.y += p.vy;
			p.life -= dt * 2;

			if (p.life <= 0)
			{
				this.particles.splice(i, 1);
			}
		}
	}

	render(ctx: CanvasRenderingContext2D): void {
		for (const p of this.particles)
		{
			ctx.globalAlpha = p.life;
			ctx.fillStyle = p.color;
			ctx.beginPath();
			ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
			ctx.fill();
		}
		ctx.globalAlpha = 1;
	}

	clear(): void {
		this.particles = [];
	}

	getParticles(): Particle[] {
		return (this.particles);
	}
}
// ==============================================
// üìÑ ./src/components/PongGame/PongInput.ts
// ==============================================
import type { WSClient } from "../../net/wsClient";

export class PongInputHandler {
	private keys = {w: false, s: false, up: false, down: false};
	private net: WSClient;
	private secondaryNet?: WSClient;
	private leftController: WSClient;
	private rightController?: WSClient;

	constructor(net: WSClient, secondaryNet?: WSClient) {
		this.net = net;
		this.secondaryNet = secondaryNet;
		this.leftController = net;
		this.rightController = secondaryNet;
	}

	private onKeyDown = (e: KeyboardEvent): void => {
		switch (e.key) {
			case 'w':
			case 'W':
				this.keys.w = true;
				break;
			case 's':
			case 'S':
				this.keys.s = true;
				break;
			case 'ArrowUp':
				this.keys.up = true;
				e.preventDefault();
				break;
			case 'ArrowDown':
				this.keys.down = true;
				e.preventDefault();
				break;
			case ' ':
				this.leftController.useSkill();
				e.preventDefault();
				return;
			case 'Enter':
				(this.rightController ?? this.leftController).useSkill();
				e.preventDefault();
				return;
			case 'p':
			case 'P':
			case 'Escape':
				this.handlePause();
				e.preventDefault();
				return;
		}
		this.sendIntent();
	};

	private onKeyUp = (e: KeyboardEvent): void => {
		switch (e.key) {
			case 'w':
			case 'W':
				this.keys.w = false;
				break;
			case 's':
			case 'S':
				this.keys.s = false;
				break;
			case 'ArrowUp':
				this.keys.up = false;
				break;
			case 'ArrowDown':
				this.keys.down = false;
				break;
		}
		this.sendIntent();
	};

	private sendIntent(): void {
		if (this.rightController && this.rightController !== this.leftController) {
			this.leftController.sendInput(!!this.keys.w, !!this.keys.s);
			this.rightController.sendInput(!!this.keys.up, !!this.keys.down);
		} else {
			const up = this.keys.w || this.keys.up;
			const down = this.keys.s || this.keys.down;
			this.net.sendInput(!!up, !!down);
		}
	}

	private handlePause(): void {
		window.dispatchEvent(new CustomEvent('pong:togglePause'));
	}

	attach(): void {
		window.addEventListener('keydown', this.onKeyDown);
		window.addEventListener('keyup', this.onKeyUp);
	}

	detach(): void {
		window.removeEventListener('keydown', this.onKeyDown);
		window.removeEventListener('keyup', this.onKeyUp);
	}

	setControllers(left: WSClient, right?: WSClient): void {
		this.leftController = left;
		this.rightController = right;
	}

	getKeys() {
		return ({ ...this.keys});
	}
}

// ==============================================
// üìÑ ./src/components/PongGame/types.ts
// ==============================================
import type { PublicState } from "../../net/wsClient";

export interface PongGameState extends PublicState {
	// si jamais
}

export interface Particle {
	x: number;
	y: number;
	vx: number;
	vy: number;
	life: number;
	size: number;
	color: string;
}

export interface Ball {
	x: number;
	y: number;
	vx: number;
	vy: number;
	radius: number;
}

export interface TimeoutStatus {
	leftActive: boolean;
	leftRemainingMs: number;
	rightActive: boolean;
	rightRemainingMs: number;
}
// ==============================================
// üìÑ ./src/components/PongGame/PongAssets.ts
// ==============================================
export class PongAssets {
	private images: Map<string, HTMLImageElement> = new Map();
	private loaded = false;

	async loadAll(): Promise<void> {
		this.loaded = true;
	}

	getImage(key: string): HTMLImageElement | undefined {
		return (this.images.get(key));
	}

	isLoaded(): boolean {
		return (this.loaded);
	}
}
// ==============================================
// üìÑ ./src/components/PongGame/constants.ts
// ==============================================
export const WORLD_WIDTH = 1920;
export const WORLD_HEIGHT = 1080;
export const PADDLE_WIDTH = 15;
export const PADDLE_HEIGHT = 100;
export const PADDLE_MARGIN = 30;
export const BALL_INITIAL_SPEED = 600;

export const COLORS = {
	background: '#000000',
	paddle: '#FFFFFF',
	ball: '#FFFFFF',
	ballTrail: 'rgba(255, 255, 255, 0.5)',
	powerUpSplit: '#FFD700',
	powerUpBlackout: '#9B59B6',
	powerUpBlackhole: '#20054bff',
	net: '#FFFFFF',
	text: '#FFFFFF'
};

export const BALL_MAX_SPEED = 1500;
export const TRAIL_THRESHOLD = 800;
// ==============================================
// üìÑ ./src/components/PongGame/PongAI.ts
// ==============================================
import type { PublicState } from "../../net/wsClient";
import type { WSClient } from "../../net/wsClient";
import { WORLD_HEIGHT, WORLD_WIDTH, PADDLE_MARGIN, PADDLE_WIDTH, PADDLE_HEIGHT } from "./constants";

type Side = 'left' | 'right';

export class PongAI {
  private getState: () => PublicState;
  private side: Side;
  private intervalMs: number;
  private timer: number | null = null;
  private ws: WSClient;
  private prev = { up: false, down: false };
  private deadZone: number; // pixels
  private hysteresis: number; // pixels beyond deadZone to reverse
  private minHoldTicks: number; // min ticks to hold direction
  private lastCmd: 'up' | 'down' | 'none' = 'none';
  private holdTicks = 0;
  private releaseTimer: number | null = null;
  private decisionSeq = 0;

  constructor(getState: () => PublicState, side: Side, ws: WSClient, options?: { hz?: number; deadZone?: number; hysteresis?: number; minHoldTicks?: number }) {
    this.getState = getState;
    this.side = side;
    this.ws = ws;
    const hz = Math.max(1, Math.min(60, Math.floor(options?.hz ?? 1)));
    this.intervalMs = Math.floor(1000 / hz);
    this.deadZone = Math.max(4, Math.floor(options?.deadZone ?? 16));
    this.hysteresis = Math.max(6, Math.floor(options?.hysteresis ?? 20));
    this.minHoldTicks = Math.max(0, Math.floor(options?.minHoldTicks ?? 1));
  }

  start(): void {
    if (this.timer !== null) return;
    this.timer = setInterval(() => this.step(), this.intervalMs) as unknown as number;
  }

  stop(): void {
    if (this.timer !== null) {
      clearInterval(this.timer);
      this.timer = null;
    }
    this.send(false, false);
  }

  private step(): void {
    const state = this.getState();
    const paddleY = this.side === 'left' ? state.leftPaddle.y : state.rightPaddle.y;
    const paddleSpeed = this.side === 'left' ? state.leftPaddle.speed : state.rightPaddle.speed;

    // Choose the ball to react to: prefer one moving towards us with minimal time to intercept
    const balls = state.balls;
    if (balls.length === 0) {
      this.applyDecision('none', 0, 0);
      return;
    }

    const targetX = this.side === 'left'
      ? PADDLE_MARGIN + PADDLE_WIDTH
      : WORLD_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;

    const candidates = balls
      .map(b => {
        const dx = targetX - b.x;
        const t = b.vx !== 0 ? dx / b.vx : Number.POSITIVE_INFINITY; // time to reach our paddle x
        return { b, t };
      })
      .filter(({ b, t }) => {
        // Keep only balls moving towards our side (positive time)
        return t > 0;
      });

    const chosen = (candidates.length > 0)
      ? candidates.reduce((best, cur) => (cur.t < best.t ? cur : best))
      : null;

    // If no ball is moving towards us, drift to center
    const targetY = chosen ? this.predictYAtTime(chosen.b.y, chosen.b.vy, chosen.b.radius, chosen.t)
                           : WORLD_HEIGHT / 2;

    const diff = targetY - paddleY;
    const absDiff = Math.abs(diff);

    // Dynamic margin: wait more when intercept is far in time, avoid chasing too early.
    const t = chosen?.t ?? 0;
    const reaction = this.intervalMs / 1000; // seconds
    const guard = Math.max(this.deadZone, 0.25 * PADDLE_HEIGHT);
    const timeBand = Math.max(0, Math.min(0.4, t * 0.3));
    const distWeCanCorrectNextTick = paddleSpeed * reaction * 0.35;
    const dynamicMargin = Math.max(guard, Math.min(distWeCanCorrectNextTick, paddleSpeed * timeBand));

    const desired: 'up' | 'down' | 'none' = absDiff <= dynamicMargin
      ? 'none'
      : (diff < 0 ? 'up' : 'down');

    this.applyDecision(desired, absDiff, paddleSpeed, t);
  }

  // Predict Y coordinate after time t with wall reflections (top/bottom), given current y, vy, and radius
  private predictYAtTime(y: number, vy: number, radius: number, t: number): number {
    const top = radius;
    const bottom = WORLD_HEIGHT - radius;
    const span = bottom - top;
    if (span <= 0) return y; // degenerate

    const yRaw = y + vy * t;
    const period = 2 * span;
    let m = (yRaw - top) % period;
    if (m < 0) m += period;
    const reflected = (m <= span) ? (top + m) : (top + (period - m));
    return reflected;
  }

  private send(up: boolean, down: boolean): void {
    if (up === this.prev.up && down === this.prev.down) return;
    this.prev = { up, down };
    this.ws.sendInput(up, down);
  }

  private applyDecision(desired: 'up' | 'down' | 'none', absDiff: number, paddleSpeed: number, timeToIntercept: number = 0): void {
    let cmd: 'up' | 'down' | 'none' = desired;

    if (desired === 'none') {
      cmd = 'none';
    } else if (this.lastCmd === 'none') {
      cmd = desired;
    } else if (desired !== this.lastCmd) {
      if (absDiff < this.deadZone + this.hysteresis || this.holdTicks < this.minHoldTicks) {
        cmd = this.lastCmd; // avoid rapid reversals
      }
    } else {
      cmd = this.lastCmd;
    }

    if (cmd !== this.lastCmd) {
      this.holdTicks = 0;
      this.lastCmd = cmd;
    } else {
      this.holdTicks++;
    }

    // Cancel previous scheduled release
    if (this.releaseTimer !== null) {
      clearTimeout(this.releaseTimer);
      this.releaseTimer = null;
    }

    // Emit command and schedule a timed release to avoid full-sweep overshoot at 1 Hz
    if (cmd === 'none') {
      this.send(false, false);
      return;
    }

    const seq = ++this.decisionSeq;
    if (cmd === 'up') {
      this.send(true, false);
    } else {
      this.send(false, true);
    }

    // Estimate hold time proportional to distance to cover, capped within the tick interval
    const estMs = paddleSpeed > 1 ? Math.round((absDiff / paddleSpeed) * 1000) : this.intervalMs;
    const holdMs = Math.max(120, Math.min(this.intervalMs - 40, Math.floor(estMs * 0.9)));
    this.releaseTimer = window.setTimeout(() => {
      if (seq === this.decisionSeq) {
        this.send(false, false);
      }
    }, holdMs) as unknown as number;
  }
}

// ==============================================
// üìÑ ./src/components/PongGame/PongRenderer.ts
// ==============================================
import type { PongGameState, TimeoutStatus } from "./types";
import type { PongParticleSystem } from "./PongParticles";
import { WORLD_WIDTH, WORLD_HEIGHT, PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_MARGIN,
COLORS, BALL_MAX_SPEED, TRAIL_THRESHOLD } from "./constants";
import type { WSClient } from "../../net/wsClient";

export class PongRenderer {
	private ctx: CanvasRenderingContext2D;
	private canvas: HTMLCanvasElement;
	private net

	constructor(canvas: HTMLCanvasElement, net: WSClient) {
		this.net = net;
		this.canvas = canvas;
		const ctx = canvas.getContext('2d');
		if (!ctx) {
			throw new Error('PongRenderer: 2D context not found');
		}
		this.ctx = ctx;
		this.setupCanvas();
	}

	setupCanvas(): void {
		const container = this.canvas.parentElement;
		if (!container)
		{
			return;
		}

		const W = WORLD_WIDTH;
		const H = WORLD_HEIGHT;
		const containerWidth = container.clientWidth * 0.9;
		const containerHeight = window.innerHeight * 0.8;
		const scaleX = containerWidth / W;
		const scaleY = containerHeight / H;
		const scale = Math.min(scaleX, scaleY);
		const displayWidth = Math.floor(W * scale);
		const displayHeight = Math.floor(H * scale);
		const dpr = window.devicePixelRatio || 1;

		this.canvas.width = W * dpr;
		this.canvas.height = H * dpr;
		this.ctx.resetTransform();
		this.ctx.scale(dpr, dpr);

		this.canvas.style.width = displayWidth + 'px';
		this.canvas.style.height = displayHeight + 'px';
		this.canvas.style.display = 'block';
		this.canvas.style.margin = '20px auto';
		this.canvas.style.border = '2px solid #333';
		this.canvas.style.boxShadow = '0 4px 20px rgba(0, 0, 0, 0.5)';

		this.ctx.imageSmoothingEnabled = true;
	}

	render(
		state: PongGameState,
		timeoutStatus: TimeoutStatus,
		particles: PongParticleSystem,
		side: 'left' | 'right' | 'spectator',
		smashOffsetX: (side: 'left' | 'right') => number,
		options?: { showLeftSkill?: boolean; showRightSkill?: boolean }
	): void {
		const ctx = this.ctx;
		const W = WORLD_WIDTH;
		const H = WORLD_HEIGHT;
		const shouldBlackout = (side === 'left' && state.blackoutLeft) || (side === 'right' && state.blackoutRight);
		const blackoutIntensity = side === 'left' ? state.blackoutLeftIntensity : side === 'right' ? state.blackoutRightIntensity : 0;

		ctx.fillStyle = COLORS.background;
		ctx.fillRect(0, 0, W, H);

		if (state.blackholeActive)
		{
			this.drawBlackHoleVortex(ctx, state);
		}
		ctx.strokeStyle = shouldBlackout ? `rgba(255, 255, 255, ${0.1 * (1 - blackoutIntensity)})` : COLORS.net;
		ctx.setLineDash([10, 10]);
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(W / 2, 0);
		ctx.lineTo(W / 2, H);
		ctx.stroke();
		ctx.setLineDash([]);

		const leftX = PADDLE_MARGIN + smashOffsetX('left');
		const rightX = W - PADDLE_MARGIN - PADDLE_WIDTH + smashOffsetX('right');

		if (!shouldBlackout || side === 'left')
		{
			ctx.fillStyle = COLORS.paddle;
			ctx.fillRect(
				leftX,
				state.leftPaddle.y - PADDLE_HEIGHT / 2,
				PADDLE_WIDTH,
				PADDLE_HEIGHT
			);
		}
		if (!shouldBlackout || side === 'right')
		{
			ctx.fillStyle = COLORS.paddle;
			ctx.fillRect(
				rightX,
				state.rightPaddle.y - PADDLE_HEIGHT / 2,
				PADDLE_WIDTH,
				PADDLE_HEIGHT
			);
		}

		if (!shouldBlackout)
		{
			for (const powerUp of state.powerUps) 
			{
				this.drawPowerUp(ctx, powerUp.x, powerUp.y, powerUp.radius, state.clock, powerUp.type);
			}
		}

		particles.render(ctx);

		for (const b of state.balls) 
		{
			const speed = Math.hypot(b.vx, b.vy);
			
			if (speed >= TRAIL_THRESHOLD) 
			{
				this.drawBallTrail(ctx, b, speed);
			}

			ctx.fillStyle = COLORS.ball;
			ctx.beginPath();
			ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
			ctx.fill();

			if (speed >= BALL_MAX_SPEED * 0.9) 
			{
				ctx.shadowBlur = 20;
				ctx.shadowColor = COLORS.ball;
				ctx.beginPath();
				ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
				ctx.fill();
				ctx.shadowBlur = 0;
			}
		}

		ctx.fillStyle = shouldBlackout ? `rgba(255, 255, 255, ${0.3 * (1 - blackoutIntensity)})` : COLORS.text;
		ctx.font = '48px monospace';
		ctx.textAlign = 'center';
		ctx.fillText(String(state.score.left), W / 2 - 100, 60);
		ctx.fillText(String(state.score.right), W / 2 + 100, 60);

		const showLeftHud = (options?.showLeftSkill ?? false) || side === 'left';
		const showRightHud = (options?.showRightSkill ?? false) || side === 'right';

		const drawSkillHud = (playerSide: 'left' | 'right', centerX: number) => {
			const isBlackout = playerSide === 'left' ? state.blackoutLeft : state.blackoutRight;
			if (isBlackout) {
				return;
			}

			const skillState = playerSide === 'left' ? state.skillStates.left : state.skillStates.right;
			const skillType = playerSide === 'left' ? state.selectedSkills.left : state.selectedSkills.right;
			const cooldown = skillType === 'smash' ? 3 : 5;
			const progress =
				skillState.cooldownRemaining > 0
					? Math.max(0, Math.min(1, 1 - skillState.cooldownRemaining / cooldown))
					: 1;

			this.drawCooldownDonut(ctx, centerX, 60, 28, 10, progress);

			if (skillState.cooldownRemaining > 0) {
				ctx.fillStyle = COLORS.text;
				ctx.font = '16px monospace';
				ctx.textAlign = playerSide === 'left' ? 'left' : 'right';
				const textX = playerSide === 'left' ? centerX + 35 : centerX - 35;
				ctx.fillText(skillState.cooldownRemaining.toFixed(1) + 's', textX, 66);
			}
		};

		if (showLeftHud) {
			drawSkillHud('left', 60);
		}
		if (showRightHud) {
			drawSkillHud('right', W - 60);
		}
		ctx.textAlign = 'center';

		if (shouldBlackout && blackoutIntensity > 0)
		{
			ctx.fillStyle = `rgba(0, 0, 0, ${blackoutIntensity * 0.95})`;
			ctx.fillRect(0, 0, W, H);
			this.drawNeonUnderBlackout(ctx, state, side, smashOffsetX);
		}

		this.renderOverlays(ctx, state, timeoutStatus, side, W, H);
	}

	private drawBallTrail(ctx: CanvasRenderingContext2D, ball: { x: number; y: number; vx: number; vy: number; radius: number }, speed: number): void {
		const trailLength = Math.min(8, Math.floor((speed / BALL_MAX_SPEED) * 10));
		const direction = Math.atan2(ball.vy, ball.vx);

		for (let i = 1; i <= trailLength; i++) 
		{
			const distance = i * 12;
			const trailX = ball.x - Math.cos(direction) * distance;
			const trailY = ball.y - Math.sin(direction) * distance;
			const alpha = 1 - i / trailLength;
			const size = ball.radius * (1 - i / trailLength * 0.5);

			ctx.globalAlpha = alpha * 0.6;
			ctx.fillStyle = COLORS.ballTrail;
			ctx.beginPath();
			ctx.arc(trailX, trailY, size, 0, Math.PI * 2);
			ctx.fill();
		}
		ctx.globalAlpha = 1;
	}

	private drawPowerUp(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, time: number, type: string): void {
		const pulse = Math.sin(time * 4) * 2;

		if (type === 'blackhole')
		{
			const color = COLORS.powerUpBlackhole;
			ctx.beginPath();
			ctx.beginPath();
			ctx.fillStyle = color;
			ctx.arc(x, y, radius + pulse, 0, Math.PI * 2);
			ctx.fill();
			ctx.strokeStyle = '#0b2230';
			ctx.lineWidth = 3;
			ctx.stroke();

			const grad = ctx.createRadialGradient(x, y, 1, x, y, radius * 0.8);
			grad.addColorStop(0, 'rgba(0,0,0,1)');
			grad.addColorStop(1, 'rgba(14,165,233,0.2)');
			ctx.fillStyle = grad;
			ctx.beginPath();
			ctx.arc(x, y, radius * 0.7 + pulse * 0.3, 0, Math.PI * 2);
			ctx.fill();
			return;
		}

		const color = type === 'blackout' ? COLORS.powerUpBlackout : COLORS.powerUpSplit;
		ctx.beginPath();
		ctx.fillStyle = color;
		ctx.arc(x, y, radius + pulse, 0, Math.PI * 2);
		ctx.fill();
		ctx.strokeStyle = '#333';
		ctx.lineWidth = 3;
		ctx.stroke();

		if (type === 'split')
		{
			const oscillation = Math.sin(time * 3) * 3;
			const iconRadius = radius * 0.25;
			const baseOffset = radius * 0.3;
	
			ctx.beginPath();
			ctx.fillStyle = '#FFF';
			ctx.arc(x - baseOffset - oscillation, y, iconRadius, 0, Math.PI * 2);
			ctx.fill();
			ctx.strokeStyle = '#333';
			ctx.lineWidth = 2;
			ctx.stroke();
	
			ctx.beginPath();
			ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
			ctx.arc(x + baseOffset + oscillation, y, iconRadius, 0, Math.PI * 2);
			ctx.fill();
			ctx.strokeStyle = 'rgba(51, 51, 51, 0.8)';
			ctx.lineWidth = 2;
			ctx.stroke();
		}
		else if (type === 'blackout') 
		{
			ctx.fillStyle = '#000';
			ctx.beginPath();
			ctx.arc(x, y, radius * 0.5, 0, Math.PI * 2);
			ctx.fill();
			
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(x + radius * 0.15, y, radius * 0.4, 0, Math.PI * 2);
			ctx.fill();
		}
	}

	private drawCooldownDonut(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, thickness: number, progress: number): void {
		const start = -Math.PI / 2;
		const end = start + progress * Math.PI * 2;

		ctx.strokeStyle = '#444';
		ctx.lineWidth = thickness;
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2);
		ctx.stroke();

		if (progress > 0) 
		{
			ctx.strokeStyle = progress >= 1 ? '#00e676' : '#ffcc00';
			ctx.lineWidth = thickness;
			ctx.beginPath();
			ctx.arc(x, y, r, start, end);
			ctx.stroke();
		}
	}

	private drawNeonUnderBlackout(ctx: CanvasRenderingContext2D, state: PongGameState, side: 'left' | 'right' | 'spectator', smashOffsetX: (side: 'left' | 'right') => number): void {
		const W = WORLD_WIDTH;
		const leftX = PADDLE_MARGIN + smashOffsetX('left');
		const rightX = W - PADDLE_MARGIN - PADDLE_WIDTH + smashOffsetX('right');

		ctx.save();
		ctx.globalCompositeOperation = 'lighter';
		ctx.shadowColor = '#ffffff';
		ctx.shadowBlur = 28;
		ctx.fillStyle = '#ffffff';

		if (side === 'left') {
			ctx.fillRect(
				leftX,
				state.leftPaddle.y - PADDLE_HEIGHT / 2,
				PADDLE_WIDTH,
				PADDLE_HEIGHT
			);
		} else if (side === 'right') {
			ctx.fillRect(
				rightX,
				state.rightPaddle.y - PADDLE_HEIGHT / 2,
				PADDLE_WIDTH,
				PADDLE_HEIGHT
			);
		}

		for (const b of state.balls) {
			ctx.beginPath();
			ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
			ctx.fill();

			ctx.shadowBlur = 40;
			ctx.beginPath();
			ctx.arc(b.x, b.y, Math.max(2, b.radius * 0.85), 0, Math.PI * 2);
			ctx.fill();
		}

		ctx.restore();
	}

	private drawBlackHoleVortex(ctx: CanvasRenderingContext2D, state: PongGameState): void
	{
		const cx = state.blackholeCenterX;
		const cy = state.blackholeCenterY;
		const p = Math.max(0, Math.min(1, state.blackholeProgress));
		const baseR = 260;
		const r = baseR * (0.8 + 0.6 * p);

		const pulse = Math.sin(state.clock * 3) * 0.15 + 1;
		const effectiveRadius = r * pulse;

		const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, effectiveRadius);
		g.addColorStop(0.0, 'rgba(0,0,0,1)');
		g.addColorStop(0.3, 'rgba(10,5,30,0.95)');
		g.addColorStop(0.6, 'rgba(20,10,50,0.7)');
		g.addColorStop(1.0, 'rgba(0,0,0,0.1)');
		ctx.fillStyle = g;
		ctx.beginPath();
		ctx.arc(cx, cy, effectiveRadius, 0, Math.PI * 2);
		ctx.fill();

		ctx.save();
		ctx.globalCompositeOperation = 'lighter';

		const ringCount = 8;
		for (let i = 0; i < ringCount; i++) 
		{
			const ringProgress = i / ringCount;
			const ringRadius = effectiveRadius * (0.3 + ringProgress * 0.7);
			const ringPulse = Math.sin(state.clock * 4 - ringProgress * Math.PI * 2) * 0.1 + 1;
			const actualRadius = ringRadius * ringPulse;
			
			const hue = 220 + ringProgress * 60;
			const alpha = (0.4 - ringProgress * 0.3) * (1 - p * 0.5);
			
			ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
			ctx.lineWidth = 3 - ringProgress * 2;
			
			ctx.beginPath();
			const segments = 60;
			for (let s = 0; s <= segments; s++) 
			{
				const angle = (s / segments) * Math.PI * 2;
				const distortion = Math.sin(angle * 3 + state.clock * 2 + ringProgress * Math.PI) * (5 + ringProgress * 10);
				const x = cx + Math.cos(angle) * (actualRadius + distortion);
				const y = cy + Math.sin(angle) * (actualRadius + distortion);
				
				if (s === 0) ctx.moveTo(x, y);
				else ctx.lineTo(x, y);
			}
			ctx.closePath();
			ctx.stroke();
		}

		const spiralCount = 5;
		for (let i = 0; i < spiralCount; i++) 
		{
			const spiralOffset = (i / spiralCount) * Math.PI * 2;
			const spiralProgress = (state.clock * 2 + spiralOffset) % (Math.PI * 2);
			
			ctx.strokeStyle = `rgba(100, 150, 255, ${0.6 * (1 - p * 0.3)})`;
			ctx.lineWidth = 2;
			ctx.beginPath();
			
			const spiralSegments = 40;
			for (let s = 0; s < spiralSegments; s++) 
			{
				const t = s / spiralSegments;
				const angle = spiralProgress + t * Math.PI * 4;
				const radius = effectiveRadius * (0.2 + t * 0.8);
				const x = cx + Math.cos(angle) * radius;
				const y = cy + Math.sin(angle) * radius;
				
				if (s === 0) ctx.moveTo(x, y);
				else ctx.lineTo(x, y);
			}
			ctx.stroke();
		}

		const particleCount = 30;
		for (let i = 0; i < particleCount; i++) 
		{
			const particleAngle = (i / particleCount) * Math.PI * 2 + state.clock * 1.5;
			const orbitRadius = effectiveRadius * (0.5 + (i % 3) * 0.2);
			const wobble = Math.sin(state.clock * 3 + i) * 10;
			
			const px = cx + Math.cos(particleAngle) * (orbitRadius + wobble);
			const py = cy + Math.sin(particleAngle) * (orbitRadius + wobble);
			
			const particleSize = 2 + Math.sin(state.clock * 4 + i) * 1.5;
			const particleAlpha = 0.6 + Math.sin(state.clock * 5 + i) * 0.4;
			
			ctx.fillStyle = `rgba(150, 200, 255, ${particleAlpha})`;
			ctx.beginPath();
			ctx.arc(px, py, particleSize, 0, Math.PI * 2);
			ctx.fill();
			
			ctx.strokeStyle = `rgba(150, 200, 255, ${particleAlpha * 0.3})`;
			ctx.lineWidth = 1;
			ctx.beginPath();
			const trailLength = 15;
			const trailX = px - Math.cos(particleAngle) * trailLength;
			const trailY = py - Math.sin(particleAngle) * trailLength;
			ctx.moveTo(px, py);
			ctx.lineTo(trailX, trailY);
			ctx.stroke();
		}

		const coreSize = 20 * pulse;
		const coreGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreSize);
		coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
		coreGradient.addColorStop(0.3, 'rgba(150, 200, 255, 0.8)');
		coreGradient.addColorStop(0.7, 'rgba(50, 100, 200, 0.4)');
		coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
		
		ctx.fillStyle = coreGradient;
		ctx.beginPath();
		ctx.arc(cx, cy, coreSize, 0, Math.PI * 2);
		ctx.fill();

		ctx.strokeStyle = `rgba(100, 150, 255, ${0.3 * pulse})`;
		ctx.lineWidth = 3;
		ctx.beginPath();
		ctx.arc(cx, cy, effectiveRadius * 0.95, 0, Math.PI * 2);
		ctx.stroke();

		ctx.restore();

		const shockwaveInterval = 2;
		const timeSinceLastShock = state.clock % shockwaveInterval;
		if (timeSinceLastShock < 0.5) 
		{
			const shockProgress = timeSinceLastShock / 0.5;
			const shockRadius = effectiveRadius * shockProgress;
			const shockAlpha = (1 - shockProgress) * 0.6;
			
			ctx.strokeStyle = `rgba(200, 220, 255, ${shockAlpha})`;
			ctx.lineWidth = 4 * (1 - shockProgress);
			ctx.beginPath();
			ctx.arc(cx, cy, shockRadius, 0, Math.PI * 2);
			ctx.stroke();
		}
	}

	private renderOverlays(ctx: CanvasRenderingContext2D, state: PongGameState, timeoutStatus: TimeoutStatus, side: 'left' | 'right' | 'spectator', W: number, H: number): void {
		if (state.countdownValue > 0) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			ctx.fillStyle = '#fff';
			ctx.font = '120px monospace';
			ctx.textAlign = 'center';
			ctx.fillText(String(state.countdownValue), W / 2, H / 2);
		} 
		else if (state.isGameOver) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);
			if (this.net.isTournament) 
			{
				const amILeft = this.net.side === 'left';
				const didIWin = (amILeft && state.winner === 'left') || 
							(!amILeft && state.winner === 'right');
				
				ctx.fillStyle = didIWin ? '#00ff00' : '#ff0000';
				ctx.font = '72px monospace';
				ctx.fillText(didIWin ? 'VICTOIRE !' : 'D√âFAITE', W / 2, H / 2 - 40);
				
				ctx.fillStyle = '#fff';
				ctx.font = '36px monospace';
				ctx.fillText(`${state.winner} wins`, W / 2, H / 2 + 10);
				
				ctx.font = '24px monospace';
				ctx.fillText('Redirection vers les brackets...', W / 2, H / 2 + 60);
			} 
			else 
			{
				ctx.fillStyle = '#fff';
				ctx.font = '72px monospace';
				ctx.fillText('GAME OVER', W / 2, H / 2 - 40);
				ctx.font = '36px monospace';
				ctx.fillText(`${state.winner} wins`, W / 2, H / 2 + 10);
			}
		} 
		else if (state.isPaused) 
		{
			ctx.fillStyle = 'rgba(0,0,0,0.7)';
			ctx.fillRect(0, 0, W, H);

			const iAmLeft = side === 'left';
			const opponentDisconnected = iAmLeft
				? timeoutStatus.rightActive
				: timeoutStatus.leftActive;
			const opponentRemainingMs = iAmLeft
				? timeoutStatus.rightRemainingMs
				: timeoutStatus.leftRemainingMs;

			if (opponentDisconnected && opponentRemainingMs > 0) 
			{
				const secondsRemaining = Math.ceil(opponentRemainingMs / 1000);
				ctx.font = '36px monospace';
				ctx.fillStyle = '#ff6b6b';
				ctx.textAlign = 'center';
				ctx.fillText('‚ö†Ô∏è Adversaire d√©connect√©', W / 2, H / 2 + 20);

				ctx.font = '48px monospace';
				ctx.fillStyle = '#fff';
				ctx.fillText(`Forfeit dans: ${secondsRemaining}s`, W / 2, H / 2 + 80);

				const barWidth = 400;
				const barHeight = 10;
				const barX = (W - barWidth) / 2;
				const barY = H / 2 + 120;
				const progress = opponentRemainingMs / 30000;

				ctx.fillStyle = 'rgba(255,255,255,0.2)';
				ctx.fillRect(barX, barY, barWidth, barHeight);

				ctx.fillStyle = progress > 0.3 ? '#4CAF50' : '#ff6b6b';
				ctx.fillRect(barX, barY, barWidth * progress, barHeight);
			} 
			else 
			{
				ctx.fillStyle = '#fff';
				ctx.font = '72px monospace';
				ctx.textAlign = 'center';
				ctx.fillText('PAUSED', W / 2, H / 2);
				ctx.font = '24px monospace';
				ctx.fillText('Press P, SPACE or ESC to resume', W / 2, H / 2 + 60);
			}
		}
	}
}

// ==============================================
// üìÑ ./src/components/DebugPanel.ts
// ==============================================
import type { Component } from "./types";
import type { PublicState } from "../net/wsClient";

export interface DebugPanelCallbacks {
    onActivatePowerUp: (type: 'split' | 'blackout' | 'blackhole' | 'random') => void;
    onClearPowerUps: () => void;
    onScoreChange: (side: 'left' | 'right', amount: number) => void;
    onResetScore: () => void;
    onSetScore: (left: number, right: number) => void;
    onBallControl: (action: 'add' | 'remove' | 'reset') => void;
    onBallSpeedControl: (action: 'multiply' | 'divide' | 'freeze') => void;
    onTimeControl: (action: 'slow' | 'fast' | 'normal') => void;
    onToggleOverlay: () => void;
    onChangeSkill: (side: 'left' | 'right', skill: 'smash' | 'dash') => void;
}

export class DebugPanel implements Component {
    private element: HTMLElement;
    private isOpen: boolean = false;
    private callbacks: DebugPanelCallbacks;
    private overlayVisible: boolean = false;
    private isFrozen: boolean = false;
    private timeScale: number = 1;

    private fps: number = 0;
    private particleCount: number = 0;
    private ballsData: Array<{ x: number; y: number; vx: number; vy: number }> = [];
    private activePowerUps: string[] = [];
    private skillCooldowns: { 
        left: number;
        right: number;
    } = { 
        left: 0,
        right: 0
    };
    private selectedSkills: {
        left: 'smash' | 'dash';
        right: 'smash' | 'dash';
    } = {
        left: 'smash',
        right: 'smash'
    };

    private listeners: Array<{ el: Element; handler: EventListener }> = [];
    private closeBtn?: Element;
    private closeHandler?: EventListener;
    private boundKeydown?: (e: KeyboardEvent) => void;
    private destroyed = false;

    private isDragging = false;
    private dragOffsetX = 0;
    private dragOffsetY = 0;
    private posX = 20;
    private posY = 20;

    constructor(element: HTMLElement, callbacks: DebugPanelCallbacks) {
        this.element = element;
        this.callbacks = callbacks;
        this.init();
    }

    private init(): void {
        this.render();
        this.attachEventListeners();
        this.startFPSCounter();
        this.setupDragging();

        this.boundKeydown = (e: KeyboardEvent) => {
            if (e.key === 'm' || e.key === 'M') {
                e.preventDefault();
                this.toggle();
            }
        };
        window.addEventListener('keydown', this.boundKeydown);
    }

    private toggle(): void {
        this.isOpen = !this.isOpen;
        const panel = this.element.querySelector('.debug-panel') as HTMLElement;
        if (panel) {
            if (this.isOpen) {
                panel.classList.add('open');
            } else {
                panel.classList.remove('open');
            }
        }
    }

    public open(): void {
        this.isOpen = true;
        const panel = this.element.querySelector('.debug-panel') as HTMLElement;
        if (panel) {
            panel.classList.add('open');
        }
    }

    public close(): void {
        this.isOpen = false;
        const panel = this.element.querySelector('.debug-panel') as HTMLElement;
        if (panel) {
            panel.classList.remove('open');
        }
    }

    private startFPSCounter(): void {
        let lastTime = performance.now();
        let frames = 0;

        const updateFPS = () => {
            if (this.destroyed) return;
            frames++;
            const now = performance.now();

            if (now >= lastTime + 1000) {
                this.fps = Math.round((frames * 1000) / (now - lastTime));
                frames = 0;
                lastTime = now;
                this.updateOverlay();
            }
            requestAnimationFrame(updateFPS);
        };

        requestAnimationFrame(updateFPS);
    }

    public updateStats(state: PublicState, particleCount: number): void {
        this.particleCount = particleCount;
        this.ballsData = state.balls.map(b => ({
            x: Math.round(b.x),
            y: Math.round(b.y),
            vx: Math.round(b.vx),
            vy: Math.round(b.vy)
        }));

        this.activePowerUps = [];
        if (state.splitActive) this.activePowerUps.push('Split');
        if (state.blackoutLeft) this.activePowerUps.push('Blackout Left');
        if (state.blackoutRight) this.activePowerUps.push('Blackout Right');
        if (state.blackholeActive) this.activePowerUps.push('Blackhole');

        this.selectedSkills = {
            left: state.selectedSkills.left,
            right: state.selectedSkills.right
        };
        this.skillCooldowns = {
            left: state.skillStates.left.cooldownRemaining,
            right: state.skillStates.right.cooldownRemaining
        };

        this.updateOverlay();
    }

    private updateOverlay(): void {
        if (!this.overlayVisible) return;

        const overlay = this.element.querySelector('.debug-overlay') as HTMLElement;
        if (!overlay) return;

        const estimatedDrawCalls = this.ballsData.length * 3 +
            this.particleCount +
            this.activePowerUps.length * 10 +
            50; // Base UI elements

        overlay.innerHTML = `
            <div class="stat-line">FPS: <span class="stat-value">${this.fps}</span></div>
            <div class="stat-line">Particles: <span class="stat-value">${this.particleCount}</span></div>
            <div class="stat-line">Draw Calls: <span class="stat-value">~${estimatedDrawCalls}</span></div>
            <div class="stat-line">Time Scale: <span class="stat-value">${this.timeScale}x</span></div>
            
            <div class="stat-section">Balls (${this.ballsData.length}):</div>
            ${this.ballsData.map((b, i) => `
                <div class="stat-line small">
                    #${i + 1}: pos(${b.x}, ${b.y}) vel(${b.vx}, ${b.vy})
                </div>
            `).join('')}
            
            <div class="stat-section">Active Power-Ups:</div>
            ${this.activePowerUps.length > 0
                ? this.activePowerUps.map(p => `<div class="stat-line small">‚Ä¢ ${p}</div>`).join('')
                : '<div class="stat-line small">None</div>'
            }
            
            <div class="stat-section">Skill Cooldowns:</div>
            <div class="stat-line small">Left (${this.selectedSkills.left}): ${this.skillCooldowns.left.toFixed(1)}s</div>
            <div class="stat-line small">Right (${this.selectedSkills.right}): ${this.skillCooldowns.right.toFixed(1)}s</div>
        `;
    }

    private render(): void {
        this.element.innerHTML = `
        <style>
            .debug-panel {
                position: fixed;
                top: 20px;
                left: 20px;
                width: 400px;
                max-height: 80vh;
                overflow-y: auto;
                background: rgba(10, 10, 30, 0.95);
                backdrop-filter: blur(10px);
                border: 2px solid rgba(100, 150, 255, 0.3);
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                color: #fff;
                font-family: 'Courier New', monospace;
                font-size: 13px;
                z-index: 9999;
                display: none;
            }
            .debug-panel.open {
                display: block;
            }
            .debug-header {
                background: rgba(100, 150, 255, 0.2);
                padding: 12px 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                display: flex;
                justify-content: space-between;
                align-items: center;
                cursor: move;
                user-select: none;
            }
            .debug-title { font-size: 16px; font-weight: bold; color: #64B5F6; }
            .debug-close {
                background: rgba(255, 100, 100, 0.3);
                border: 1px solid rgba(255, 100, 100, 0.5);
                color: #fff;
                padding: 4px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                transition: all 0.2s;
            }
            .debug-section { padding: 16px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
            .debug-section:last-child { border-bottom: none; }
            .section-title { font-size: 14px; font-weight: bold; color: #90CAF9; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
            .debug-btn {
                background: rgba(100, 150, 255, 0.2);
                border: 1px solid rgba(100, 150, 255, 0.4);
                color: #fff;
                padding: 8px 14px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 12px;
                font-family: 'Courier New', monospace;
                transition: all 0.2s;
                margin: 4px;
                display: inline-block;
            }
            .debug-btn:hover { background: rgba(100, 150, 255, 0.4); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(100, 150, 255, 0.4); }
            .debug-btn:active { transform: translateY(0); }
            .debug-btn.danger { background: rgba(255, 100, 100, 0.2); border-color: rgba(255, 100, 100, 0.4); }
            .debug-btn.danger:hover { background: rgba(255, 100, 100, 0.4); box-shadow: 0 4px 12px rgba(255, 100, 100, 0.4); }
            .debug-btn.success { background: rgba(100, 255, 100, 0.2); border-color: rgba(100, 255, 100, 0.4); }
            .debug-btn.success:hover { background: rgba(100, 255, 100, 0.4); box-shadow: 0 4px 12px rgba(100, 255, 100, 0.4); }
            .debug-btn.small { padding: 6px 10px; font-size: 11px; }
            .debug-btn.active { background: rgba(100, 200, 255, 0.5); border-color: rgba(100, 200, 255, 0.8); box-shadow: 0 0 8px rgba(100, 200, 255, 0.6); }
            .btn-row { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px; }
            .score-control { display: flex; align-items: center; gap: 8px; margin: 8px 0; }
            .score-label { min-width: 50px; color: #90CAF9; }
            .skill-control { display: flex; align-items: center; gap: 8px; margin: 8px 0; }
            .skill-label { min-width: 80px; color: #90CAF9; font-weight: bold; }
            .debug-overlay {
                position: fixed;
                top: 20px;
                left: 20px;
                background: rgba(10, 10, 30, 0.9);
                backdrop-filter: blur(8px);
                border: 1px solid rgba(100, 150, 255, 0.3);
                border-radius: 8px;
                padding: 12px 16px;
                color: #fff;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                z-index: 9998;
                display: none;
            }
            .stat-line { margin: 4px 0; color: #B0BEC5; }
            .stat-line.small { font-size: 11px; margin-left: 12px; color: #78909C; }
            .stat-value { color: #64B5F6; font-weight: bold; }
            .stat-section { margin-top: 12px; margin-bottom: 4px; color: #90CAF9; font-weight: bold; border-top: 1px solid rgba(255, 255, 255, 0.1); padding-top: 8px; }
            .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
            .status-indicator.active { background: #4CAF50; box-shadow: 0 0 8px #4CAF50; }
            .status-indicator.inactive { background: #666; }
        </style>

        <div class="debug-panel">
            <div class="debug-header">
                <div class="debug-title">DEBUG PANEL</div>
                <button class="debug-close" data-action="close">Close [M]</button>
            </div>

            <div class="debug-section">
                <div class="section-title">Power-Ups</div>
                <div class="btn-row">
                    <button class="debug-btn" data-action="activate-split">Activate Split</button>
                    <button class="debug-btn" data-action="activate-blackout">Activate Blackout</button>
                    <button class="debug-btn" data-action="activate-blackhole">Activate Blackhole</button>
                    <button class="debug-btn" data-action="activate-random">Activate Random</button>
                    <button class="debug-btn danger" data-action="clear-powerups">Clear All</button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Score Control</div>
                <div class="score-control">
                    <span class="score-label">Left:</span>
                    <button class="debug-btn small" data-action="score-left-plus">+1</button>
                    <button class="debug-btn small" data-action="score-left-minus">-1</button>
                </div>
                <div class="score-control">
                    <span class="score-label">Right:</span>
                    <button class="debug-btn small" data-action="score-right-plus">+1</button>
                    <button class="debug-btn small" data-action="score-right-minus">-1</button>
                </div>
                <div class="btn-row">
                    <button class="debug-btn" data-action="reset-score">Reset (0-0)</button>
                    <button class="debug-btn" data-action="set-score-10">Set 10-10</button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Ball Control</div>
                <div class="btn-row">
                    <button class="debug-btn success" data-action="ball-add">Add Ball</button>
                    <button class="debug-btn danger" data-action="ball-remove">Remove Ball</button>
                    <button class="debug-btn" data-action="ball-reset">Reset to 1</button>
                </div>
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="debug-btn" data-action="ball-speed-multiply">Speed x2</button>
                    <button class="debug-btn" data-action="ball-speed-divide">Speed /2</button>
                    <button class="debug-btn" data-action="ball-freeze">
                        <span class="status-indicator inactive" data-freeze-indicator></span>
                        Freeze
                    </button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Time Control</div>
                <div class="btn-row">
                    <button class="debug-btn" data-action="time-slow">Slow (0.5x)</button>
                    <button class="debug-btn" data-action="time-fast">Fast (2x)</button>
                    <button class="debug-btn success" data-action="time-normal">Normal (1x)</button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Skills</div>
                <div class="skill-control">
                    <span class="skill-label">Left Player:</span>
                    <button class="debug-btn small" data-action="skill-left-smash" data-skill-left-smash>Smash</button>
                    <button class="debug-btn small" data-action="skill-left-dash" data-skill-left-dash>Dash</button>
                </div>
                <div class="skill-control">
                    <span class="skill-label">Right Player:</span>
                    <button class="debug-btn small" data-action="skill-right-smash" data-skill-right-smash>Smash</button>
                    <button class="debug-btn small" data-action="skill-right-dash" data-skill-right-dash>Dash</button>
                </div>
            </div>

            <div class="debug-section">
                <div class="section-title">Debug Overlay</div>
                <button class="debug-btn" data-action="toggle-overlay">
                    <span class="status-indicator inactive" data-overlay-indicator></span>
                    Toggle Stats HUD
                </button>
            </div>
        </div>

        <div class="debug-overlay"></div>
        `;
    }


    private attachEventListeners(): void {
        // Fermeture du panel
        const closeBtn = this.element.querySelector('[data-action="close"]');
        closeBtn?.addEventListener('click', () => this.toggle());

        // Power-Ups
        this.addListener('activate-split', () => this.callbacks.onActivatePowerUp('split'));
        this.addListener('activate-blackout', () => this.callbacks.onActivatePowerUp('blackout'));
        this.addListener('activate-blackhole', () => this.callbacks.onActivatePowerUp('blackhole'));
        this.addListener('activate-random', () => this.callbacks.onActivatePowerUp('random'));
        this.addListener('clear-powerups', () => this.callbacks.onClearPowerUps());

        // Score
        this.addListener('score-left-plus', () => this.callbacks.onScoreChange('left', 1));
        this.addListener('score-left-minus', () => this.callbacks.onScoreChange('left', -1));
        this.addListener('score-right-plus', () => this.callbacks.onScoreChange('right', 1));
        this.addListener('score-right-minus', () => this.callbacks.onScoreChange('right', -1));
        this.addListener('reset-score', () => this.callbacks.onResetScore());
        this.addListener('set-score-10', () => this.callbacks.onSetScore(10, 10));

        // Balls
        this.addListener('ball-add', () => this.callbacks.onBallControl('add'));
        this.addListener('ball-remove', () => this.callbacks.onBallControl('remove'));
        this.addListener('ball-reset', () => this.callbacks.onBallControl('reset'));
        this.addListener('ball-speed-multiply', () => this.callbacks.onBallSpeedControl('multiply'));
        this.addListener('ball-speed-divide', () => this.callbacks.onBallSpeedControl('divide'));
        this.addListener('ball-freeze', () => {
            this.callbacks.onBallSpeedControl('freeze');
            this.isFrozen = !this.isFrozen;
            this.updateFreezeIndicator();
        });

        // Time
        this.addListener('time-slow', () => {
            this.callbacks.onTimeControl('slow');
            this.timeScale = 0.5;
        });
        this.addListener('time-fast', () => {
            this.callbacks.onTimeControl('fast');
            this.timeScale = 2;
        });
        this.addListener('time-normal', () => {
            this.callbacks.onTimeControl('normal');
            this.timeScale = 1;
        });

        // Overlay
        this.addListener('toggle-overlay', () => {
            this.callbacks.onToggleOverlay();
            this.overlayVisible = !this.overlayVisible;
            this.updateOverlayIndicator();

            const overlay = this.element.querySelector('.debug-overlay') as HTMLElement;
            if (overlay) {
                overlay.style.display = this.overlayVisible ? 'block' : 'none';
            }
        });

        // Skills
        this.addListener('skill-left-smash', () => {
            this.callbacks.onChangeSkill('left', 'smash');
            this.updateSkillButtons();
        });
        this.addListener('skill-left-dash', () => {
            this.callbacks.onChangeSkill('left', 'dash');
            this.updateSkillButtons();
        });
        this.addListener('skill-right-smash', () => {
            this.callbacks.onChangeSkill('right', 'smash');
            this.updateSkillButtons();
        });
        this.addListener('skill-right-dash', () => {
            this.callbacks.onChangeSkill('right', 'dash');
            this.updateSkillButtons();
        });

        this.updateSkillButtons();
    }

    private addListener(action: string, callback: () => void): void {
        const el = this.element.querySelector(`[data-action="${action}"]`);
        if (!el) return;

        const handler = (() => callback()) as EventListener;
        el.addEventListener('click', handler);
        this.listeners.push({ el, handler });
    }

    private updateFreezeIndicator(): void {
        const indicator = this.element.querySelector('[data-freeze-indicator]');
        if (indicator) {
            indicator.className = `status-indicator ${this.isFrozen ? 'active' : 'inactive'}`;
        }
    }

    private updateOverlayIndicator(): void {
        const indicator = this.element.querySelector('[data-overlay-indicator]');
        if (indicator) {
            indicator.className = `status-indicator ${this.overlayVisible ? 'active' : 'inactive'}`;
        }
    }

    private updateSkillButtons(): void {
        const leftSmash = this.element.querySelector('[data-skill-left-smash]');
        const leftDash = this.element.querySelector('[data-skill-left-dash]');
        const rightSmash = this.element.querySelector('[data-skill-right-smash]');
        const rightDash = this.element.querySelector('[data-skill-right-dash]');

        if (leftSmash && leftDash) {
            leftSmash.classList.toggle('active', this.selectedSkills.left === 'smash');
            leftDash.classList.toggle('active', this.selectedSkills.left === 'dash');
        }

        if (rightSmash && rightDash) {
            rightSmash.classList.toggle('active', this.selectedSkills.right === 'smash');
            rightDash.classList.toggle('active', this.selectedSkills.right === 'dash');
        }
    }

    private setupDragging(): void {
        const header = this.element.querySelector('.debug-header') as HTMLElement;
        const panel = this.element.querySelector('.debug-panel') as HTMLElement;
        if (!header || !panel) return;

        const onMouseDown = (e: MouseEvent) => {
            if ((e.target as HTMLElement).classList.contains('debug-close')) return;
            
            this.isDragging = true;
            const rect = panel.getBoundingClientRect();
            this.dragOffsetX = e.clientX - rect.left;
            this.dragOffsetY = e.clientY - rect.top;
            
            header.style.cursor = 'grabbing';
        };

        const onMouseMove = (e: MouseEvent) => {
            if (!this.isDragging) return;

            this.posX = e.clientX - this.dragOffsetX;
            this.posY = e.clientY - this.dragOffsetY;

            this.posX = Math.max(0, Math.min(window.innerWidth - panel.offsetWidth, this.posX));
            this.posY = Math.max(0, Math.min(window.innerHeight - 100, this.posY));

            panel.style.left = `${this.posX}px`;
            panel.style.top = `${this.posY}px`;
        };

        const onMouseUp = () => {
            this.isDragging = false;
            header.style.cursor = 'move';
        };

        header.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        this.listeners.push(
            { el: header, handler: onMouseDown as EventListener },
            { el: window as any, handler: onMouseMove as EventListener },
            { el: window as any, handler: onMouseUp as EventListener }
        );
    }

    cleanup(): void {
        this.destroyed = true;

        for (const { el, handler } of this.listeners) {
            el.removeEventListener('click', handler);
        }
        this.listeners = [];

        if (this.closeBtn && this.closeHandler) {
            this.closeBtn.removeEventListener('click', this.closeHandler);
            this.closeBtn = undefined;
            this.closeHandler = undefined;
        }

        if (this.boundKeydown) {
            window.removeEventListener('keydown', this.boundKeydown);
            this.boundKeydown = undefined;
        }

        this.element.innerHTML = '';
    }
}

// ==============================================
// üìÑ ./src/components/index.ts
// ==============================================
import { PongGame } from './PongGame/PongGame';
import { ComponentRegistry } from './ComponantManager';
import { JoinTournamentComponent } from './JoinTournament';

export function registerComponents(): void
{
    ComponentRegistry.register('pong-game', PongGame)
    ComponentRegistry.register('joinTournament', JoinTournamentComponent)
}

// ==============================================
// üìÑ ./src/components/Header.ts
// ==============================================
import type { ComponentProps } from './types';
import { Button } from './Button';

interface HeaderProps extends ComponentProps {
    isLogged?: boolean
}

export function Header({ 
	className = '',
	isLogged = false
}: HeaderProps): string {

	const baseClass = `
		container flex justify-between
		gap-4 py-4 px-8 mt-4 ml-auto mr-auto
		rounded-xl
		bg-orange-600
		${className}
	`.replace(/\s+/g, ' ').trim();
	
	return `
		<header class="${baseClass}">
			<h1 class="text-2xl text-white">Pongers!</h1>
			${isLogged ? 
				Button({
					children: "Profile",
					id: "profileBtn",
					variant: "secondary",
					size: "md",
					href: ""
				})
					:
				Button({
					children: "Login",
					id: "loginBtn",
					variant: "secondary",
					size: "md",
					href: "/login"
				})
			}
		</header>
	`;
}

// ==============================================
// üìÑ ./src/components/Button.ts
// ==============================================
import type { ComponentProps } from './types';
import { renderChildren } from './types';

// ============= BUTTON DE BASE =============
interface ButtonProps extends ComponentProps {
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
    size?: 'sm' | 'md' | 'lg';
    href?: string;
}

export function Button({ 
    children, 
    variant = 'primary', 
    size = 'md',
    href,
    className = '',
    id
}: ButtonProps): string {
    const variants = {
        primary: 'bg-blue-500 hover:bg-blue-600 text-white',
        secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-800',
        danger: 'bg-red-500 hover:bg-red-600 text-white',
		default: ''
    };
    
    const sizes = {
        sm: 'px-3 py-1 text-sm',
        md: 'px-4 py-2',
        lg: 'px-6 py-3 text-lg'
    };
    
    const baseClass = `
        ${variants[variant]}
        ${sizes[size]}
        rounded-lg font-medium transition-colors cursor-pointer
		relative block w-fit
        ${className}
    `.replace(/\s+/g, ' ').trim();
    
    const content = renderChildren(children);
    
    if (href) {
        return `<a href="${href}" id=${id} class="${baseClass}">${content}</a>`;
    }
    
    return `<button id=${id} class="${baseClass}">${content}</button>`;
}

// ============= SETTINGS BUTTON =============
interface SettingsButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
}

export function SettingsButton({ 
    className = '', 
    size = 'md' 
}: SettingsButtonProps = {}): string {
    return Button({
        children: "‚öôÔ∏è",
        variant: "default",
        size: size,
        href: "/settings",
        className: className,
        id: "settings-button"
    });
}

// ============= SKIN BUTTON =============
interface SkinButtonProps extends ButtonProps {
    showLabel?: boolean;
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
}

export function SkinButton({ 
    className = '', 
    size = 'md',
    showLabel = true,
    variant = 'default'
}: SkinButtonProps = {}): string {
    const buttonContent = showLabel ? "üé®" : "üé®";
    
    return Button({
        children: buttonContent,
        variant: variant,
        size: size,
        href: "/customization",
        className: className,
        id: "skin-button"
    });
}

// ============= COFFEE BUTTON =============
interface CoffeeButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
    showIcon?: boolean;
}

export function CoffeeButton({ 
    className = '', 
    size = 'md',
    showIcon = true
}: CoffeeButtonProps = {}): string {
    const content = showIcon ? "‚òï Buy me a Coffee" : "Buy me a Coffee";
    
    return Button({
        children: content,
        variant: "default",
        size: size,
        href: "/cafe",
        className: `bg-yellow-500 hover:bg-yellow-600 ${className}`,
        id: "coffee-button"
    });
}

// ============= BACK BUTTON =============
interface BackButtonProps {
    className?: string;
    size?: 'sm' | 'md' | 'lg';
    text?: string;
    variant?: 'primary' | 'secondary' | 'danger' | 'default';
}

export function BackButton({ 
    className = '', 
    size,
    text = "‚Üê",
    variant = 'default'
}: BackButtonProps = {}): string {
    return `
        <button 
            onclick="history.back()" 
            class="
                ${variant === 'primary' ? 'bg-blue-500 hover:bg-blue-600 text-white' : ''}
                ${variant === 'secondary' ? 'bg-gray-200 hover:bg-gray-300 text-gray-800' : ''}
                ${variant === 'danger' ? 'bg-red-500 hover:bg-red-600 text-white' : ''}
                ${size === 'sm' ? 'px-3 py-1 text-sm' : ''}
                ${size === 'md' ? 'px-4 py-2' : ''}
                ${size === 'lg' ? 'px-6 py-3 text-lg' : ''}
                rounded-lg font-medium transition-colors cursor-pointer
                relative block w-fit
                ${className}
            "
            id="back-button"
        >
            ${text}
        </button>
    `;
}

// ==============================================
// üìÑ ./src/components/Game3d/core/renderer3D.ts
// ==============================================
import { Paddle } from "../entities/Paddle";
import { Ball } from "../entities/Ball";
import { Scoreboard } from "../entities/Scoreboard";
import { CelebrationSphere } from "../entities/CelebrationSphere";
import { PowerUpEffects } from "../entities/PowerUpEffects";
import type { Scene } from "@babylonjs/core";
import type { Game3DState, PowerUpsState } from "../types";
import { PowerUp } from "../entities/powerUp";
import { NetworkManager } from "../network/NetworkManager";
export class Renderer3D {
	private scene: Scene;
	
	// Entities
	private paddleLeft!: Paddle;
	private paddleRight!: Paddle;
	private balls: Map<string, Ball> = new Map();
	private scoreboard!: Scoreboard;
	private celebrationSphere!: CelebrationSphere;
	private powerUpMeshes: Map<string, PowerUp> = new Map(); //todo add !
	
	
	private currentState!: Game3DState;
	private powerUpEffects!: PowerUpEffects;
	private networkManager: NetworkManager;
	
	private lastScore = { left: 0, right: 0 };
	
	private lastBlackholeActive = false;
	private lastBlackoutLeft = false;
	private lastBlackoutRight = false;

	constructor(scene: Scene, networkManager: NetworkManager) {
		this.scene = scene;
		this.networkManager = networkManager;
		this.createInitialEntities();
	}

	private createInitialEntities(): void {
		this.paddleLeft = new Paddle(this.scene, 'left');
		this.paddleRight = new Paddle(this.scene, 'right');
		this.scoreboard = new Scoreboard(this.scene);
		this.celebrationSphere = new CelebrationSphere(this.scene);
		this.powerUpEffects = new PowerUpEffects(this.scene);
	}


	public updateFromState(state: Game3DState): void {
		this.currentState = state;
		if (this.paddleLeft) {
			this.paddleLeft.updateFromState(state.paddleLeft, this.smashOffsetX?.('left'));
		}
		if (this.paddleRight) {
			this.paddleRight.updateFromState(state.paddleRight, this.smashOffsetX?.('right'));
		}
		this.updateBalls(state.balls);
		this.updatePowerUps(state.powerUpState);
		// update scoreboard
		if (this.scoreboard && state.score) {
			if (state.score.left !== this.lastScore.left || state.score.right !== this.lastScore.right) {
				if (state.score.left > this.lastScore.left) {
					this.celebrationSphere.update();
				} else if (state.score.right > this.lastScore.right) {
					this.celebrationSphere.update();
				}
				
				this.scoreboard.updateScore(state.score.left, state.score.right);
				this.lastScore.left = state.score.left;
				this.lastScore.right = state.score.right;
			}
		}
	}

	private smashOffsetX = (side: 'left' | 'right'): number => {
		const skillType = side === 'left' ? this.currentState.selectedSkills.left : this.currentState.selectedSkills.right;
		if (skillType !== 'smash') 
		{
			return 0;
		}

		const skillState = side === 'left' ? this.currentState.skillStates.left : this.currentState.skillStates.right;
		const dur = 0.12;
		const dt = Math.max(0, this.currentState.clock - skillState.lastActivationAt);

		if (dt <= 0 || dt > dur) 
		{
			return 0;
		}
		const t = dt / dur;
		const amp = 0.5;
		const dir = side === 'left' ? 1 : -1;
		return dir * amp * Math.sin(Math.PI * t);
	};

	private updateBalls(ballStates: any[]): void {
		const currentBallIds = new Set(ballStates.map(b => b.id) || 'main');
		const existingBallIds = new Set(this.balls.keys());

		for (const id of existingBallIds) {
			if (!currentBallIds.has(id)) {
				const ball = this.balls.get(id);
				ball?.dispose();
				this.balls.delete(id);
			}
		}

		ballStates.forEach((ballState, index) => {
			const id = ballState.id || `main-${index}`;
			let ball = this.balls.get(id);
			if (!ball) {
				ball = new Ball(this.scene, id);
				this.balls.set(id, ball);
			}
			ball.updateFromState(ballState);
		});
	}

	private updatePowerUps(state: PowerUpsState): void {
		const currentPowerUpIds = new Set<string>();

		for (let i = 0; i < state.allPowerUps.length; i++) {
			const powerUp = state.allPowerUps[i];
			const id = `powerup-${powerUp.type}-${Math.round(powerUp.x * 100)}-${Math.round(powerUp.y * 100)}`;;
			currentPowerUpIds.add(id);

			let mesh = this.powerUpMeshes.get(id);

			if (!mesh) {
				mesh = new PowerUp(this.scene, id, powerUp);
				this.powerUpMeshes.set(id, mesh);
			}
			mesh.updateState(powerUp);
			mesh.update();
		}

		for (const [id, mesh] of this.powerUpMeshes.entries()) {
			if (!currentPowerUpIds.has(id)) {
				mesh.dispose();
				this.powerUpMeshes.delete(id);
			}
		}

		// Blackhole activation
		if (state.blackholeActive && !this.lastBlackholeActive) {
			this.powerUpEffects.triggerBlackholeEffect();
		}

		// Blackhole deactivation
		if (!state.blackholeActive && this.lastBlackholeActive) {
			this.powerUpEffects.resetBlackholeEffect();
		}
		
		this.lastBlackholeActive = state.blackholeActive;
		
		// Blackout activation
		if (state.blackoutLeft && this.networkManager.getSide() === 'left' && !this.lastBlackoutLeft) {
			this.powerUpEffects.activateBlackoutEffect('left');
		}
		if (state.blackoutRight && this.networkManager.getSide() === 'right' && !this.lastBlackoutRight) {
			this.powerUpEffects.activateBlackoutEffect('right');
		}
		this.lastBlackoutLeft = state.blackoutLeft;
		this.lastBlackoutRight = state.blackoutRight;

		// Blackout deactivation
		if (!state.blackoutLeft && this.networkManager.getSide() === 'left') {
			this.powerUpEffects.restoreVisibilityAfterBlackout();
		}
		if (!state.blackoutRight && this.networkManager.getSide() === 'right') {
			this.powerUpEffects.restoreVisibilityAfterBlackout();
		}

		// Per frame update (only helix now)
		this.powerUpEffects.update();
	}

	public render(): void {
		this.scene.render();
	}

	public getCurrentState(): Game3DState {
		return this.currentState;
	}

	public dispose(): void {
		this.paddleLeft?.dispose();
		this.paddleRight?.dispose();
		this.scoreboard?.dispose();
		this.celebrationSphere?.dispose();
		this.balls.forEach(ball => ball.dispose());
		this.balls.clear();
		this.powerUpMeshes.forEach(p => p.dispose());
		this.powerUpMeshes.clear();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/core/sceneManager.ts
// ==============================================
// todo: add shadows
// todo: optimize imports
// todo: add gates material
// todo: add camera intro animation
// todo: add stadium loading error handling
// todo: maybe add more types for environment

import '@babylonjs/loaders';
import { Animation, ArcRotateCamera, AxesViewer, Color3, CubicEase, DirectionalLight, EasingFunction, Engine, GlowLayer, HemisphericLight, Mesh, MeshBuilder, Scene, SceneLoader, StandardMaterial, Texture, Vector3 } from '@babylonjs/core';
import { CAMERA, MATERIALS } from '../constants';

export class SceneManager {
	private scene: Scene;
	private camera: ArcRotateCamera;
	private cameraViewMode: 'overhead' | 'fps' = 'overhead';
	private environment: {
		skybox: Mesh;
		stadium: {
			ground: Mesh | null;
			group_border: Mesh | null;
			gates: {
				cables: Mesh[] | null;
				poleCylinders: Mesh[] | null;
				poleTops: Mesh[] | null;
				poleMids: Mesh[] | null;
				poleBots: Mesh[] | null;
			} | null;
			groundTexture: Mesh[] | null;
		} | null;
	};
	private lights: {
		ambient: HemisphericLight;
		main: DirectionalLight;
	};
	private engine: Engine;
	private canvas: HTMLCanvasElement;
	// private axisHelper: AxesViewer; // dev

	constructor(engine: Engine, canvas: HTMLCanvasElement) {
		this.engine = engine;
		this.canvas = canvas;
		this.scene = this.createScene();
		this.camera = this.setupCamera();
		this.lights = this.setupLights();
		this.environment = this.setupEnvironment();
		// this.axisHelper = this.setupAxisHelper(); // dev
	}
	
	private createScene(): Scene {
		const scene = new Scene(this.engine);
		// OPTI
		scene.autoClear = true;
		scene.autoClearDepthAndStencil = true;
		scene.skipPointerMovePicking = true;
		return scene;
	}

	private setupCamera(): ArcRotateCamera {
		const camera = new ArcRotateCamera(
			'mainCamera',
			CAMERA.INITIAL_ALPHA,
			CAMERA.INITIAL_BETA,
			CAMERA.INITIAL_RADIUS,
			new Vector3(CAMERA.TARGET.x, CAMERA.TARGET.y, CAMERA.TARGET.z),
			this.scene
		);
		// camera.attachControl(this.canvas, true); //dev to move camera with drag
		// camera.lowerRadiusLimit = 10;// dev
		// camera.upperRadiusLimit = 400;// dev
		
		return camera;
	}

	private setupLights(): typeof this.lights {
		const ambientLight = new HemisphericLight('ambientLight', new Vector3(0, 1, 0), this.scene);
		const mainLight = new DirectionalLight('mainLight', new Vector3(-1, -2, -1), this.scene);
		mainLight.position = new Vector3(20, 40, 20);
		mainLight.intensity = 0.7;
		// todo shadows
		return {
			ambient: ambientLight,
			main: mainLight
		};
	}

	private setupEnvironment(): typeof this.environment {
		const skybox = this.createSkybox();
		const environment = {
			skybox: skybox,
			stadium: null as {
				ground: Mesh | null;
				group_border: Mesh | null;
				gates: {
					cables: Mesh[] | null;
					poleCylinders: Mesh[] | null;
					poleTops: Mesh[] | null;
					poleMids: Mesh[] | null;
					poleBots: Mesh[] | null;
				} | null,
				groundTexture: Mesh[] | null;
			} | null
		};

		this.createStadium().then((stadium) => {
			environment.stadium = stadium || null;
		});
		return environment;
	}

	private createSkybox(): Mesh {
		const skybox = MeshBuilder.CreateSphere('skybox', { diameter: 150, sideOrientation: Mesh.BACKSIDE }, this.scene);
		// Material
		const skyboxMaterial = new StandardMaterial('skyboxMat', this.scene);
		const skyboxTexture = new Texture('/assets/textures/skysphere_bg.png', this.scene);

		// Texture
		skyboxTexture.uScale = 8;
		skyboxTexture.vScale = 5;
		skyboxTexture.wAng = Math.PI;
		
		// Properties
		skyboxMaterial.diffuseTexture = skyboxTexture;
		skyboxMaterial.emissiveTexture = skyboxTexture;
		skyboxMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);
		skyboxMaterial.backFaceCulling = false;
		skyboxMaterial.specularColor = new Color3(0, 0, 0);
		skyboxMaterial.disableLighting = true;
		skybox.material = skyboxMaterial;

		return skybox;
	}

	private async createStadium(): Promise<{ ground: Mesh | null; group_border: Mesh | null; gates: { cables: Mesh[] | null; poleCylinders: Mesh[] | null; poleTops: Mesh[] | null; poleMids: Mesh[] | null; poleBots: Mesh[] | null; } | null; groundTexture: Mesh[] | null }> {
		await SceneLoader.ImportMeshAsync('', '/assets/models/', 'stadium.gltf', this.scene);

		const ground = this.scene.getMeshByName('ground') as Mesh | null;
		const group_border = this.scene.getMeshByName('group_border') as Mesh | null;
		const blackholeHelix = this.scene.getMeshByName('blacholeHelix') as Mesh | null;

		// Ground material
		if (ground) {
			const groundMaterial = new StandardMaterial('groundMat', this.scene);
			groundMaterial.diffuseColor = Color3.FromHexString('#0A6219');
			groundMaterial.alpha = 0.7;
			groundMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
			ground.material = groundMaterial;
			ground.receiveShadows = true;
		}

		// Border material
		if (group_border) {
			const borderGroundMaterial = new StandardMaterial('borderMat', this.scene);
			borderGroundMaterial.diffuseColor = Color3.FromHexString("#353535");
			borderGroundMaterial.specularColor = Color3.FromHexString(MATERIALS.BORDER);
			group_border.material = borderGroundMaterial;
		}

		// Gates structure
		const gates = {
			cables: this.getMeshesByPrefix('cable'),
			poleCylinders: this.getMeshesByPrefix('poleCylinder'),
			poleTops: this.getMeshesByPrefix('poleTop'),
			poleMids: this.getMeshesByPrefix('poleMid'),
			poleBots: this.getMeshesByPrefix('poleBot'),
		};
		
		this.colorCables(gates.cables);
		this.colorPoleCylinders(gates.poleCylinders);
		this.colorPoleTops(gates.poleTops);
		this.colorPoleMids(gates.poleMids);
		this.colorPoleBots(gates.poleBots);

		const groundTexture = this.createGroundTexture();

		if (blackholeHelix) {
			const helixMaterial = new StandardMaterial('blackholeHelixMat', this.scene);
			helixMaterial.diffuseColor = Color3.FromHexString('#000000');
			helixMaterial.emissiveColor = Color3.FromHexString('#000000').scale(0.8);
			helixMaterial.specularColor = Color3.FromHexString('#000000');
			helixMaterial.alpha = 0;
			blackholeHelix.material = helixMaterial;
		}
		return { ground, group_border, gates, groundTexture };
	}

	private getMeshesByPrefix(prefix: string): Mesh[] | null {
		const meshes = this.scene.meshes.filter((mesh: any) => typeof mesh.name === 'string' && mesh.name.startsWith(prefix)) as Mesh[];
		return meshes.length > 0 ? meshes : null;
	}

	private createGroundTexture(): Mesh[] {
		const textures: Mesh[] = [];
		const textureElements = ['centerCircle', 'centerCircleInner', 'lineMid', 'lineBorderLeft', 'lineBorderRight', 'lineBorderTop', 'lineBorderBot'];
		const whiteTexture = new StandardMaterial('whiteLineMat', this.scene);
		whiteTexture.diffuseColor = Color3.FromHexString('#FFFFFF');
		const centerInnerColorBlack = new StandardMaterial('centerInnerBlackMat', this.scene);
		centerInnerColorBlack.diffuseColor = Color3.Black();
		centerInnerColorBlack.specularColor = Color3.Black();
		centerInnerColorBlack.emissiveColor = Color3.Black();
		centerInnerColorBlack.disableLighting = true;
		centerInnerColorBlack.alpha = 0;

		for (const element of textureElements) {
			const texture = this.scene.getMeshByName(element) as Mesh | null;
			if (texture) {
				texture.material = texture.name === 'centerCircleInner' ? centerInnerColorBlack : whiteTexture;
				textures.push(texture);
			}
		}
		return textures;
	}
	
	private colorCables(cables: Mesh[] | null): void {
		if (!cables) return;
		const cableMaterial = new StandardMaterial('cableMat', this.scene);
		cableMaterial.diffuseColor = Color3.FromHexString(MATERIALS.CABLE);
		cableMaterial.alpha = 0.4;
		cableMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
		cables.forEach(cable => {
			cable.material = cableMaterial;
		});
	}
	
	private colorPoleCylinders(poleCylinders: Mesh[] | null): void {
		if (!poleCylinders) return;
		const poleCylinderMaterial = new StandardMaterial('poleCylinderMat', this.scene);
		poleCylinderMaterial.diffuseColor = Color3.FromHexString(MATERIALS.poleCylinder);
		poleCylinders.forEach(poleCylinder => {
			poleCylinder.material = poleCylinderMaterial;
		});
	}
	
	private colorPoleTops(poleTops: Mesh[] | null): void {
		if (!poleTops) return;
		const poleTopMaterial = new StandardMaterial('poleTopMat', this.scene);
		poleTopMaterial.diffuseColor = Color3.FromHexString(MATERIALS.poleTop).scale(1.5);
		poleTopMaterial.specularColor = Color3.White();
		poleTopMaterial.specularPower = 128;
		poleTopMaterial.emissiveColor = Color3.FromHexString(MATERIALS.poleTop).scale(0.3);
		poleTops.forEach(poleTop => {
			poleTop.material = poleTopMaterial;
		});
	}
	
	private colorPoleMids(poleMids: Mesh[] | null): void {
		if (!poleMids) return;
		const poleMidMaterial = new StandardMaterial('poleMidMat', this.scene);
		poleMidMaterial.diffuseColor = Color3.FromHexString(MATERIALS.poleMid);
		poleMids.forEach(poleMid => {
			poleMid.material = poleMidMaterial;
		});
	}
	
	private colorPoleBots(poleBots: Mesh[] | null): void {
		if (!poleBots) return;
		const poleBotMaterial = new StandardMaterial('poleBotMat', this.scene);
		poleBotMaterial.diffuseColor = Color3.FromHexString(MATERIALS.poleBot);
		poleBots.forEach(poleBot => {
			poleBot.material = poleBotMaterial;
		});
	}
	// private setupAxisHelper(): AxesViewer { //dev
	// 	const axisHelper = new AxesViewer(this.scene, 1);
	// 	return axisHelper;
	// }

	public playCameraIntro(): void {
		const startHorizontalRotation = CAMERA.ANIMATION.START_ALPHA;
		const startVerticalAngle = CAMERA.ANIMATION.START_BETA;
		const startDistance = CAMERA.ANIMATION.START_RADIUS;

		const finalHorizontalRotation = CAMERA.ANIMATION.END_ALPHA;
		const finalVerticalAngle = CAMERA.ANIMATION.END_BETA;
		const finalDistance = CAMERA.ANIMATION.END_RADIUS;

		this.camera.alpha = startHorizontalRotation;
		this.camera.beta = startVerticalAngle;
		this.camera.radius = startDistance;

		// CREATE ANIMATIONS
		const horizontalRotationAnimation = new Animation(
			'cameraHorizontalRotation',
			'alpha',
			60,//fps
			Animation.ANIMATIONTYPE_FLOAT,
			Animation.ANIMATIONLOOPMODE_CONSTANT
		);
		const verticalAngleAnimation = new Animation(
			'cameraVerticalAngle',
			'beta',
			60,
			Animation.ANIMATIONTYPE_FLOAT,
			Animation.ANIMATIONLOOPMODE_CONSTANT
		);
		const distanceAnimation = new Animation(
			'cameraDistance',
			'radius',
			60,
			Animation.ANIMATIONTYPE_FLOAT,
			Animation.ANIMATIONLOOPMODE_CONSTANT
		);
		
		// KEYFRAMES
		const horizontalRotationKeys = [
			{ frame: 0, value: startHorizontalRotation },
			{ frame: CAMERA.ANIMATION.DURATION_FRAMES, value: finalHorizontalRotation }
		];
		const verticalAngleKeys = [
			{ frame: 0, value: startVerticalAngle },
			{ frame: CAMERA.ANIMATION.DURATION_FRAMES, value: finalVerticalAngle }
		];
		const distanceKeys = [
			{ frame: 0, value: startDistance },
			{ frame: CAMERA.ANIMATION.DURATION_FRAMES, value: finalDistance }
		];
		
		horizontalRotationAnimation.setKeys(horizontalRotationKeys);
		verticalAngleAnimation.setKeys(verticalAngleKeys);
		distanceAnimation.setKeys(distanceKeys);
		
		// EASING
		const easingFunction = new CubicEase();
		easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEOUT);
		horizontalRotationAnimation.setEasingFunction(easingFunction);
		verticalAngleAnimation.setEasingFunction(easingFunction);
		distanceAnimation.setEasingFunction(easingFunction);
		
		// START ANIMATION
		this.camera.animations = [horizontalRotationAnimation, verticalAngleAnimation, distanceAnimation];
		this.scene.beginAnimation(this.camera, 0, CAMERA.ANIMATION.DURATION_FRAMES, false);
	}

	public toggleCameraView(playerSide: 'left' | 'right' | 'spectator'): void {
		if (this.cameraViewMode === 'overhead') {
			this.cameraViewMode = 'fps';
			this.camera.alpha = playerSide === 'left' ? CAMERA.FPS_ALPHA + Math.PI : CAMERA.FPS_ALPHA;
			this.camera.beta = CAMERA.FPS_BETA;
			this.camera.radius = CAMERA.FPS_RADIUS;
		} else {
			this.cameraViewMode = 'overhead';
			this.camera.alpha = CAMERA.INITIAL_ALPHA;
			this.camera.beta = CAMERA.INITIAL_BETA;
			this.camera.radius = CAMERA.INITIAL_RADIUS;
		}
	}

	public getCamera(): ArcRotateCamera {
		return this.camera;
	}

	public getEnvironment(): typeof this.environment {
		return this.environment;
	}

	public getScene(): Scene {
		return this.scene;
	}

	public dispose(): void {
		this.environment.stadium?.ground?.dispose();
		this.environment.stadium?.group_border?.dispose();
		this.environment.stadium?.gates?.cables?.forEach(mesh => mesh.dispose());
		this.environment.stadium?.gates?.poleCylinders?.forEach(mesh => mesh.dispose());
		this.environment.stadium?.gates?.poleTops?.forEach(mesh => mesh.dispose());
		this.environment.stadium?.gates?.poleMids?.forEach(mesh => mesh.dispose());
		this.environment.stadium?.gates?.poleBots?.forEach(mesh => mesh.dispose());
		this.environment.skybox.dispose();
		// this.axisHelper.dispose(); // dev
		this.lights.main.dispose();
		this.lights.ambient.dispose();
		this.camera.dispose();
		this.scene.dispose();
		this.engine.dispose();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/core/game3DEngine.ts
// ==============================================
import { Engine } from '@babylonjs/core';
import { SceneManager } from './sceneManager';
import { Renderer3D } from './renderer3D';
import { InputSystem } from '../systems/InputSystem';
import { NetworkManager } from '../network/NetworkManager';
import { UIManager } from '../ui/UIManager';
import { StateAdapter } from '../utils/StateAdapter';
import type { TimeoutStatus, GameStatusInfo } from '../types';

export class Game3DEngine {
	private engine: Engine;
	private sceneManager: SceneManager;
	private renderer!: Renderer3D;
	private canvas: HTMLCanvasElement;
	private roomId: string;
	private isRunning: boolean = false;

	public gameStatusInfo: GameStatusInfo = {
		isPaused: false,
		isGameOver: false,
		winner: '',
		countdownValue: 0,
		score: { left: 0, right: 0 }
	};

	private timeoutStatus: TimeoutStatus = {
		leftActive: false,
		leftRemainingMs: 0,
		rightActive: false,
		rightRemainingMs: 0
	};

	private gameOverHandled: boolean = false;

	// systems
	private inputSystem!: InputSystem;
	private networkManager!: NetworkManager;
	private uiManager!: UIManager;

	constructor(canvas: HTMLCanvasElement) {
		this.canvas = canvas;
		this.roomId = this.getRoomIdFromURL();
		
		this.engine = new Engine(canvas, true, {
			preserveDrawingBuffer: false,
			stencil: false,
			antialias: true,
			powerPreference: 'high-performance'
		});
		
		this.sceneManager = new SceneManager(this.engine, canvas);
		this.initializeSystems();
	}

	private getRoomIdFromURL(): string { // todo needs better secu
		return (window.location.pathname.split('/').pop() || '');
	}

	private initializeSystems(): void {
		this.inputSystem = new InputSystem(this.canvas);
		this.networkManager = new NetworkManager(this.roomId);
		this.uiManager = new UIManager();
		this.inputSystem.initialize();
		this.setupNetworkCallbacks();
		this.renderer = new Renderer3D(this.sceneManager.getScene(), this.networkManager);
	}

	private setupNetworkCallbacks(): void {
		this.networkManager.onStateUpdate = (serverState) => {
			this.gameStatusInfo = StateAdapter.getStatusInfo(serverState);
			const game3DState = StateAdapter.toGame3DState(serverState);
			this.renderer.updateFromState(game3DState);
		};

		this.networkManager.onPaused = () => {
			this.gameStatusInfo.isPaused = true;
			this.timeoutStatus = {
				leftActive: false,
				leftRemainingMs: 0,
				rightActive: false,
				rightRemainingMs: 0
			};
		};

		this.networkManager.onResumed = () => {
			this.gameStatusInfo.isPaused = false;
		};

		this.networkManager.onTimeoutStatus = (status) => {
			this.timeoutStatus = {
				leftActive: status.left.active,
				leftRemainingMs: status.left.remainingMs,
				rightActive: status.right.active,
				rightRemainingMs: status.right.remainingMs
			};
		};

		this.networkManager.onCountdown = (v) => {
			this.gameStatusInfo.countdownValue = v;
		};

		this.networkManager.onWelcome = (side, playerNames) => {
			this.uiManager.updatePlayerNames(side, playerNames);
			this.timeoutStatus = {
				leftActive: false,
				leftRemainingMs: 0,
				rightActive: false,
				rightRemainingMs: 0
			};
		};

		this.networkManager.onGameOver = (winner, isTournament, tournamentId) => {
			if (this.gameOverHandled) return;
			this.gameOverHandled = true;
			// Make sure internal status reflects game over so UIManager.render won't show pause overlays
			this.gameStatusInfo.isGameOver = true;
			this.gameStatusInfo.isPaused = false;
			this.gameStatusInfo.countdownValue = 0;
			
			const forfeitBtn = document.getElementById('forfeit-btn') as HTMLButtonElement;
			if (forfeitBtn) {
				forfeitBtn.disabled = true;
			}
			
			const amILeft = this.networkManager.getSide() === 'left';
			const didIWin = (winner === 'left' && amILeft) || (winner === 'right' && !amILeft);

			if (isTournament && tournamentId) {
				// ensure any generic pause/countdown overlay is removed so tournament overlay is visible
				this.uiManager.clearOverlayById('generic-overlay');
				const overlay = this.uiManager.handleTournamentGameOver(didIWin, this.gameStatusInfo.score!);
				document.body.appendChild(overlay);
				setTimeout(() => {
					sessionStorage.removeItem('gameWsURL');
					window.router.navigate(`/tournament/${tournamentId}`); // wip redirection to 3D tournament
					document.body.removeChild(overlay);
				}, 3000);
				return;
			}
			// ensure any generic pause/countdown overlay is removed so game-over overlay is visible
			this.uiManager.clearOverlayById('generic-overlay');
			const overlay = this.uiManager.showGameOver(didIWin, this.gameStatusInfo.score!);
			document.body.appendChild(overlay);
			overlay.addEventListener('click', (e) => {
				const target = e.target as HTMLElement;
				if (target.id === 'return-to-lobby' || target.closest('#return-to-lobby')) {
					e.stopPropagation();
					sessionStorage.removeItem('gameWsURL');
					document.body.removeChild(overlay);
					window.router?.navigateTo('/play');
				}
			});
		};
	}

	// start
	public start(): void {
		if (this.isRunning) return;
		this.isRunning = true;

		this.engine.runRenderLoop(() => {
			if (!this.isRunning) return;
			this.update();
			this.render();
		});
		this.sceneManager.playCameraIntro();
		this.networkManager.connect();
		this.setupForfeitButton();

		window.addEventListener('resize', this.handleResize);
	}
	
	private setupForfeitButton(): void {
		const forfeitBtn = document.getElementById('forfeit-btn');
		if (forfeitBtn) {
			forfeitBtn.addEventListener('click', this.handleForfeit);
		}
	}

	private update(): void {
		const input = this.inputSystem.getInput();
		
		this.networkManager.sendInput(input);

		// SPACE KEY
		if (this.inputSystem.isSkillKeyPressed()) {
			this.networkManager.useSkill();
		}

		// V KEY
		if (this.inputSystem.isCameraToggleKeyPressed()) {
			this.sceneManager.toggleCameraView(this.networkManager.getSide());
		}
	}

	private handleResize = (): void => {
		this.engine.resize();
	}

	private handleForfeit = (): void => {
		const confirmed = confirm('Are you sure you want to forfeit the game?');
		if (confirmed)
			this.networkManager.forfeit();
	}

	private render(): void {
		this.uiManager.render(
			this.gameStatusInfo,
			this.timeoutStatus,
			this.networkManager.getSide(),
			this.renderer.getCurrentState()
		);
		this.renderer.render();
	}

	public pause(): void {
		this.isRunning = false;
	}

	public resume(): void {
		if (this.isRunning) return;
		this.isRunning = true;
	}

	public dispose(): void {
		this.isRunning = false;
		this.engine.stopRenderLoop();
		this.uiManager.dispose();
		
		const forfeitBtn = document.getElementById('forfeit-btn');
		if (forfeitBtn) {
			forfeitBtn.removeEventListener('click', this.handleForfeit);
		}
		
		this.inputSystem.dispose();
		this.networkManager.disconnect();
		
		this.renderer.dispose();
		this.sceneManager.dispose();
		this.engine.dispose();
		
		window.removeEventListener('resize', this.handleResize);
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/utils/mathHelper.ts
// ==============================================
import { BALL_3D } from "../constants";

export function ballConverter2DXto3DX(x2d: number): number {
	return (x2d - 1920 / 2) * BALL_3D.SCALE_3D;
}

export function ballConverter2DYto3DZ (y2d: number): number {
	return -(y2d - 1080 / 2) * BALL_3D.SCALE_3D;
}

// could change later
export function powerUpConverter2DXto3DX(x2d: number): number {
	return (x2d - 1920 / 2) * BALL_3D.SCALE_3D;
}

export function powerUpConverter2DYto3DZ (y2d: number): number {
	return -(y2d - 1080 / 2) * BALL_3D.SCALE_3D;
}

// ==============================================
// üìÑ ./src/components/Game3d/utils/StateAdapter.ts
// ==============================================
import type { PublicState } from '../../../net/wsClient';
import type { Game3DState, BallState, PaddleState, GameStatusInfo } from '../types';

export class StateAdapter {
	public static toGame3DState(serverState: PublicState): Game3DState {
		return {
			paddleLeft: this.convertPaddle(serverState.leftPaddle),
			paddleRight: this.convertPaddle(serverState.rightPaddle),
			balls: this.convertBalls(serverState.balls),
			score: serverState.score,
			selectedSkills: serverState.selectedSkills,
			skillStates: serverState.skillStates,
			clock: serverState.clock,
			powerUpState: this.convertPowerUps(serverState)
		};
	}

	private static convertPaddle(paddle: { y: number; speed: number; intention: number }): PaddleState {
		return {
			y: paddle.y,
			speed: paddle.speed,
			intention: paddle.intention
		};
	}

	private static convertBalls(balls: { x: number; y: number; vx: number; vy: number; radius: number }[]): BallState[] {
		return balls.map((ball, index) => ({
			id: `ball-${index}`,
			x: ball.x,
			y: ball.y,
			z: 0,
			vx: ball.vx,
			vy: ball.vy,
			vz: 0,
			speed: Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy),
		}));
	}

	private static convertPowerUps(serverState: PublicState) {
		return {
			allPowerUps: serverState.powerUps,
			splitActive: serverState.splitActive,
			clock: serverState.clock,
			blackoutLeft: serverState.blackoutLeft,
			blackoutRight: serverState.blackoutRight,
			blackoutLeftIntensity: serverState.blackoutLeftIntensity,
			blackoutRightIntensity: serverState.blackoutRightIntensity,
			blackholeActive: serverState.blackholeActive,
			blackholeProgress: serverState.blackholeProgress,
			blackholeCenterX: serverState.blackholeCenterX,
			blackholeCenterY: serverState.blackholeCenterY
		}
	}

	public static getStatusInfo(serverState: PublicState): GameStatusInfo {
		return {
			isPaused: serverState.isPaused,
			isGameOver: serverState.isGameOver,
			winner: serverState.winner,
			countdownValue: serverState.countdownValue,
			score: serverState.score
		}
	}

	public static getExtendedInfo(serverState: PublicState) {
		return {
			isPaused: serverState.isPaused,
			isGameOver: serverState.isGameOver,
			winner: serverState.winner,
			countdownValue: serverState.countdownValue,
			powerUps: serverState.powerUps,
			splitActive: serverState.splitActive,
			blackoutLeft: serverState.blackoutLeft,
			blackoutRight: serverState.blackoutRight,
			blackoutLeftIntensity: serverState.blackoutLeftIntensity,
			blackoutRightIntensity: serverState.blackoutRightIntensity,
			blackholeActive: serverState.blackholeActive,
			blackholeProgress: serverState.blackholeProgress,
			blackholeCenterX: serverState.blackholeCenterX,
			blackholeCenterY: serverState.blackholeCenterY,
			selectedSkills: serverState.selectedSkills,
			skillStates: serverState.skillStates,
			clock: serverState.clock
		};
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/ui/UIManager.ts
// ==============================================
import type { GameStatusInfo, TimeoutStatus, Game3DState} from "../types";

export class UIManager {
	private previousCount: number = 0;

	constructor() {
	}

	public updatePlayerNames(side: 'left' | 'right' | 'spectator', playerNames?: { left?: string; right?: string }): void {
		const leftNameEl = document.getElementById('player-left-name');
		const rightNameEl = document.getElementById('player-right-name');
		
		if (leftNameEl && playerNames?.left) {
			leftNameEl.textContent = side === 'left' 
				? `${playerNames.left} üëà (You)` 
				: playerNames.left;
		}
		
		if (rightNameEl && playerNames?.right) {
			rightNameEl.textContent = side === 'right' 
				? `${playerNames.right} üëà (You)` 
				: playerNames.right;
		}
	}

	public showGameOver(didIWin: boolean, score: { left: number; right: number }): HTMLElement {

		const overlay = document.createElement('div');
		overlay.id = 'game-over-overlay';
		overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="bg-[#0C154D]/90 border-2 border-white/20 rounded-lg p-8 text-center max-w-md">
				<h2 class="text-4xl font-bold mb-4 ${didIWin ? 'text-green-400' : 'text-red-400'}">
					${didIWin ? 'üèÜ VICTOIRE !' : 'üíÄ D√âFAITE'}
				</h2>
				<p class="text-white/80 text-xl mb-6">
					Score: ${score.left} - ${score.right}
				</p>
				<button 
					id="return-to-lobby"
					class="px-6 py-3 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg text-white font-semibold transition-all cursor-pointer"
				>
					Retour au lobby
				</button>
			</div>
		`;
		return overlay;
	}

	public handleTournamentGameOver(didIWin: boolean, score: { left: number; right: number }): HTMLElement {
		// Handle tournament-specific game over logic here
		const overlay = document.createElement('div');
		overlay.id = 'tournament-game-over-overlay';
		overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="bg-[#0C154D]/90 border-2 border-white/20 rounded-lg p-8 text-center max-w-md">
				<h2 class="text-4xl font-bold mb-4 ${didIWin ? 'text-green-400' : 'text-red-400'}">
					${didIWin ? 'üèÜ VICTOIRE TOURNAMENT!' : 'üíÄ D√âFAITE TOURNAMENT!'}
				</h2>
				<p class="text-white/80 text-xl mb-6">
					Score: ${score.left} - ${score.right}
				</p>
				<button 
					id="return-to-lobby"
					class="px-6 py-3 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg text-white font-semibold transition-all cursor-pointer"
				>
					Retour au lobby
				</button>
			</div>
		`;
		return overlay;
	}

	private updateSkillOverlay(side: 'left' | 'right' | 'spectator', state: Game3DState | null): void {
		console.log('Updating skill overlay for side:', side);
		if (!state) return;
		console.log('Received game state');
		const isBlackout = side === 'left' ? state.powerUpState.blackoutLeft : state.powerUpState.blackoutRight;
		if (isBlackout) return;
		const skillState = side === 'left' ? state.skillStates.left : state.skillStates.right;
		const skillType = side === 'left' ? state.selectedSkills.left : state.skillStates.right;
		const cooldown = skillType === 'smash' ? 3 : 5;
		const progress = skillState.cooldownRemaining > 0
			? Math.max(0, Math.min(1, 1 - skillState.cooldownRemaining / cooldown))
			: 1;
		const currentLoader = document.querySelector('.skillLoader') as HTMLElement;
		if (currentLoader) {
			const step = Math.floor(progress * 6);
			console.log('Skill loader step:', step);
			let backgroundSize: string = '';
			const color = step == 6 ? '#00e676': '#ffcc00'
			switch (step) {
				case 0:
					backgroundSize = '0% 0%';
					break;
				case 1:
					backgroundSize = '0% 0%';
					break;
				case 2:
					backgroundSize = '20% 20%';
					break;
				case 3:
					backgroundSize = '40% 40%';
					break;
				case 4:
					backgroundSize = '60% 60%';
					break;
				case 5:
					backgroundSize = '80% 80%';
					break;
				case 6:
					backgroundSize = '100% 100%';
					break;
				default:
					backgroundSize = '100% 100%';
			}
			currentLoader.style.setProperty('--skill-gradient-color', color);
			currentLoader.style.backgroundSize = backgroundSize;
		}
	}
	
	public render(gameStatusInfo: GameStatusInfo, timeoutStatus: TimeoutStatus, side: 'left' | 'right' | 'spectator', state: Game3DState): void {
		if (gameStatusInfo.isGameOver) {
			this.clearOverlayById('generic-overlay');
			return;
		}

		this.updateSkillOverlay(side, state);

		let overlay: HTMLElement;
		let text: string = '';
		if ((gameStatusInfo.countdownValue ?? 0) > 0) {
			if (this.previousCount === gameStatusInfo.countdownValue) return;
			this.previousCount = gameStatusInfo.countdownValue ?? 0;
			text = `${gameStatusInfo.countdownValue}`;
		} else if (gameStatusInfo.isPaused) {
			const iAmLeft = side === 'left';
			const opponentDisconnected = iAmLeft ? timeoutStatus.rightActive : timeoutStatus.leftActive;
			const opponentRemainingMs = iAmLeft ? timeoutStatus.rightRemainingMs : timeoutStatus.leftRemainingMs;
			if (opponentDisconnected && opponentRemainingMs > 0) {
				const secondsRemaining = Math.ceil(opponentRemainingMs / 1000);
				text = `‚ö†Ô∏è <span style="color:#ff4d4f">Opponent disconnected.</span> <br> Forfeit in ${secondsRemaining}s`;
			} else {
				text = 'Game Paused';
			}
		}
		if (text.length > 0) {
			overlay = this.generateOverlay(text);
			if (!document.body.contains(overlay)) {
				document.body.appendChild(overlay);
			}
		} else {
			this.clearOverlayById('generic-overlay');
			this.previousCount = 0;
		}
	}

	private generateOverlay(text: string): HTMLElement {
		const existing = document.getElementById('generic-overlay');
		if (existing) {
			const genericText = existing.querySelector('.generic-text');
			if (genericText) {
				genericText.innerHTML = text;
			}
			return existing;
		}
		
		const overlay = document.createElement('div');
		overlay.id = 'generic-overlay';
		overlay.className = 'fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="p-8 text-center max-w-md">
				<h2 class="text-2xl font-bold text-white mb-4 generic-text">
					${text}
				</h2>
			</div>
		`;
		return overlay;
	}
	
	public clearOverlayById(overlayId: string): void {
		const existing = document.getElementById(overlayId);
		if (existing && existing.parentElement) {
			existing.parentElement.removeChild(existing);
		}
	}

	public clearAllOverlays(): void {
		this.clearOverlayById('generic-overlay');
		this.clearOverlayById('game-over-overlay');
		this.clearOverlayById('tournament-game-over-overlay');
	}

	public dispose(): void {
		this.clearAllOverlays();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/Game3d.ts
// ==============================================
import { Game3DEngine } from './core/game3DEngine';

interface Game3DConfig {
	wsURL?: string;
	roomId?: string;
}

export class Game3D {
	private canvas: HTMLCanvasElement;
	private gameEngine?: Game3DEngine;
	private config: Game3DConfig;

	constructor(element: HTMLElement) {
		console.log('[game3d] initializing...');

		//CANVAS
		const canvasElem = element.querySelector('#game3d-canvas') as HTMLCanvasElement;
		if (!canvasElem) throw new Error('[game3d] error: canvas not found');
		this.canvas = canvasElem;
		this.config = this.getConfiguration();
		this.initalizeEngine();
	}

	private initalizeEngine(): void {
		try {
			this.gameEngine = new Game3DEngine(this.canvas);
			this.gameEngine.start();
		} catch (error) {
			this.showError('Failed to initialize 3D game. Please refresh the page.');
		}

	}

	private getConfiguration(): Game3DConfig {
		const storedUrl = sessionStorage.getItem('gameWsURL');
		let findRoomId = null;
		if (!storedUrl) {
			const host = import.meta.env.VITE_HOST;
			const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
			findRoomId = window.location.pathname.split('/').pop();
			const fallbackUrl = host && endpoint && findRoomId ? `wss://${host}${endpoint}/${findRoomId}` : undefined;
			return {
				wsURL: fallbackUrl || undefined,
				roomId: findRoomId || undefined
			};
		}
		return {
			wsURL: storedUrl ? storedUrl : undefined,
			roomId: findRoomId || undefined
		};
	}
	
	//todo verify if its ok to use the innerHtml
	private showError(message: string): void {
		const overlay = document.createElement('div');
		overlay.className = 'fixed inset-0 bg-black/80 flex items-center justify-center z-50';
		overlay.innerHTML = `
			<div class="bg-red-900/50 border-2 border-red-500 rounded-lg p-8 text-center max-w-md">
				<h2 class="text-2xl font-bold text-red-400 mb-4">Error</h2>
				<p class="text-white mb-6">${message}</p>
				<button 
					onclick="window.location.reload()" 
					class="px-6 py-3 bg-red-600 hover:bg-red-700 rounded-lg text-white font-semibold"
				>
					Reload Page
				</button>
			</div>
		`;
		document.body.appendChild(overlay);
	}

	public cleanup(): void {
		console.log('[game3d] disposing...');
		if (this.gameEngine) {
			this.gameEngine.dispose();
			this.gameEngine = null as any;
		}
		sessionStorage.removeItem('gameWsURL');
	}
}


export function Game3dComponent(): string {
	
	return `
		<style>
			@keyframes gridMove {
				0% { transform: translateY(0); }
				100% { transform: translateY(50px); }
			}
			
			@keyframes neonPulse {
				0%, 100% { 
					text-shadow: 
						0 0 10px rgba(59, 130, 246, 0.8),
						0 0 20px rgba(59, 130, 246, 0.6),
						0 0 30px rgba(59, 130, 246, 0.4);
				}
				50% { 
					text-shadow: 
						0 0 20px rgba(59, 130, 246, 1),
						0 0 30px rgba(59, 130, 246, 0.8),
						0 0 40px rgba(59, 130, 246, 0.6);
				}
			}
			
			@keyframes scanline {
				0% { transform: translateY(-100%); }
				100% { transform: translateY(100vh); }
			}

			@keyframes glitch {
				0%, 100% { transform: translate(0); }
				20% { transform: translate(-2px, 2px); }
				40% { transform: translate(-2px, -2px); }
				60% { transform: translate(2px, 2px); }
				80% { transform: translate(2px, -2px); }
			}
			
			.pixel-font {
				font-family: 'Courier New', monospace;
				font-weight: bold;
				letter-spacing: 0.1em;
			}
			
			.neon-border {
				box-shadow: 
					0 0 10px rgba(59, 130, 246, 0.5),
					inset 0 0 10px rgba(59, 130, 246, 0.2);
				border: 3px solid rgba(59, 130, 246, 0.8);
			}

			.neon-border-green {
				box-shadow: 
					0 0 10px rgba(34, 197, 94, 0.5),
					inset 0 0 10px rgba(34, 197, 94, 0.2);
				border: 3px solid rgba(34, 197, 94, 0.8);
			}

			.neon-border-red {
				box-shadow: 
					0 0 10px rgba(239, 68, 68, 0.5),
					inset 0 0 10px rgba(239, 68, 68, 0.2);
				border: 3px solid rgba(239, 68, 68, 0.8);
			}

			.game-hud {
				background: rgba(4, 7, 26, 0.85);
				backdrop-filter: blur(10px);
			}

			.player-info {
				transition: all 0.3s ease;
			}

			.player-info:hover {
				transform: translateY(-2px);
			}

			#pong-canvas {
				box-shadow: 
					0 0 30px rgba(59, 130, 246, 0.4),
					0 0 60px rgba(59, 130, 246, 0.2),
					inset 0 0 30px rgba(59, 130, 246, 0.1);
				border: 3px solid rgba(59, 130, 246, 0.6);
			}

			.action-button {
				transition: all 0.2s ease;
				position: relative;
				overflow: hidden;
			}

			.action-button::before {
				content: '';
				position: absolute;
				top: 50%;
				left: 50%;
				width: 0;
				height: 0;
				border-radius: 50%;
				background: rgba(255, 255, 255, 0.1);
				transform: translate(-50%, -50%);
				transition: width 0.6s, height 0.6s;
			}

			.action-button:hover::before {
				width: 300px;
				height: 300px;
			}

			.action-button:active {
				transform: scale(0.95);
			}

			.forfeit-button:hover {
				box-shadow: 
					0 0 20px rgba(239, 68, 68, 0.6),
					inset 0 0 20px rgba(239, 68, 68, 0.3);
			}

			.status-indicator {
				animation: neonPulse 2s ease-in-out infinite;
			}

			.game-container {
				animation: fadeIn 0.8s ease-out;
			}

			@keyframes fadeIn {
				from { opacity: 0; transform: scale(0.95); }
				to { opacity: 1; transform: scale(1); }
			}

			.corner-decoration {
				position: absolute;
				width: 20px;
				height: 20px;
			}

			.corner-decoration-blue {
				border: 2px solid rgba(59, 130, 246, 0.5);
			}

			.corner-decoration-green {
				border: 2px solid rgba(34, 197, 94, 0.5);
			}

			.corner-decoration-red {
				border: 2px solid rgba(239, 68, 68, 0.5);
			}

			.corner-tl { top: -2px; left: -2px; border-right: none; border-bottom: none; }
			.corner-tr { top: -2px; right: -2px; border-left: none; border-bottom: none; }
			.corner-bl { bottom: -2px; left: -2px; border-right: none; border-top: none; }
			.corner-br { bottom: -2px; right: -2px; border-left: none; border-top: none; }

			.stat-good { color: #4ade80; }
			.stat-medium { color: #fbbf24; }
			.stat-bad { color: #ef4444; }
		</style>
		<div class="fixed inset-0 w-full h-full" data-component="game3d">

			<!-- Header HUD -->
			<div class="game-hud border-b border-white/10">
				<div class="container mx-auto px-4 py-4">
					<div class="flex items-center justify-between gap-4">
						<!-- Left: Back button -->
						<button 
							onclick="history.back()" 
							class="action-button pixel-font px-4 py-2 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all text-sm"
							id="back-button"
						>
							<span class="relative z-10">‚Üê EXIT</span>
						</button>

							<!-- Player 1 Name -->
						<div id="player-left-name" class="text-xl font-bold text-white drop-shadow-lg mx-4">Player 1</div>

						<!-- Center: Status indicator -->
						<div class="flex items-center gap-3">
							<div id="connection-indicator" class="status-indicator w-3 h-3 bg-green-400 rounded-full"></div>
							<span class="pixel-font text-sm text-blue-300">
								LIVE MATCH
							</span>
						</div>

							<!-- Player 2 Name -->
						<div id="player-right-name" class="text-xl font-bold text-white drop-shadow-lg mx-4">Player 2</div>

						<!-- Right: Forfeit button (si pas mode local) -->
						<button 
							id="forfeit-btn"
							class="action-button forfeit-button pixel-font px-4 py-2 neon-border-red bg-red-500/10 text-red-400 hover:bg-red-500/20 transition-all text-sm relative z-10"
						>
							<span class="relative z-10">üè≥Ô∏è SURRENDER</span>
						</button>
					</div>
				</div>
			</div>

			<canvas id="game3d-canvas" class="w-full h-full block"></canvas>
			
				<!-- skill indicator -->
			<div id="game3d-ui-skill">
				<div id="game3d-skill-container" class="fixed left-1/2 bottom-6 transform -translate-x-1/2 z-50 pointer-events-none">
					<div class="flex flex-col items-center">
						<div id="skill-wrapper" class="skillLoader" aria-hidden="true"></div>
						<div id="skill-cooldown" class="mt-2 text-white/90 text-sm select-none">Skill cooldown</div>
					</div>
				</div>
			</div>
			<style id="game3d-ui-styles">
				:root {
					--skill-gradient-color: #00e676;
				}

				.skillLoader {
					width: 120px;
					height: 60px;
					border-radius: 200px 200px 0 0;
					-webkit-mask: repeating-radial-gradient(farthest-side at bottom ,#0000 0,#000 1px 12%,#0000 calc(12% + 1px) 20%);
					background: radial-gradient(farthest-side at bottom, var(--skill-gradient-color) 0 95%,#0000 0) bottom/0% 0% no-repeat #ddd;
					background-size: 100% 100%;
				}
			</style>

			<!-- Camera View Indicator -->
			<div class="absolute bottom-4 right-4 px-3 py-2 bg-black/50 text-white text-sm rounded pointer-events-none">
				Press <span class="font-bold text-cyan-400">V</span> to toggle camera view
			</div>
			<!-- Global Css -->
			<style>
				@keyframes fadeIn {
				from {
					opacity: 0;
					transform: scale(0.9);
				}
				to {
					opacity: 1;
					transform: scale(1);
				}
				}
				.animate-fade-in {
					animation: fadeIn 0.3s ease-out;
				}
			</style>
		</div>
	`;
}

// ==============================================
// üìÑ ./src/components/Game3d/rendering/materialManager.ts
// ==============================================
import type { Scene, StandardMaterial } from "@babylonjs/core";

export class MaterialManager {
	private scene: Scene;
	private materials: Map<string, StandardMaterial> = new Map();

	constructor(scene: Scene) {
		this.scene = scene;
	}

	public dispose(): void {
		this.materials.forEach((material) => {
			material.dispose();
		});
		this.materials.clear();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/types.ts
// ==============================================
import type { Mesh, Vector3 } from '@babylonjs/core';

export interface Game3DState {
	paddleLeft: PaddleState;
	paddleRight: PaddleState;
	balls: BallState[];
	score: {
		left: number;
		right: number;
	};
	selectedSkills: {
		left: 'smash' | 'dash';
		right: 'smash' | 'dash';
	};
	skillStates: {
		left: {cooldownRemaining: number; lastActivationAt: number};
		right: {cooldownRemaining: number; lastActivationAt: number};
	};
	clock: number;
	powerUpState: PowerUpsState;
}

export interface IEntity {
	id: string;
	mesh?: Mesh;
	position: Vector3;
	update(deltaTime: number): void;
	dispose(): void;
}

export interface IRenderable {
	render(): void;
	setVisibility(visible: boolean): void;
}

export interface PaddleState {
	y: number;
	z?: number;
	speed?: number;
	velocity?: number;
	intention?: number;
}

export interface BallState {
	id: string;
	x: number;
	y: number;
	z: number;
	vx: number;
	vy: number;
	vz: number;
	speed: number;
}

export interface PowerUpsState {
	allPowerUps: {x: number, y: number, radius: number, type: string}[];
	splitActive: boolean;
	clock: number;
	blackoutLeft: boolean;
	blackoutRight: boolean;
	blackoutLeftIntensity: number;
	blackoutRightIntensity: number;
	blackholeActive: boolean;
	blackholeProgress: number;
	blackholeCenterX: number;
	blackholeCenterY: number;
}

export interface ISystem {
	initialize(): void;
	update(): void;
	dispose(): void;
}

export interface InputState {
	up: boolean;
	down: boolean;
	left: boolean;
	right: boolean;
}

export interface GameStatusInfo {
	isPaused?: boolean;
	countdownValue?: number;
	isGameOver?: boolean;
	winner?: '' | 'left' | 'right';
	score?: {left: number; right: number};
}


export interface TimeoutStatus {
	leftActive: boolean;
	leftRemainingMs: number;
	rightActive: boolean;
	rightRemainingMs: number;
}

// ==============================================
// üìÑ ./src/components/Game3d/entities/Ball.ts
// ==============================================
import type { Scene } from "@babylonjs/core/scene";
import { Entity } from "./Entity";
import { Color3, MeshBuilder, StandardMaterial } from "@babylonjs/core";
import type { BallState } from "../types";
import { BALL_3D } from "../constants";
import { ballConverter2DXto3DX, ballConverter2DYto3DZ } from "../utils/mathHelper";

export class Ball extends Entity {
	constructor(scene: Scene, id: string) {
		super(scene, id);
		this.createMesh();
	}

	private createMesh(): void {
		this.mesh = MeshBuilder.CreateSphere(this.id, { diameter: BALL_3D.DIAMETER * BALL_3D.SCALE_3D }, this.scene);
		const material = new StandardMaterial(`ball-mat-${this.id}`, this.scene);
		material.diffuseColor = Color3.FromHexString('#FFFFFF');
		this.mesh.material = material;
	}

	public updateFromState(state: BallState): void {
		if (!this.mesh) return;
		const x3d = ballConverter2DXto3DX(state.x);
		const z3d = ballConverter2DYto3DZ(state.y);

		this.mesh.position.x = x3d;
		this.mesh.position.y = (BALL_3D.START_POSY * 2) * BALL_3D.SCALE_3D;
		this.mesh.position.z = z3d;
	}

	public update(): void {
		if (!this.mesh) return;
	}

	public dispose(): void {
		super.dispose();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/entities/Entity.ts
// ==============================================
import { Scene, Mesh, Vector3 } from '@babylonjs/core';
import type { IEntity, IRenderable } from '../types';

// base class for 3D entities
export abstract class Entity implements IEntity, IRenderable {
	public id: string;
	public mesh?: Mesh
	public position: Vector3;
	protected scene: Scene;
	protected isDisposed: boolean = false;
	
	constructor(scene: Scene, id: string) {
		this.scene = scene;
		this.id = id;
		this.position = new Vector3(0, 0, 0);
	}

	abstract update(): void;

	public setPosition(x: number, y: number, z: number): void {
		this.position.set(x, y, z);
		if (this.mesh) {
			this.mesh.position.copyFrom(this.position);
			// or this.mesh.position = this.position; //wip
		}
	}

	public setVisibility(visible: boolean): void {
		if (this.mesh) {
			this.mesh.isVisible = visible;
		}
	}

	public render(): void {}

	public isEntityDisposed(): boolean {
		return this.isDisposed;
	}

	public dispose(): void {
		if (this.isDisposed) return;
		this.isDisposed = true;
		if (this.mesh) {
			if (this.mesh.material) {
				this.mesh.material.dispose();
			}
			this.mesh.dispose();
			this.mesh = undefined;
		}
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/entities/PowerUpEffects.ts
// ==============================================
import { Scene, Mesh, MeshBuilder, StandardMaterial, Color3, ParticleSystem, Quaternion, Vector3, Color4, Animation} from "@babylonjs/core";

export class PowerUpEffects {
	private scene: Scene;

	constructor(scene: Scene) {
		this.scene = scene;
	}

	public activateBlackoutEffect(side: 'left' | 'right'): void {
		this.scene.meshes.forEach(mesh => {
			if (mesh.name.startsWith('ball')) return;
			if (side === 'right' && mesh.name === 'paddle-right') return;
			if (side === 'left' && mesh.name === 'paddle-left') return;
			if (mesh.name === 'centerCircle') return;
			if (mesh.name.startsWith('line')) return;
			if (!mesh.isDisposed()) {
				mesh.isVisible = false;
			}
		});
	}

	public restoreVisibilityAfterBlackout(): void {
		this.scene.meshes.forEach(mesh => {
			if (!mesh.isDisposed()) {
				mesh.isVisible = true;
			}
		});
	}

	public triggerBlackholeEffect(): void {
		const inner = this.scene.getMeshByName('centerCircleInner') as Mesh;
		const border = this.scene.getMeshByName('centerCircle') as Mesh;
		const helix = this.scene.getMeshByName('blacholeHelix') as Mesh;

		if (inner.material && inner.material instanceof StandardMaterial) {
			const alphaAnim = new Animation("blackhole-inner-alpha-in", "alpha", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
			alphaAnim.setKeys([
				{ frame: 0, value: inner.material.alpha },
				{ frame: 30, value: 1 }
			]);
			inner.material.animations = [alphaAnim];
			this.scene.beginAnimation(inner.material, 0, 30, false);
		}

		if (helix.material && helix.material instanceof StandardMaterial) {
			const alphaAnim = new Animation("blackhole-helix-alpha-in", "alpha", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
			alphaAnim.setKeys([
				{ frame: 0, value: helix.material.alpha },
				{ frame: 30, value: 0.5 }
			]);
			helix.material.animations = [alphaAnim];
			this.scene.beginAnimation(helix.material, 0, 30, false);
		}

		if (border.material && border.material instanceof StandardMaterial) {
			const colorAnim = new Animation("blackhole-core-to-black", "diffuseColor", 30, Animation.ANIMATIONTYPE_COLOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
			colorAnim.setKeys([
				{ frame: 0, value: (border.material as StandardMaterial).diffuseColor },
				{ frame: 30, value: Color3.Black() }
			]);
			border.material.animations = [colorAnim];
			this.scene.beginAnimation(border.material, 0, 30, false);
		}

		const scaleAnim = new Animation("blackhole-scale-up", "scaling", 30, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
		scaleAnim.setKeys([
			{ frame: 0, value: new Vector3(1, 1, 1) },
			{ frame: 30, value: new Vector3(5, 5, 5) }
		]);
		border.animations = [scaleAnim];
		this.scene.beginAnimation(border, 0, 30, false);
		inner.animations = [scaleAnim.clone()];
		this.scene.beginAnimation(inner, 0, 30, false);
	}

	public resetBlackholeEffect(): void {

		const inner = this.scene.getMeshByName('centerCircleInner') as Mesh;
		const border = this.scene.getMeshByName('centerCircle') as Mesh;
		const helix = this.scene.getMeshByName('blacholeHelix') as Mesh;

		const scaleAnim = new Animation("blackhole-scale-down", "scaling", 30, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
		scaleAnim.setKeys([
			{ frame: 0, value: border.scaling.clone() },
			{ frame: 30, value: new Vector3(1, 1, 1) }
		]);
		border.animations = [scaleAnim];
		this.scene.beginAnimation(border, 0, 30, false);
		inner.animations = [scaleAnim.clone()];
		this.scene.beginAnimation(inner, 0, 30, false);

		if (inner.material && inner.material instanceof StandardMaterial) {
			const alphaAnim = new Animation("blackhole-inner-alpha-out", "alpha", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
			alphaAnim.setKeys([
				{ frame: 0, value: inner.material.alpha },
				{ frame: 30, value: 0 }
			]);
			inner.material.animations = [alphaAnim];
			this.scene.beginAnimation(inner.material, 0, 30, false);
		}

		if (helix.material && helix.material instanceof StandardMaterial) {
			const alphaAnim = new Animation("blackhole-helix-alpha-out", "alpha", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);
			alphaAnim.setKeys([
				{ frame: 0, value: helix.material.alpha },
				{ frame: 30, value: 0 }
			]);
			helix.material.animations = [alphaAnim];
			this.scene.beginAnimation(helix.material, 0, 30, false);
		}

		if (border.material && border.material instanceof StandardMaterial) {
			const colorAnim = new Animation("blackhole-border-to-white", "diffuseColor", 30, Animation.ANIMATIONTYPE_COLOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);
			colorAnim.setKeys([
				{ frame: 0, value: (border.material as StandardMaterial).diffuseColor },
				{ frame: 30, value: Color3.FromHexString('#FFFFFF') }
			]);
			border.material.animations = [colorAnim];
			this.scene.beginAnimation(border.material, 0, 30, false);
		}
	}

	private updateBlackholeEffect(): void {
		const helix = this.scene.getMeshByName('blacholeHelix') as Mesh | null;
		if (helix) helix.rotate(Vector3.Up(), 0.1);
	}

	public update(): void {
		this.updateBlackholeEffect();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/entities/Scoreboard.ts
// ==============================================
import { Entity } from "./Entity";
import type { Scene } from "@babylonjs/core/scene";
import { Color3, DynamicTexture, Mesh, MeshBuilder, StandardMaterial, Vector3 } from "@babylonjs/core";

export class Scoreboard extends Entity {
	private panelTextures: DynamicTexture[] = [];
	private panels: Mesh[] = [];
	private parentMesh!: Mesh;

	constructor(scene: Scene, id: string = 'scoreboard') {
		super(scene, id);
		this.createMesh();
	}

	private createMesh(): void {
		const centerPoint = new Vector3(0, 7, 0);
		this.parentMesh = MeshBuilder.CreateBox('scoreBoardParent', { size: 0.1 }, this.scene);
		this.parentMesh.position = centerPoint;
		this.parentMesh.isVisible = false;
		this.mesh = this.parentMesh;

		this.createPanels();
		this.createCylinder();
	}

	private createPanels(): void {
		const panelWidth = 4;
		const panelHeight = panelWidth * (9 / 16);
		const panelDepth = 0.03;
		const distanceFromCenter = 3;
		const panelInclinement = -0.3;

		const panelConfigs = [
			{ name: 'scorePanel1', position: new Vector3(0, 0, distanceFromCenter), rotation: 0 },
			{ name: 'scorePanel2', position: new Vector3(distanceFromCenter, 0, 0), rotation: Math.PI / 2 },
			{ name: 'scorePanel3', position: new Vector3(0, 0, -distanceFromCenter), rotation: Math.PI },
			{ name: 'scorePanel4', position: new Vector3(-distanceFromCenter, 0, 0), rotation: -Math.PI / 2 }
		];

		for (const config of panelConfigs) {
			const panel = this.createPanel(config, panelWidth, panelHeight, panelDepth, panelInclinement);
			this.panels.push(panel);
		}
	}

	private createPanel(
		config: { name: string; position: Vector3; rotation: number },
		width: number,
		height: number,
		depth: number,
		inclinement: number
	): Mesh {
		const panel = MeshBuilder.CreateBox(config.name, { width, height, depth }, this.scene);

		const holographicMaterial = new StandardMaterial(`${config.name}_holographicMat`, this.scene);
		const panelTexture = this.panelTextures.length === 0 
			? this.createScoreTexture(0, 0) 
			: this.panelTextures[0];

		// TEXTURE PROPERTIES
		panelTexture.vScale = 1;
		panelTexture.uScale = 1;

		// MAT
		holographicMaterial.diffuseTexture = panelTexture;
		holographicMaterial.diffuseColor = Color3.FromHexString('#0fb3ff');
		holographicMaterial.emissiveColor = Color3.FromHexString('#00d4ff');
		holographicMaterial.specularColor = Color3.White();
		holographicMaterial.alpha = 0.6;
		holographicMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
		holographicMaterial.backFaceCulling = true;

		// APPLY
		panel.material = holographicMaterial;
		panel.position = config.position;
		panel.rotation.y = config.rotation + Math.PI;
		panel.rotation.x = inclinement;
		panel.parent = this.parentMesh;

		// OPTI (ONE TEXTURE FOR ALL PANELS)
		if (this.panelTextures.length === 0) {
			this.panelTextures.push(panelTexture);
		}

		this.createPanelBorders(panel, width, height, depth);

		return panel;
	}

	private createPanelBorders(panel: Mesh, panelWidth: number, panelHeight: number, panelDepth: number): void {
		// MAT
		const borderMaterial = new StandardMaterial(`${panel.name}_borderMat`, this.scene);
		borderMaterial.diffuseColor = Color3.FromHexString('#192e38');
		borderMaterial.emissiveColor = new Color3(0.05, 0.05, 0.05);

		// PROPERTIES
		const borderThickness = 0.08;
		const borderDepth = panelDepth + 0.01;

		// CONFIG
		const borders = [
			{ name: 'Top', width: panelWidth + borderThickness * 2, height: borderThickness, x: 0, y: panelHeight / 2 + borderThickness / 2 },
			{ name: 'Bottom', width: panelWidth + borderThickness * 2, height: borderThickness, x: 0, y: -panelHeight / 2 - borderThickness / 2 },
			{ name: 'Left', width: borderThickness, height: panelHeight, x: -panelWidth / 2 - borderThickness / 2, y: 0 },
			{ name: 'Right', width: borderThickness, height: panelHeight, x: panelWidth / 2 + borderThickness / 2, y: 0 }
		];

		for (const border of borders) {
			const borderMesh = MeshBuilder.CreateBox(
				`${panel.name}_border${border.name}`,
				{ width: border.width, height: border.height, depth: borderDepth },
				this.scene
			);
			borderMesh.material = borderMaterial;
			borderMesh.position = new Vector3(border.x, border.y, 0);
			borderMesh.parent = panel;
		}
	}

	private createCylinder(): void {
		const cylinderMidMaterial = new StandardMaterial('cylinderMidMat', this.scene);
		cylinderMidMaterial.diffuseColor = Color3.FromHexString('#0fb3ff');
		cylinderMidMaterial.specularColor = Color3.White();
		cylinderMidMaterial.alpha = 0.4;
		cylinderMidMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
		cylinderMidMaterial.backFaceCulling = false;

		const cylinderMidInnerMaterial = new StandardMaterial('cylinderMidInnerMat', this.scene);
		cylinderMidInnerMaterial.diffuseColor = Color3.Black();
		cylinderMidInnerMaterial.specularColor = new Color3(0.1, 0.1, 0.1);

		const cylinderTopBorderMaterial = new StandardMaterial('cylinderTopBorderMat', this.scene);
		const cylinderBottomBorderMaterial = new StandardMaterial('cylinderBottomBorderMat', this.scene);
		cylinderTopBorderMaterial.diffuseColor = Color3.FromHexString('#8fdbff');
		cylinderTopBorderMaterial.emissiveColor = Color3.FromHexString('#0fb3ff');
		cylinderTopBorderMaterial.specularColor = Color3.White();
		cylinderBottomBorderMaterial.diffuseColor = Color3.FromHexString('#8fdbff');
		cylinderBottomBorderMaterial.emissiveColor = Color3.FromHexString('#0fb3ff');
		cylinderBottomBorderMaterial.specularColor = Color3.White();

		const cylinderMid = MeshBuilder.CreateCylinder('cylinderMid', { diameterTop: 3, diameterBottom: 2.5, height: 0.5, tessellation: 32 }, this.scene);
		const cylinderMidInner = MeshBuilder.CreateCylinder('cylinderMidInner', { diameterTop: 2.5, diameterBottom: 2., height: 0.5, tessellation: 32 }, this.scene);
		const cylinderTopBorder = MeshBuilder.CreateCylinder('cylinderTopBorder', { diameter: 3.1, height: 0.04, tessellation: 32 }, this.scene);
		const cylinderBottomBorder = MeshBuilder.CreateCylinder('cylinderBottomBorder', { diameter: 2.6, height: 0.04, tessellation: 32 }, this.scene);

		cylinderMid.material = cylinderMidMaterial;
		cylinderMidInner.material = cylinderMidInnerMaterial;
		cylinderTopBorder.material = cylinderTopBorderMaterial;
		cylinderBottomBorder.material = cylinderBottomBorderMaterial;

		cylinderTopBorder.position = new Vector3(0, 0.25, 0);
		cylinderBottomBorder.position = new Vector3(0, -0.25, 0);

		cylinderMid.parent = this.parentMesh;
		cylinderMidInner.parent = this.parentMesh;
		cylinderTopBorder.parent = this.parentMesh;
		cylinderBottomBorder.parent = this.parentMesh;
	}

	private createScoreTexture(scoreLeft: number = 0, scoreRight: number = 0): DynamicTexture {
		const texture = new DynamicTexture('scoreTexture', { width: 1024, height: 1024 }, this.scene, false);
		this.updateScoreTexture(texture, scoreLeft, scoreRight);
		return texture;
	}

	private updateScoreTexture(texture: DynamicTexture, scoreLeft: number, scoreRight: number): void {
		const ctx = texture.getContext() as CanvasRenderingContext2D;

		ctx.fillStyle = '#0a4d66';
		ctx.fillRect(0, 0, 1024, 1024);

		ctx.fillStyle = '#083d52';
		for (let i = 0; i < 1024; i += 8) {
			ctx.fillRect(0, i, 1024, 4);
		}

		const scoreText = `${scoreLeft} - ${scoreRight}`;
		ctx.font = 'bold 300px Arial';
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';

		ctx.strokeStyle = '#000000';
		ctx.lineWidth = 16;
		ctx.strokeText(scoreText, 512, 512);

		ctx.shadowColor = '#00ffff';
		ctx.shadowBlur = 40;
		ctx.fillStyle = '#00d4ff';
		ctx.fillText(scoreText, 512, 512);

		ctx.shadowBlur = 0;
		ctx.fillStyle = '#FFFFFF';
		ctx.fillText(scoreText, 512, 512);

		texture.update();
	}

	public updateScore(scoreLeft: number, scoreRight: number): void {
		if (this.panelTextures.length > 0) {
			this.updateScoreTexture(this.panelTextures[0], scoreLeft, scoreRight);
		}
	}

	public update(): void {
	}

	public dispose(): void {
		for (const texture of this.panelTextures) {
			texture.dispose();
		}
		this.panelTextures = [];
		this.panels = [];
		this.parentMesh.dispose();
		super.dispose();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/entities/CelebrationSphere.ts
// ==============================================
import { Entity } from "./Entity";
import { MeshBuilder, StandardMaterial, Color4, Scene, Mesh, ParticleSystem, DynamicTexture } from "@babylonjs/core";

export class CelebrationSphere extends Entity {
	private particleSystem?: ParticleSystem;

	constructor(scene: Scene, id: string = 'celebration-sphere') {
		super(scene, id);
		this.createMesh();
		this.createParticleSystem();
	}

	private createMesh(): void {
		const sphereCelebration = MeshBuilder.CreateSphere('sphereCelebration', { diameter: 149, sideOrientation: Mesh.BACKSIDE }, this.scene);
		const sphereCelebrationMaterial = new StandardMaterial('sphereCelebrationMat', this.scene);
		sphereCelebrationMaterial.alpha = 0;
		sphereCelebrationMaterial.transparencyMode = StandardMaterial.MATERIAL_ALPHABLEND;
		sphereCelebration.material = sphereCelebrationMaterial;
		this.mesh = sphereCelebration;
	}

	private createParticleSystem(): void {
		if (!this.mesh) return;
		const particleSystem = new ParticleSystem('celebrationParticles', 3000, this.scene);
		const particleTexture = new DynamicTexture('particleTexture', 64, this.scene, false);
		const ctx = particleTexture.getContext() as CanvasRenderingContext2D;
		const centerX = 32;
		const centerY = 32;
		const radius = 30;
		const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
		gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
		gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)');
		gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.5)');
		gradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.1)');
		gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
		ctx.fillStyle = gradient;
		ctx.fillRect(0, 0, 64, 64);
		particleTexture.update();
		particleSystem.particleTexture = particleTexture;

		particleSystem.emitter = this.mesh;
		particleSystem.createSphereEmitter(74.5, 0); // Radius 74.5 (149/2), radiusRange 0 = surface only
		particleSystem.color1 = new Color4(2, 2, 2, 1);
		particleSystem.color2 = new Color4(2, 2, 2, 1);
		particleSystem.colorDead = new Color4(1, 1, 1, 0);
		particleSystem.minSize = 0.3;
		particleSystem.maxSize = 0.8;
		particleSystem.minLifeTime = 0.2;
		particleSystem.maxLifeTime = 0.4;
		particleSystem.emitRate = 1500;
		particleSystem.minEmitPower = 0;
		particleSystem.maxEmitPower = 0;
		particleSystem.updateSpeed = 0.02;
		particleSystem.blendMode = ParticleSystem.BLENDMODE_ADD;
		// particleSystem.stop();
		this.particleSystem = particleSystem;
	}
	
	public update(): void {
		if (!this.mesh) return;
		const material = this.mesh.material as StandardMaterial;
		material.alpha = 0;
		this.particleSystem?.start();
		setTimeout(() => {
			this.particleSystem?.stop();
		}, 2000);
	}

	public dispose(): void {
		super.dispose();
		this.particleSystem?.dispose();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/entities/powerUp.ts
// ==============================================
import { Color3, MeshBuilder, Scene, StandardMaterial } from "@babylonjs/core";
import { Entity } from "./Entity";
import { powerUpConverter2DXto3DX, powerUpConverter2DYto3DZ } from "../utils/mathHelper";

export class PowerUp extends Entity {
	private type: 'blackout' | 'split' | 'blackhole';
	private state: {x: number; y: number; radius: number; type: string};

	constructor(scene: Scene, id: string, state: {x: number; y: number; radius: number; type: string}) {
		super(scene, id);
		this.state = state;
		this.type = state.type as 'blackout' | 'split' | 'blackhole';
		this.createMesh();
	}

	private createMesh(): void {
		this.mesh = MeshBuilder.CreateCylinder(this.id, { 
			diameter: this.state.radius * 2 * 0.01, 
			height: 1, 
			tessellation: 32
		}, this.scene);
		
		const material = new StandardMaterial(`powerup-mat-${this.id}`, this.scene);
		material.needDepthPrePass = true;
		material.backFaceCulling = false;
		material.alpha = 0.7;

		switch (this.type) {
			case 'split':
				material.diffuseColor = Color3.FromHexString('#FFD700');
				material.emissiveColor = Color3.FromHexString('#FFD700').scale(0.6);
				material.specularColor = Color3.FromHexString('#FFEA00');
				break;
			case 'blackout':
				material.diffuseColor = Color3.FromHexString('#9B59B6');
				material.emissiveColor = Color3.FromHexString('#9B59B6').scale(0.7);
				material.specularColor = Color3.FromHexString('#E74FF0');
				break;
			case 'blackhole':
				material.diffuseColor = Color3.FromHexString('#000000');
				material.emissiveColor = Color3.FromHexString('#111111').scale(0.6);
				material.specularColor = Color3.FromHexString('#333333');
				break;
		}
		this.mesh.material = material;
	}

	public updateState(state: {x: number; y: number; radius: number; type: string}): void {
		this.state = state;
	}

	public update(): void {
		if (!this.mesh) return;
		
		const time = Date.now() * 0.001;
		
		const floatOffset = Math.sin(time * 3) * 0.15;
		this.mesh.position.x = powerUpConverter2DXto3DX(this.state.x);
		this.mesh.position.z = powerUpConverter2DYto3DZ(this.state.y);
		this.mesh.position.y = 0.9 + floatOffset;
		
		this.mesh.rotation.y += 0.015;
		
		const pulse = 1 + Math.sin(time * 4) * 0.05;
		this.mesh.scaling.set(pulse, 1, pulse);
	}

	public dispose(): void {
		super.dispose();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/entities/Paddle.ts
// ==============================================
import { MeshBuilder, Vector3, StandardMaterial, Color3, Scene } from '@babylonjs/core';
import { PADDLE_3D, MATERIALS } from '../constants';
import { Entity } from './Entity';
import type { PaddleState } from '../types';

export class Paddle extends Entity {
	private side: 'left' | 'right'; 

	constructor(scene: Scene, side: 'left' | 'right') {
		super(scene, `paddle-${side}`);
		this.side = side;
		this.createMesh();
	}
	
	private createMesh(): void {
		this.mesh = MeshBuilder.CreateBox(
			this.id, {
				width: PADDLE_3D.X * PADDLE_3D.SCALE_3D,
				height: PADDLE_3D.Y * PADDLE_3D.SCALE_3D,
				depth: PADDLE_3D.Z * PADDLE_3D.SCALE_3D
			}, this.scene);

		const xPos = this.side === 'left' ? (-PADDLE_3D.START_POSX - PADDLE_3D.MARGIN) * PADDLE_3D.SCALE_3D  : (PADDLE_3D.START_POSX + PADDLE_3D.MARGIN) * PADDLE_3D.SCALE_3D 
		this.mesh.position = new Vector3(xPos, PADDLE_3D.START_POSY * PADDLE_3D.SCALE_3D, PADDLE_3D.START_POSZ * PADDLE_3D.SCALE_3D);

		const material = new StandardMaterial(`paddle-mat-${this.side}`, this.scene);
		material.diffuseColor = Color3.FromHexString(MATERIALS.PADDLE_COLOR);
		this.mesh.material = material;
	}

	public updateFromState(state: PaddleState, smashOffsetX?: number): void {
		if (!this.mesh) return;
		
		this.mesh.position.z = -(state.y - 540) * 0.01;

		// SMASH OFFSET de l'enfer
		const xPos = this.side === 'left' ? (-PADDLE_3D.START_POSX - PADDLE_3D.MARGIN) * PADDLE_3D.SCALE_3D  : (PADDLE_3D.START_POSX + PADDLE_3D.MARGIN) * PADDLE_3D.SCALE_3D 
		this.mesh.position.x = xPos + (smashOffsetX || 0);
	}

	public update(): void {
		if (!this.mesh) return;
	}

	public static getPaddleIntention(keys: { [key: string]: boolean }, side: 'left' | 'right'): number {
		if (side === 'left') {
			if (keys['w'] || keys['a']) return 1;
			if (keys['s'] || keys['d']) return -1;
		} else {
			if (keys['w'] || keys['d']) return 1;
			if (keys['s'] || keys['a']) return -1;
		}
		return 0;
	}

	public dispose(): void {
		super.dispose();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/systems/InputSystem.ts
// ==============================================
import type { ISystem, InputState } from '../types';

export class InputSystem implements ISystem {
	private keys: Map<string, boolean> = new Map();
	private canvas: HTMLCanvasElement;
	private vKeyWasPressed: boolean = false;

	constructor(canvas: HTMLCanvasElement) {
		this.canvas = canvas;
	}

	public initialize(): void {
		window.addEventListener('keydown', this.onKeyDown);
		window.addEventListener('keyup', this.onKeyUp);
		
		this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
	}
	
	private onKeyDown = (event: KeyboardEvent): void => {
		this.keys.set(event.key.toLowerCase(), true);
	}

	private onKeyUp = (event: KeyboardEvent): void => {
		this.keys.set(event.key.toLowerCase(), false);
	}

	public isKeyPressed(key: string): boolean {
		return this.keys.get(key.toLowerCase()) || false;
	}

	public getInput(): InputState {
		return {
			up: this.isKeyPressed('w'),
			down: this.isKeyPressed('s'),
			left: this.isKeyPressed('a'),
			right: this.isKeyPressed('d'),
		};
	}

	public isSkillKeyPressed(): boolean {
		return this.isKeyPressed(' ');
	}

	public isCameraToggleKeyPressed(): boolean {
		const isVPressed = this.isKeyPressed('v');
		
		if (isVPressed && !this.vKeyWasPressed) {
			this.vKeyWasPressed = true;
			return true;
		}
		
		if (!isVPressed) {
			this.vKeyWasPressed = false;
		}
		
		return false;
	}

	public update(): void {
	}

	public dispose(): void {
		window.removeEventListener('keydown', this.onKeyDown);
		window.removeEventListener('keyup', this.onKeyUp);
		this.keys.clear();
	}
}

// ==============================================
// üìÑ ./src/components/Game3d/constants.ts
// ==============================================
/**
 * Game3d Constants
 * 
 * These constants define the dimensions and properties of the 3D game world
 */

// Stadium dimensions (should match your stadium.gltf model)
export const STADIUM_WIDTH = 1920;
export const STADIUM_HEIGHT = 1080;

// Paddle dimensions
export const PADDLE_DEPTH = 100; // Z-axis size
export const PADDLE_WIDTH = 15;  // X-axis thickness

// Ball properties
export const BALL_DIAMETER = 30;
export const BALL_Y_POSITION = 15; // Height above ground

// Camera settings
export const CAMERA_INTRO_DURATION = 180; // frames at 60fps = 3 seconds
export const CAMERA_DEFAULT_ALPHA = Math.PI / 2;
export const CAMERA_DEFAULT_BETA = Math.PI / 3;
export const CAMERA_DEFAULT_RADIUS = 30;

// Positions
export const PADDLE_DISTANCE_FROM_CENTER = STADIUM_WIDTH / 2 - 50;


export const WORLD_3D = {
	WIDTH: 1920,
	HEIGHT: 1080,
	DEPTH: 500,
	CAMERA_DISTANCE: 1500
} as const;

export const PADDLE_3D = {
	START_POSX: 900,
	START_POSY: 15,
	START_POSZ: 0,
	X: 15,
	Y: 15,
	Z: 100,
	MARGIN: 30,
	SPEED: 800,
	SCALE_3D: 0.01
} as const;

export const BALL_3D = {
	START_POSX: 0,
	START_POSY: 15,
	START_POSZ: 0,
	DIAMETER: 30,
	SCALE_3D: 0.01,
} as const;

export const POWERUP_3D = {
	// cylinder
	RADIUS: 10,
	HEIGHT: 5,
} as const;

export const MATERIALS = {
	PADDLE_COLOR: '#5a5a5a',
	BALL_COLOR: '#FFFFFF',
	POWERUP_SPLIT: '#FFD700',
	POWERUP_BLACKOUT: '#1522da',
	POWERUP_BLACKHOLE: '#12012e',
	BORDER: '#3CFFE2',
	CABLE: '#ADFFE6',
	poleCylinder:'#2E2E2E',
	poleTop:'#00FFBC',
	poleMid:'#2E2E2E',
	poleBot:'#2E2E2E'
} as const;

export const CAMERA = {
	INITIAL_ALPHA: -Math.PI / 2,
	INITIAL_BETA: Math.PI / 3,
	INITIAL_RADIUS: 30,
	TARGET: {
		x: 0,
		y: 0,
		z: 0
	},
	MIN_RADIUS: 10,
	MAX_RADIUS: 400,
	ANIMATION : {
		START_ALPHA: Math.PI / 2,
		END_ALPHA: -Math.PI / 2,
		START_BETA: Math.PI / 6,
		END_BETA: Math.PI / 3,
		START_RADIUS: 80,
		END_RADIUS: 30,
		DURATION_FRAMES: 180
	},
	FPS_ALPHA: 0,
	FPS_BETA: Math.PI / 2.5,
	FPS_RADIUS: 20
} as const;

// ==============================================
// üìÑ ./src/components/Game3d/network/NetworkManager.ts
// ==============================================
import { WSClient, type PublicState } from "../../../net/wsClient";
import type { InputState } from "../types";

export class NetworkManager  {
	private wsClient: WSClient;
	private roomId: string;
	private isConnected: boolean = false;

	// callbacks
	public onStateUpdate?: (state: PublicState) => void;
	public onWelcome?: (side: 'left' | 'right' | 'spectator', playerNames?: any) => void;
	public onGameOver?: (winner: string, isTournament?: boolean, tournamentId?: string) => void;
	public onPaused?: () => void;
	public onResumed?: () => void;
	public onCountdown?: (value: number) => void;
	public onTimeoutStatus?: (status: { left: { active: boolean; remainingMs: number }; right: { active: boolean; remainingMs: number } }) => void;

	constructor(roomId: string) {
		this.roomId = roomId;
		this.wsClient = new WSClient();
		this.setupNetworkHandlers();
	}

	private setupNetworkHandlers() {
		this.wsClient.onState = (state) => {
			if (this.onStateUpdate) {
				this.onStateUpdate(state);
			}
		}
		this.wsClient.onWelcome = (side, playerNames) => {
			this.isConnected = true;
			if (this.onWelcome) {
				this.onWelcome(side, playerNames);
			}
		}
		this.wsClient.onGameOver = (winner, isTournament, tournamentId) => {
			if (this.onGameOver) {
				this.onGameOver(winner, isTournament, tournamentId);
			}
		}
		this.wsClient.onPaused = () => {
			if (this.onPaused) {
				this.onPaused();
			}
		}

		this.wsClient.onResumed = () => {
			if (this.onResumed) this.onResumed();
		};

		this.wsClient.onCountdown = (v) => {
			if (this.onCountdown) this.onCountdown(v);
		};

		this.wsClient.onTimeoutStatus = (s) => {
			if (this.onTimeoutStatus) this.onTimeoutStatus(s);
		};
	}

	public connect(): void {
		const storedUrl = sessionStorage.getItem('gameServerURL') || undefined;
		if (storedUrl) {
			this.wsClient.connect(storedUrl);
		} else {
			const host = import.meta.env.VITE_HOST;
			const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
			const fallbackUrl = host && endpoint && this.roomId
				? `wss://${host}${endpoint}/${this.roomId}`
				: undefined;
			this.wsClient.connect(fallbackUrl);
		}
	}

	public sendInput(input: InputState): void {
		if (!this.isConnected) return;
		const side = this.wsClient.side;

		let up = false;
		let down = false;

		if (side === 'left') {
			up = input.up || input.left;
			down = input.down || input.right;
		} else {
			up = input.up || input.right;
			down = input.down || input.left;
		}
		this.wsClient.sendInput(up, down);
	}

	public useSkill(): void {
		if (!this.isConnected) return;
		this.wsClient.useSkill();
	}

	public forfeit(): void {
		if (!this.isConnected) return;
		this.wsClient.forfeit();
	}

	public getSide(): 'left' | 'right' | 'spectator' {
		return this.wsClient.side;
	}

	public disconnect(): void {
		this.wsClient.cleanup();
		this.isConnected = false;
		this.onStateUpdate = undefined;
		this.onWelcome = undefined;
		this.onGameOver = undefined;
	}
}

// ==============================================
// üìÑ ./src/components/JoinTournament.ts
// ==============================================
import type { ComponentProps, Component } from "./types";

interface JoinTournamentProps extends ComponentProps
{
	slots: number
}

export class JoinTournamentComponent implements Component
{
	private element: HTMLElement
	private slots: string | null

	constructor(element: HTMLElement)
	{

		this.element = element;
		this.slots = element.getAttribute('data-slots')
		this.init();
	}

	private init(): void
	{

	}
	
	cleanup(): void
	{

	}
}

export function JoinTournament({
	className = 'px-32 py-16 border-2 border-red-400 rounded-2xl cursor-pointer',
	slots
} : JoinTournamentProps) {
	const chatClasses = `${className}`

	return `
		<button class="${chatClasses}"
			data-component="joinTournament"
			data-slots=${slots}	
		>
			${slots} Players
			<span></span>
		<button>
	`
}

// ==============================================
// üìÑ ./src/components/types.ts
// ==============================================
export interface ComponentProps {
    children?: string | string[];
    className?: string;
    id?: string;
    [key: string]: any;
}

export function renderChildren(children?: string | string[]): string {
    if (!children) return '';
    return Array.isArray(children) ? children.join('') : children;
}

export interface Component
{
    cleanup(): void;
}
// ==============================================
// üìÑ ./src/components/ComponantManager.ts
// ==============================================
import type { Component } from "./types";

type ComponentConstructor = new (element: HTMLElement) => Component;

export class ComponentRegistry
{
    private static components: Map<string, ComponentConstructor> = new Map();

    static register(name: string, constructor: ComponentConstructor): void
    {
        this.components.set(name, constructor);
    }

    static get(name: string): ComponentConstructor | undefined
    {
        return this.components.get(name);
    }
}

export class ComponentManager
{
    private instances: Map<HTMLElement, Component> = new Map();
    
    scanAndMount(): void
    {
        const components = document.querySelectorAll('[data-component]');
        console.log(components)
        
        components.forEach(element => {
            const componentName = element.getAttribute('data-component');
            if (!componentName) return;
            
            const ComponentClass = ComponentRegistry.get(componentName);
            
            if (ComponentClass && !this.instances.has(element as HTMLElement))
            {
                const instance = new ComponentClass(element as HTMLElement);
                this.instances.set(element as HTMLElement, instance);
            }
        });
    }
    
    cleanupAll(): void
    {
        this.instances.forEach(instance => instance.cleanup());
        this.instances.clear();
    }
}

// ==============================================
// üìÑ ./src/utils/localTournamentManager.ts
// ==============================================
/**
 * Local Tournament Manager
 * Manages local tournament bracket generation and state without backend
 */

export interface LocalPlayer {
  id: string;
  username: string;
  selectedSkill: 'smash' | 'dash';
  eliminated: boolean;
}

export interface LocalMatch {
  id: string;
  round: number;
  position: number;
  player1?: LocalPlayer;
  player2?: LocalPlayer;
  winner?: LocalPlayer;
  status: 'pending' | 'ready' | 'in_progress' | 'finished';
}

export interface LocalTournament {
  id: string;
  size: 4 | 8;
  players: LocalPlayer[];
  bracket: LocalMatch[];
  currentRound: number;
  status: 'setup' | 'in_progress' | 'finished';
  winner?: LocalPlayer;
  createdAt: Date;
}

export class LocalTournamentManager {
  private static readonly STORAGE_KEY = 'localTournament';

  /**
   * Create a new local tournament
   */
  static createTournament(size: 4 | 8, players: Omit<LocalPlayer, 'eliminated'>[]): LocalTournament {
    if (players.length !== size) {
      throw new Error(`Expected ${size} players, got ${players.length}`);
    }

    const tournament: LocalTournament = {
      id: this.generateId(),
      size,
      players: players.map(p => ({ ...p, eliminated: false })),
      bracket: [],
      currentRound: 1,
      status: 'setup',
      createdAt: new Date(),
    };

    // Shuffle players for fairness
    const shuffledPlayers = this.shuffleArray([...tournament.players]);

    // Generate first round bracket
    tournament.bracket = this.generateFirstRound(shuffledPlayers);
    tournament.status = 'in_progress';

    this.saveTournament(tournament);
    return tournament;
  }

  /**
   * Generate first round matches from shuffled players
   */
  private static generateFirstRound(players: LocalPlayer[]): LocalMatch[] {
    const matches: LocalMatch[] = [];
    const matchCount = players.length / 2;

    for (let i = 0; i < matchCount; i++) {
      matches.push({
        id: this.generateId(),
        round: 1,
        position: i,
        player1: players[i * 2],
        player2: players[i * 2 + 1],
        status: 'ready',
      });
    }

    return matches;
  }

  /**
   * Get the current tournament from storage
   */
  static getCurrentTournament(): LocalTournament | null {
    const data = sessionStorage.getItem(this.STORAGE_KEY);
    if (!data) return null;

    try {
      const tournament = JSON.parse(data);
      // Convert date strings back to Date objects
      tournament.createdAt = new Date(tournament.createdAt);
      return tournament;
    } catch (error) {
      console.error('Failed to parse tournament data:', error);
      return null;
    }
  }

  /**
   * Save tournament to storage
   */
  static saveTournament(tournament: LocalTournament): void {
    sessionStorage.setItem(this.STORAGE_KEY, JSON.stringify(tournament));
  }

  /**
   * Clear tournament from storage
   */
  static clearTournament(): void {
    sessionStorage.removeItem(this.STORAGE_KEY);
  }

  /**
   * Get the next match to be played
   */
  static getNextMatch(tournament: LocalTournament): LocalMatch | null {
    return tournament.bracket.find(
      m => m.status === 'ready' && m.round === tournament.currentRound
    ) || null;
  }

  /**
   * Get all matches for a specific round
   */
  static getMatchesForRound(tournament: LocalTournament, round: number): LocalMatch[] {
    return tournament.bracket.filter(m => m.round === round);
  }

  /**
   * Record match result and update bracket
   */
  static recordMatchResult(matchId: string, winnerId: string): LocalTournament | null {
    const tournament = this.getCurrentTournament();
    if (!tournament) return null;

    const match = tournament.bracket.find(m => m.id === matchId);
    if (!match) return null;

    // Determine winner and loser
    const winner = match.player1?.id === winnerId ? match.player1 : match.player2;
    const loser = match.player1?.id === winnerId ? match.player2 : match.player1;

    if (!winner || !loser) return null;

    // Update match
    match.winner = winner;
    match.status = 'finished';

    // Mark loser as eliminated
    const loserInPlayers = tournament.players.find(p => p.id === loser.id);
    if (loserInPlayers) {
      loserInPlayers.eliminated = true;
    }

    // Check if current round is complete
    const currentRoundMatches = this.getMatchesForRound(tournament, tournament.currentRound);
    const allFinished = currentRoundMatches.every(m => m.status === 'finished');

    if (allFinished) {
      // Check if tournament is over
      if (currentRoundMatches.length === 1) {
        // Final match - tournament complete
        tournament.status = 'finished';
        tournament.winner = winner;
      } else {
        // Create next round
        this.createNextRound(tournament);
      }
    }

    this.saveTournament(tournament);
    return tournament;
  }

  /**
   * Create next round from winners of current round
   */
  private static createNextRound(tournament: LocalTournament): void {
    const currentRoundMatches = this.getMatchesForRound(tournament, tournament.currentRound);
    const winners = currentRoundMatches
      .filter(m => m.winner)
      .map(m => m.winner!);

    if (winners.length < 2) {
      console.error('Not enough winners to create next round');
      return;
    }

    tournament.currentRound++;
    const newMatches: LocalMatch[] = [];
    const matchCount = winners.length / 2;

    for (let i = 0; i < matchCount; i++) {
      newMatches.push({
        id: this.generateId(),
        round: tournament.currentRound,
        position: i,
        player1: winners[i * 2],
        player2: winners[i * 2 + 1],
        status: 'ready',
      });
    }

    tournament.bracket.push(...newMatches);
  }

  /**
   * Mark match as in progress
   */
  static markMatchInProgress(matchId: string): void {
    const tournament = this.getCurrentTournament();
    if (!tournament) return;

    const match = tournament.bracket.find(m => m.id === matchId);
    if (match) {
      match.status = 'in_progress';
      this.saveTournament(tournament);
    }
  }

  /**
   * Get total number of rounds for tournament size
   */
  static getTotalRounds(size: 4 | 8): number {
    return size === 4 ? 2 : 3; // 4 players = 2 rounds, 8 players = 3 rounds
  }

  /**
   * Get round name
   */
  static getRoundName(round: number, totalRounds: number): string {
    if (round === totalRounds) return 'Final';
    if (round === totalRounds - 1) return 'Semi-Finals';
    if (round === totalRounds - 2) return 'Quarter-Finals';
    return `Round ${round}`;
  }

  /**
   * Shuffle array using Fisher-Yates algorithm
   */
  private static shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  /**
   * Generate unique ID
   */
  private static generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ==============================================
// üìÑ ./src/vite-env.d.ts
// ==============================================
/// <reference types="vite/client" />

interface ImportMetaEnv {
    readonly VITE_HOST: string
    readonly VITE_GAME_ENDPOINT: string
    readonly VITE_CHAT_ENDPOINT: string
    readonly VITE_CREATEGAME_ENDPOINT: string
    // Ajoute ici toutes tes variables d'environnement VITE_*
}

interface ImportMeta {
    readonly env: ImportMetaEnv
}
// ==============================================
// üìÑ ./src/views/LocalGameView.ts
// ==============================================
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";

const makeId = () => {
	if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
		return crypto.randomUUID();
	}
	return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
};

export const LocalGameView: ViewFunction = () => {
	return `
		<!-- Fond avec grille anim√©e -->
		<div class="fixed inset-0 bg-black overflow-hidden">
			<!-- Grille de fond -->
			<div class="absolute inset-0" style="
				background-image: 
					linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
					linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
				background-size: 50px 50px;
				animation: gridMove 20s linear infinite;
			"></div>
			
			<style>
				@keyframes gridMove {
					0% { transform: translateY(0); }
					100% { transform: translateY(50px); }
				}
				
				@keyframes neonPulse {
					0%, 100% { 
						text-shadow: 
							0 0 10px rgba(59, 130, 246, 0.8),
							0 0 20px rgba(59, 130, 246, 0.6),
							0 0 30px rgba(59, 130, 246, 0.4);
					}
					50% { 
						text-shadow: 
							0 0 20px rgba(59, 130, 246, 1),
							0 0 30px rgba(59, 130, 246, 0.8),
							0 0 40px rgba(59, 130, 246, 0.6);
					}
				}
				
				@keyframes scanline {
					0% { transform: translateY(-100%); }
					100% { transform: translateY(100vh); }
				}
				
				.pixel-font {
					font-family: 'Courier New', monospace;
					font-weight: bold;
					letter-spacing: 0.1em;
				}
				
				.neon-border {
					box-shadow: 
						0 0 10px rgba(59, 130, 246, 0.5),
						inset 0 0 10px rgba(59, 130, 246, 0.2);
					border: 3px solid rgba(59, 130, 246, 0.8);
				}
				
				.neon-border:hover {
					box-shadow: 
						0 0 20px rgba(59, 130, 246, 0.8),
						inset 0 0 20px rgba(59, 130, 246, 0.3);
					border-color: rgba(59, 130, 246, 1);
				}
				
				.neon-input {
					background: rgba(15, 23, 42, 0.6);
					border: 2px solid rgba(59, 130, 246, 0.5);
					color: #60A5FA;
					transition: all 0.3s ease;
				}
				
				.neon-input:focus {
					outline: none;
					border-color: rgba(59, 130, 246, 1);
					box-shadow: 
						0 0 10px rgba(59, 130, 246, 0.5),
						inset 0 0 10px rgba(59, 130, 246, 0.2);
					background: rgba(15, 23, 42, 0.8);
				}
				
				.neon-input::placeholder {
					color: rgba(96, 165, 250, 0.4);
				}

				.player-card {
					transition: all 0.3s ease;
					background: rgba(15, 23, 42, 0.6);
					backdrop-filter: blur(10px);
				}

				.player-card:hover {
					transform: translateY(-5px);
					background: rgba(30, 41, 59, 0.8);
				}

				.control-hint {
					background: rgba(59, 130, 246, 0.1);
					border: 1px solid rgba(59, 130, 246, 0.3);
				}
			</style>
			
			<!-- Scanline effect -->
			<div class="absolute inset-0 pointer-events-none opacity-10">
				<div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
			</div>
		</div>

		<!-- Contenu principal -->
		<div class="relative z-10 min-h-screen flex flex-col">
			<!-- Header avec BackButton -->
			<header class="flex justify-between items-center px-8 py-6">
				<button 
					onclick="history.back()" 
					class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
					id="back-button"
				>
					‚Üê BACK
				</button>
				
				<!-- Bouton Sign in -->
				<a href="/login" 
				   class="pixel-font bg-blue-500 text-black px-6 py-3 text-sm md:text-base hover:bg-blue-400 transition-all neon-border flex items-center gap-2">
					<span>SIGN IN</span>
				</a>
			</header>

			<!-- Zone centrale -->
			<div class="flex-1 flex items-center justify-center px-4 py-12">
				<div class="w-full max-w-6xl">
					
					<!-- Titre principal -->
					<div class="text-center mb-12">
						<h1 class="pixel-font text-5xl md:text-7xl text-blue-400 mb-4" 
							style="animation: neonPulse 2s ease-in-out infinite;"
							id="local-title">
							üéÆ LOCAL GAME üéÆ
						</h1>
						<p class="pixel-font text-lg text-blue-300 opacity-80">
							>>> TWO PLAYERS - ONE SCREEN <<<
						</p>
					</div>

					<!-- Formulaire -->
					<form id="local-game-form" class="space-y-8">
						<!-- Grid pour les deux joueurs -->
						<div class="grid grid-cols-1 md:grid-cols-2 gap-6">
							
							<!-- Joueur 1 (Gauche) -->
							<div class="player-card neon-border rounded-lg p-6" id="player-left-card" style="opacity: 0; transform: translateX(-100px);">
								<!-- Header -->
								<div class="flex items-center justify-between mb-6">
									<h2 class="pixel-font text-2xl text-blue-400 ">PLAYER 1</h2>
								</div>

								<!-- Username -->
								<div class="mb-4">
									<label for="local-left-name" class="block mb-2 pixel-font text-sm text-blue-300">
										USERNAME:
									</label>
									<input 
										type="text" 
										id="local-left-name" 
										name="left-name"
										placeholder="Player 1"
										maxlength="24"
										required
										class="w-full p-3 rounded pixel-font text-sm neon-input"
									/>
								</div>

								<!-- Skill -->
								<div class="mb-6">
									<label for="local-left-skill" class="block mb-2 pixel-font text-sm text-blue-300">
										SKILL:
									</label>
									<select 
										id="local-left-skill" 
										name="left-skill"
										class="w-full p-3 rounded pixel-font text-sm neon-input cursor-pointer"
									>
										<option value="smash">üí• Smash</option>
										<option value="dash">‚ö° Dash</option>
									</select>
								</div>

								<!-- Contr√¥les -->
								<div class="control-hint rounded-lg p-4">
									<div class="pixel-font text-xs text-blue-300 mb-2 font-bold">
										CONTROLS:
									</div>
									<div class="space-y-1 pixel-font text-xs text-blue-300/80">
										<div>W / S ‚Üí Move paddle</div>
										<div>SPACE ‚Üí Use skill</div>
									</div>
								</div>
							</div>

							<!-- Joueur 2 (Droite) -->
							<div class="player-card neon-border rounded-lg p-6" id="player-right-card" style="opacity: 0; transform: translateX(100px);">
								<!-- Header -->
								<div class="flex items-center justify-between mb-6">
									<h2 class="pixel-font text-2xl text-red-500">PLAYER 2</h2>
								</div>

								<!-- Username -->
								<div class="mb-4">
									<label for="local-right-name" class="block mb-2 pixel-font text-sm text-red-400">
										USERNAME:
									</label>
									<input 
										type="text" 
										id="local-right-name" 
										name="right-name"
										placeholder="Player 2"
										maxlength="24"
										required
										class="w-full p-3 rounded pixel-font text-sm neon-input"
									/>
								</div>

								<!-- Skill -->
								<div class="mb-6">
									<label for="local-right-skill" class="block mb-2 pixel-font text-sm text-red-400">
										SKILL:
									</label>
									<select 
										id="local-right-skill" 
										name="right-skill"
										class="w-full p-3 rounded pixel-font text-sm neon-input cursor-pointer"
									>
										<option value="smash">üí• Smash</option>
										<option value="dash">‚ö° Dash</option>
									</select>
								</div>

								<!-- Contr√¥les -->
								<div class="control-hint rounded-lg p-4">
									<div class="pixel-font text-xs text-red-400 mb-2 font-bold">
										CONTROLS:
									</div>
									<div class="space-y-1 pixel-font text-xs text-red-400/80">
										<div>‚Üë / ‚Üì ‚Üí Move paddle</div>
										<div>ENTER ‚Üí Use skill</div>
									</div>
								</div>
							</div>
						</div>

						<!-- Message d'erreur -->
						<div id="local-game-feedback" class="hidden neon-border bg-red-500/10 rounded-lg p-4 text-center">
							<p class="pixel-font text-sm text-red-400"></p>
						</div>

						<!-- Boutons d'action -->
						<div class="flex flex-col gap-4">
							<!-- Bouton START -->
							<button 
								type="submit" 
								class="w-full py-4 pixel-font text-lg neon-border bg-green-500/20 text-green-400 hover:bg-green-500/40 hover:text-white transition-all relative group"
								id="start-btn"
							>
								<span class="relative z-10">>>> START GAME <<<</span>
								<div class="absolute inset-0 bg-green-500/0 group-hover:bg-green-500/10 transition-all rounded"></div>
							</button>

							<!-- Bouton RETOUR -->
							<button 
								type="button" 
								id="local-back-btn"
								class="w-full py-3 pixel-font text-sm neon-border bg-transparent text-blue-400 hover:bg-blue-500/20 transition-all"
							>
								‚Üê BACK TO MENU
							</button>
						</div>
					</form>

					<!-- Info suppl√©mentaire -->
					<div class="mt-8 text-center">
						<div class="inline-block neon-border bg-blue-500/10 rounded-lg px-6 py-3">
							<p class="pixel-font text-xs text-blue-300/60">
								üí° TIP: Choose different skills for more strategic gameplay!
							</p>
						</div>
					</div>
				</div>
			</div>

			<!-- Footer -->
			<footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
				<p>¬© 2025 PONG - SKILL ISSUE</p>
			</footer>
		</div>
	`;
};

export const localGameLogic = (): CleanupFunction | void => {
	// Animations d'entr√©e - UNE SEULE FOIS
	gsap.to('#local-title', {
		scale: 1,
		opacity: 1,
		duration: 1,
		ease: 'back.out(1.7)'
	});

	gsap.to('#player-left-card', {
		x: 0,
		opacity: 1,
		duration: 0.8,
		delay: 0.3,
		ease: 'power2.out'
	});

	gsap.to('#player-right-card', {
		x: 0,
		opacity: 1,
		duration: 0.8,
		delay: 0.3,
		ease: 'power2.out'
	});

	const form = document.getElementById('local-game-form') as HTMLFormElement | null;
	const feedbackEl = document.getElementById('local-game-feedback');
	const feedbackText = feedbackEl?.querySelector('p');
	const backBtn = document.getElementById('local-back-btn');

	if (!form) {
		return;
	}

	const host = import.meta.env.VITE_HOST || 'localhost:8443';
	const createEndpoint = import.meta.env.VITE_CREATEGAME_ENDPOINT || '/gameback/create';
	const gameEndpoint = import.meta.env.VITE_GAME_ENDPOINT || '/gameback/game';

	const showError = (message: string) => {
		if (feedbackEl && feedbackText) {
			feedbackText.textContent = message;
			feedbackEl.classList.remove('hidden');
			
			// Animation de l'erreur
			gsap.fromTo(feedbackEl, 
				{ scale: 0.8, opacity: 0 },
				{ scale: 1, opacity: 1, duration: 0.3, ease: 'back.out' }
			);
		}
	};

	const hideError = () => {
		if (feedbackEl) {
			feedbackEl.classList.add('hidden');
		}
	};

	const backHandler = () => {
		window.router?.navigateTo('/play');
	};

	backBtn?.addEventListener('click', backHandler);

	const submitHandler = async (event: Event) => {
		event.preventDefault();
		hideError();
		
		const submitBtn = form.querySelector('button[type="submit"]') as HTMLButtonElement | null;
		if (submitBtn) {
			submitBtn.disabled = true;
			
			// Animation du bouton
			gsap.to(submitBtn, {
				scale: 0.95,
				duration: 0.1,
				yoyo: true,
				repeat: 1
			});
		}

		const leftName = (form.querySelector<HTMLInputElement>('input[name="left-name"]')?.value.trim() || 'Player 1');
		const rightName = (form.querySelector<HTMLInputElement>('input[name="right-name"]')?.value.trim() || 'Player 2');
		const leftSkill = (form.querySelector<HTMLSelectElement>('select[name="left-skill"]')?.value === 'dash') ? 'dash' : 'smash';
		const rightSkill = (form.querySelector<HTMLSelectElement>('select[name="right-skill"]')?.value === 'dash') ? 'dash' : 'smash';

		const roomId = makeId();
		const leftId = makeId();
		const rightId = makeId();

		try {
			const response = await fetch(`https://${host}${createEndpoint}`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					roomId,
					player1: { id: leftId, username: leftName, selectedSkill: leftSkill },
					player2: { id: rightId, username: rightName, selectedSkill: rightSkill }
				})
			});

			if (!response.ok) {
				throw new Error(`Server error (${response.status})`);
			}

			const wsUrl = `wss://${host}${gameEndpoint}/${roomId}`;
			sessionStorage.setItem('gameWsURL', wsUrl);
			sessionStorage.setItem('localGameConfig', JSON.stringify({
				roomId,
				left: { id: leftId, username: leftName, selectedSkill: leftSkill },
				right: { id: rightId, username: rightName, selectedSkill: rightSkill }
			}));

			// Redirection imm√©diate
			window.router?.navigateTo(`/game/${roomId}`);
		} catch (err) {
			console.error('Failed to create local game session', err);
			showError(err instanceof Error ? err.message : 'Unable to create local game.');
			
			if (submitBtn) {
				submitBtn.disabled = false;
			}
		}
	};

	form.addEventListener('submit', submitHandler);

	return () => {
		form.removeEventListener('submit', submitHandler);
		backBtn?.removeEventListener('click', backHandler);
	};
};

// ==============================================
// üìÑ ./src/views/Game3dView.ts
// ==============================================
import type { ViewFunction } from "../router/types";
import { Game3dComponent, Game3D } from "../components/Game3d/Game3d";

 export const Game3dView: ViewFunction = () => {
	setTimeout(() => {
		const gameContainer = document.getElementById('game-content');
		if (gameContainer) {
			new Game3D(gameContainer);
		} else
			console.error('Game container not found');
	}, 100);
	
	return `
		<div id="game-content">
			${Game3dComponent()}
		</div>
	`
};

// ==============================================
// üìÑ ./src/views/DbUserView.ts
// ==============================================
import type { ViewFunction } from "../router/types";
import { Header } from "../components/Header";

export const dbUserView: ViewFunction = () => {
    return `
        <div class="fixed inset-0 bg-[#04071A] overflow-hidden">
			<!-- √âtoiles -->
			${Array.from({length: 150}, (_, i) => `
			<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			<!-- √âtoiles normales -->
			${Array.from({length: 150}, (_, i) => `
				<div 
					class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
					style="
						width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						opacity: ${0.3 + Math.random() * 0.7};
						${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
					"
				></div>
			`).join('')}
			
			<!-- √âtoiles qui scintillent fort -->
			${Array.from({length: 50}, (_) => `
				<div 
					class="absolute"
					style="
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
					"
				>
					<div class="w-[4px] h-[4px] bg-white rounded-full"></div>
				</div>
			`).join('')}
			
			<style>
				@keyframes strong-sparkle {
					0%, 100% {
						opacity: 0.3;
						filter: blur(0px);
					}
					50% {
						opacity: 1;
						filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
					}
				}
			</style>

        ${Header({ isLogged: false })}
        <h1>bonjour kenzo</h1>

        `;
};

export const dbUserLogic = (): CleanupFunction => {

    function handleClick() {
        alert("ok")
    }
    
    document?.querySelector('h1')?.addEventListener("click", handleClick)


    return () => {
        document.querySelector('h1')?.removeEventListener("click", handleClick)
    };
};

// ==============================================
// üìÑ ./src/views/GameDetailView.ts
// ==============================================
import type { ViewFunction } from "../router/types";
import { BackButton } from "../components/Button";
import { gsap } from "gsap";

interface GameDetail {
    id: string;
    room_id: string;
    game_type: 'quickplay' | 'tournament';
    tournament_id?: string;
    tournament_round?: number;
    player_left_id: string;
    player_right_id: string;
    player_left_username: string;
    player_right_username: string;
    winner_username?: string;
    score_left: number;
    score_right: number;
    status: string;
    end_reason?: 'score' | 'timeout' | 'forfeit';
    created_at: string;
    started_at?: string;
    finished_at?: string;
    duration_seconds?: number;
    stats: GameStat[];
    skills: SkillUsed[];
    powerUps: PowerUpUsed[];
    goals: Goal[];
}

interface GameStat {
    player_id: string;
    username: string;
    side: 'left' | 'right';
    paddle_hits: number;
    max_ball_speed: number;
    power_ups_collected: number;
    skills_used: number;
    time_disconnected_ms: number;
}

interface SkillUsed {
    player_id: string;
    username: string;
    skill_type: string;
    activated_at_game_time: number;
    was_successful: boolean;
}

interface PowerUpUsed {
    player_id: string;
    username: string;
    power_up_type: 'split' | 'blackout' | 'blackhole';
    collected_at_game_time?: number;
    activated_at_game_time: number;
}

interface Goal {
    id: number;
    game_id: string;
    scorer_side: 'left' | 'right';
    scored_against_side: 'left' | 'right';
    ball_y_position: number;
    scored_at_game_time: number;
}

export const GameDetailView: ViewFunction = (params) => {
    const gameId = params?.id || '';
    
    return `
        <!-- Fond √©toil√© -->
        <div class="fixed inset-0 bg-[#04071A] overflow-hidden">
            ${Array.from({length: 150}, (_, i) => `
                <div 
                    class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
                    style="
                        width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                        height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        opacity: ${0.3 + Math.random() * 0.7};
                        ${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
                    "
                ></div>
            `).join('')}
            
            ${Array.from({length: 50}, (_) => `
                <div 
                    class="absolute"
                    style="
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
                    "
                >
                    <div class="w-[4px] h-[4px] bg-white rounded-full"></div>
                </div>
            `).join('')}
            
            <style>
                @keyframes strong-sparkle {
                    0%, 100% {
                        opacity: 0.3;
                        filter: blur(0px);
                    }
                    50% {
                        opacity: 1;
                        filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
                    }
                }
            </style>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen">
            <!-- Header avec BackButton -->
            <div class="p-8">
                ${BackButton({
                    size: "lg",
                    className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
                })}
            </div>

            <!-- Container principal -->
            <div class="container mx-auto px-8 pb-8" data-game-id="${gameId}">
                <!-- Loading state -->
                <div id="game-loading" class="text-center py-12">
                    <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
                    <p class="text-white/60 mt-4">Chargement des d√©tails...</p>
                </div>

                <!-- Content (sera inject√© par JS) -->
                <div id="game-content" style="display: none;">
                    <!-- Le contenu sera g√©n√©r√© dynamiquement -->
                </div>

                <!-- Error state -->
                <div id="game-error" style="display: none;" class="text-center py-12">
                    <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                    <h3 class="text-2xl font-bold text-red-400 mb-2">Partie non trouv√©e</h3>
                    <p class="text-white/60">Impossible de charger les d√©tails de cette partie</p>
                </div>
            </div>
        </div>
    `;
};

export const gameDetailLogic = (params?: Record<string, string>): (() => void) => {
    const gameId = params?.id;
    
    if (!gameId) {
        showError();
        return () => {};
    }

    const fetchGameDetails = async (): Promise<void> => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/gamedb/games/${gameId}`);
            
            if (!response.ok) {
                throw new Error('Failed to fetch game details');
            }

            const data = await response.json();
            
            if (data.success && data.game) {
                displayGameDetails(data.game);
                hideLoading();
            } else {
                showError();
            }
        } catch (err) {
            console.error('Error fetching game details:', err);
            showError();
        }
    };

    const displayGameDetails = (game: GameDetail): void => {
        const contentElement = document.getElementById('game-content');
        if (!contentElement) return;

        const date = new Date(game.created_at);
        const formattedDate = date.toLocaleDateString('fr-FR', {
            day: '2-digit',
            month: 'long',
            year: 'numeric'
        });
        const formattedTime = date.toLocaleTimeString('fr-FR', {
            hour: '2-digit',
            minute: '2-digit'
        });

        const duration = game.duration_seconds 
            ? `${Math.floor(game.duration_seconds / 60)}:${(game.duration_seconds % 60).toString().padStart(2, '0')}`
            : '-';

        const isWinner = game.score_left > game.score_right;
        const isDraw = game.score_left === game.score_right;
        const resultIcon = isWinner ? 'üèÜ' : isDraw ? 'ü§ù' : 'üíÄ';

        const gameTypeLabel = game.game_type === 'tournament' ? 'üèÜ Tournoi' : '‚ö° QuickPlay';
        const gameTypeBg = game.game_type === 'tournament' ? 'bg-purple-500/20' : 'bg-blue-500/20';

        // Trouver les stats de chaque joueur
        const leftStats = game.stats.find(s => s.side === 'left');
        const rightStats = game.stats.find(s => s.side === 'right');

        // Grouper skills et power-ups par joueur
        const leftSkills = game.skills.filter(s => s.player_id === game.player_left_id);
        const rightSkills = game.skills.filter(s => s.player_id === game.player_right_id);
        const leftPowerUps = game.powerUps.filter(p => p.player_id === game.player_left_id);
        const rightPowerUps = game.powerUps.filter(p => p.player_id === game.player_right_id);

        // Calculer taux de r√©ussite des skills par joueur
        const calculateSkillSuccessRate = (skills: SkillUsed[]) => {
            if (skills.length === 0) return { total: 0, successful: 0, rate: 0 };
            const successful = skills.filter(s => s.was_successful).length;
            return {
                total: skills.length,
                successful,
                rate: (successful / skills.length) * 100
            };
        };

        const leftSkillStats = calculateSkillSuccessRate(leftSkills);
        const rightSkillStats = calculateSkillSuccessRate(rightSkills);

        // Cr√©er la timeline des √©v√©nements (skills + power-ups)
        const createTimeline = () => {
            const events: Array<{
                time: number;
                type: 'skill' | 'powerup' | 'goal';
                player: string;
                playerId: string;
                data: SkillUsed | PowerUpUsed | Goal;
            }> = [];

            // Ajouter les skills
            game.skills.forEach(skill => {
                events.push({
                    time: skill.activated_at_game_time,
                    type: 'skill',
                    player: skill.username,
                    playerId: skill.player_id,
                    data: skill
                });
            });

            // Ajouter les power-ups
            game.powerUps.forEach(powerUp => {
                events.push({
                    time: powerUp.activated_at_game_time,
                    type: 'powerup',
                    player: powerUp.username,
                    playerId: powerUp.player_id,
                    data: powerUp
                });
            });

            // Ajouter les goals
            game.goals.forEach(goal => {
                const scorerUsername = goal.scorer_side === 'left' ? game.player_left_username : game.player_right_username;
                const scorerPlayerId = goal.scorer_side === 'left' ? game.player_left_id : game.player_right_id;
                events.push({
                    time: goal.scored_at_game_time,
                    type: 'goal',
                    player: scorerUsername,
                    playerId: scorerPlayerId,
                    data: goal
                });
            });

            // Trier par temps
            events.sort((a, b) => a.time - b.time);

            return events;
        };

        const timeline = createTimeline();

        contentElement.innerHTML = `
            <!-- Titre -->
            <div class="text-center mb-8">
                <h1 class="text-5xl font-bold text-white mb-2">D√©tails de la Partie</h1>
                <p class="text-white/60 text-lg">${formattedDate} √† ${formattedTime}</p>
            </div>

            <!-- Infos principales -->
            <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-8 mb-6">
                <div class="flex items-center justify-between mb-6">
                    <div class="flex items-center gap-4">
                        <div class="text-5xl">${resultIcon}</div>
                        <div>
                            <div class="text-3xl font-bold text-white">
                                ${isDraw ? '√âGALIT√â' : `Victoire de ${game.winner_username}`}
                            </div>
                            <div class="${gameTypeBg} inline-block px-4 py-2 rounded-lg text-white text-sm mt-2">
                                ${gameTypeLabel}
                            </div>
                        </div>
                    </div>
                    <div class="text-right">
                        ${game.end_reason ? `
                            <div class="text-white/60 text-sm mb-2">
                                ${game.end_reason === 'score' ? 'üéØ Termin√© au score' : 
                                  game.end_reason === 'timeout' ? '‚è±Ô∏è Timeout' : 
                                  'üö´ Forfait'}
                            </div>
                        ` : ''}
                        <div class="text-white/60 text-sm">‚è±Ô∏è Dur√©e: ${duration}</div>
                    </div>
                </div>

                <!-- Score -->
                <div class="grid grid-cols-3 gap-8 items-center">
                    <div class="text-center">
                        <div class="text-white text-2xl font-semibold mb-3">
                            ${game.player_left_username}
                        </div>
                        <div class="text-6xl font-bold ${game.score_left > game.score_right ? 'text-green-400' : 'text-white/60'}">
                            ${game.score_left}
                        </div>
                    </div>
                    <div class="text-center">
                        <div class="text-white/40 text-3xl font-bold">VS</div>
                    </div>
                    <div class="text-center">
                        <div class="text-white text-2xl font-semibold mb-3">
                            ${game.player_right_username}
                        </div>
                        <div class="text-6xl font-bold ${game.score_right > game.score_left ? 'text-green-400' : 'text-white/60'}">
                            ${game.score_right}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Statistiques d√©taill√©es -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                <!-- Stats joueur gauche -->
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                    <h3 class="text-2xl font-bold text-white mb-4 flex items-center gap-2">
                        <span>üìä</span> Stats - ${game.player_left_username}
                    </h3>
                    ${leftStats ? `
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">üèì Touches de paddle</span>
                                <span class="text-white font-bold text-xl">${leftStats.paddle_hits}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">üéÅ Power-ups collect√©s</span>
                                <span class="text-white font-bold text-xl">${leftStats.power_ups_collected}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">üí• Skills utilis√©s</span>
                                <span class="text-white font-bold text-xl">${leftStats.skills_used}</span>
                            </div>
                            ${leftSkillStats.total > 0 ? `
                                <div class="flex justify-between items-center">
                                    <span class="text-white/60">üéØ Taux de r√©ussite</span>
                                    <span class="${leftSkillStats.rate >= 50 ? 'text-green-400' : 'text-orange-400'} font-bold text-xl">
                                        ${leftSkillStats.rate.toFixed(0)}%
                                    </span>
                                </div>
                                <div class="w-full bg-white/10 rounded-full h-2 overflow-hidden">
                                    <div class="h-full ${leftSkillStats.rate >= 50 ? 'bg-green-400' : 'bg-orange-400'} transition-all" 
                                         style="width: ${leftSkillStats.rate}%"></div>
                                </div>
                            ` : ''}
                            ${leftStats.time_disconnected_ms > 0 ? `
                                <div class="flex justify-between items-center">
                                    <span class="text-white/60">üîå Temps d√©connect√©</span>
                                    <span class="text-red-400 font-bold text-xl">${(leftStats.time_disconnected_ms / 1000).toFixed(1)}s</span>
                                </div>
                            ` : ''}
                        </div>
                    ` : '<p class="text-white/40">Aucune statistique disponible</p>'}
                </div>

                <!-- Stats joueur droit -->
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                    <h3 class="text-2xl font-bold text-white mb-4 flex items-center gap-2">
                        <span>üìä</span> Stats - ${game.player_right_username}
                    </h3>
                    ${rightStats ? `
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">üèì Touches de paddle</span>
                                <span class="text-white font-bold text-xl">${rightStats.paddle_hits}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">üéÅ Power-ups collect√©s</span>
                                <span class="text-white font-bold text-xl">${rightStats.power_ups_collected}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span class="text-white/60">üí• Skills utilis√©s</span>
                                <span class="text-white font-bold text-xl">${rightStats.skills_used}</span>
                            </div>
                            ${rightSkillStats.total > 0 ? `
                                <div class="flex justify-between items-center">
                                    <span class="text-white/60">üéØ Taux de r√©ussite</span>
                                    <span class="${rightSkillStats.rate >= 50 ? 'text-green-400' : 'text-orange-400'} font-bold text-xl">
                                        ${rightSkillStats.rate.toFixed(0)}%
                                    </span>
                                </div>
                                <div class="w-full bg-white/10 rounded-full h-2 overflow-hidden">
                                    <div class="h-full ${rightSkillStats.rate >= 50 ? 'bg-green-400' : 'bg-orange-400'} transition-all" 
                                         style="width: ${rightSkillStats.rate}%"></div>
                                </div>
                            ` : ''}
                            ${rightStats.time_disconnected_ms > 0 ? `
                                <div class="flex justify-between items-center">
                                    <span class="text-white/60">üîå Temps d√©connect√©</span>
                                    <span class="text-red-400 font-bold text-xl">${(rightStats.time_disconnected_ms / 1000).toFixed(1)}s</span>
                                </div>
                            ` : ''}
                        </div>
                    ` : '<p class="text-white/40">Aucune statistique disponible</p>'}
                </div>
            </div>

            <!-- Heatmap des goals -->
            ${game.goals && game.goals.length > 0 ? `
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6 mb-6">
                    <h3 class="text-2xl font-bold text-white mb-6 flex items-center gap-2">
                        <span>üéØ</span> Heatmap des Goals
                    </h3>
                    
                    <!-- Terrain de jeu unifi√© -->
                    <div class="relative w-full" style="height: 400px;">
                        <!-- Terrain -->
                        <div class="absolute inset-0 bg-[#101C69]/40 rounded-lg border-2 border-white/20">
                            <!-- Ligne centrale verticale -->
                            <div class="absolute left-1/2 top-0 bottom-0 w-px bg-white/30"></div>
                            
                            <!-- Ligne centrale horizontale -->
                            <div class="absolute left-0 right-0 top-1/2 h-px bg-white/20"></div>
                            
                            <!-- Paddles visuels -->
                            <div class="absolute left-2 top-1/2 w-2 h-24 bg-blue-400/30 -translate-y-1/2 rounded"></div>
                            <div class="absolute right-2 top-1/2 w-2 h-24 bg-orange-400/30 -translate-y-1/2 rounded"></div>
                            
                            <!-- Goals marqu√©s par le joueur de GAUCHE (bord droit) -->
                            ${game.goals.filter(g => g.scorer_side === 'left').map(goal => {
                                const yPercent = (goal.ball_y_position / 1080) * 100;
                                return `
                                    <div class="absolute" style="right: 0%; top: ${yPercent}%; transform: translate(50%, -50%);">
                                        <div class="w-4 h-4 bg-blue-500 rounded-full shadow-lg shadow-blue-500/50 border-2 border-blue-300 animate-pulse" 
                                             title="${game.player_left_username} - ${goal.scored_at_game_time.toFixed(1)}s - Y: ${goal.ball_y_position.toFixed(0)}"></div>
                                    </div>
                                `;
                            }).join('')}
                            
                            <!-- Goals marqu√©s par le joueur de DROITE (bord gauche) -->
                            ${game.goals.filter(g => g.scorer_side === 'right').map(goal => {
                                const yPercent = (goal.ball_y_position / 1080) * 100;
                                return `
                                    <div class="absolute" style="left: 0%; top: ${yPercent}%; transform: translate(-50%, -50%);">
                                        <div class="w-4 h-4 bg-orange-500 rounded-full shadow-lg shadow-orange-500/50 border-2 border-orange-300 animate-pulse" 
                                             title="${game.player_right_username} - ${goal.scored_at_game_time.toFixed(1)}s - Y: ${goal.ball_y_position.toFixed(0)}"></div>
                                    </div>
                                `;
                            }).join('')}
                            
                            <!-- Labels -->
                            <div class="absolute top-2 left-1/2 -translate-x-1/2 text-white/40 text-xs font-semibold">Haut</div>
                            <div class="absolute bottom-2 left-1/2 -translate-x-1/2 text-white/40 text-xs font-semibold">Bas</div>
                            
                            <!-- Noms des joueurs -->
                            <div class="absolute top-1/2 left-8 -translate-y-1/2 -rotate-90 text-blue-400 text-sm font-bold bg-[#04071A]/80 px-2 py-1 rounded">
                                ${game.player_left_username}
                            </div>
                            <div class="absolute top-1/2 right-8 -translate-y-1/2 rotate-90 text-orange-400 text-sm font-bold bg-[#04071A]/80 px-2 py-1 rounded">
                                ${game.player_right_username}
                            </div>
                        </div>
                    </div>

                    <!-- L√©gende -->
                    <div class="mt-6 flex justify-center gap-8">
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 bg-blue-500 rounded-full shadow-lg shadow-blue-500/50 border-2 border-blue-300"></div>
                            <span class="text-white/80 text-sm">Goals de ${game.player_left_username} (${game.goals.filter(g => g.scorer_side === 'left').length})</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-4 bg-orange-500 rounded-full shadow-lg shadow-orange-500/50 border-2 border-orange-300"></div>
                            <span class="text-white/80 text-sm">Goals de ${game.player_right_username} (${game.goals.filter(g => g.scorer_side === 'right').length})</span>
                        </div>
                    </div>
                </div>
            ` : ''}

            <!-- Timeline des √©v√©nements -->
            ${timeline.length > 0 ? `
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6 mb-6">
                    <h3 class="text-2xl font-bold text-white mb-6 flex items-center gap-2">
                        <span>üìÖ</span> Timeline du Match
                    </h3>
                    
                    <!-- Filtres -->
                    <div class="flex flex-wrap gap-2 mb-6">
                        <button class="timeline-filter active px-3 py-1 rounded-lg bg-white/20 border border-white/30 text-white text-sm hover:bg-white/30 transition-all" data-filter="all">
                            Tout afficher
                        </button>
                        <button class="timeline-filter px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-white text-sm hover:bg-white/30 transition-all" data-filter="goals">
                            üéØ Goals uniquement
                        </button>
                        <button class="timeline-filter px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-white text-sm hover:bg-white/30 transition-all" data-filter="skills">
                            üí• Skills uniquement
                        </button>
                        <button class="timeline-filter px-3 py-1 rounded-lg bg-white/10 border border-white/20 text-white text-sm hover:bg-white/30 transition-all" data-filter="powerups">
                            ‚ö° Power-ups uniquement
                        </button>
                    </div>
                    
                    <div class="relative" style="padding-top: 140px; padding-bottom: 120px;">
                        <!-- Ligne horizontale principale -->
                        <div class="absolute h-1 bg-gradient-to-r from-blue-500/20 via-white/30 to-orange-500/20 rounded" style="top: 150px; left: 0; right: 0;"></div>
                        
                        <!-- Goals (au-dessus de la ligne) -->
                        ${timeline.filter(e => e.type === 'goal').map((event, index) => {
                            const isLeft = event.playerId === game.player_left_id;
                            const goal = event.data as Goal;
                            const timePercent = game.duration_seconds ? (event.time / game.duration_seconds) * 100 : 50;
                            
                            return `
                                <div class="absolute timeline-event timeline-goal" style="left: ${timePercent}%; top: 0; transform: translateX(-50%);">
                                    <div class="flex flex-col items-center">
                                        <!-- Carte goal -->
                                        <div class="bg-gradient-to-br ${isLeft ? 'from-blue-500/20 to-blue-600/10 border-blue-400/40' : 'from-orange-500/20 to-orange-600/10 border-orange-400/40'} px-3 py-2 rounded-lg border-2 backdrop-blur-sm shadow-lg mb-2">
                                            <div class="text-2xl mb-1">üéØ</div>
                                            <div class="text-xs font-bold ${isLeft ? 'text-blue-300' : 'text-orange-300'} whitespace-nowrap">${event.player}</div>
                                            <div class="text-xs text-white/60">${event.time.toFixed(1)}s</div>
                                        </div>
                                        <!-- Ligne vers timeline -->
                                        <div class="w-px ${isLeft ? 'bg-blue-400/60' : 'bg-orange-400/60'}" style="height: 50px;"></div>
                                        <!-- Point sur la timeline -->
                                        <div class="w-4 h-4 rounded-full ${isLeft ? 'bg-blue-500 border-blue-300' : 'bg-orange-500 border-orange-300'} border-2 shadow-lg"></div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        
                        <!-- Events (en dessous de la ligne, sans cascade) -->
                        ${timeline.filter(e => e.type !== 'goal').map((event, index) => {
                            const isLeft = event.playerId === game.player_left_id;
                            const isSkill = event.type === 'skill';
                            const timePercent = game.duration_seconds ? (event.time / game.duration_seconds) * 100 : 50;
                            const eventClass = isSkill ? 'timeline-skill' : 'timeline-powerup';
                            
                            if (isSkill) {
                                const skill = event.data as SkillUsed;
                                return `
                                    <div class="absolute timeline-event ${eventClass}" style="left: ${timePercent}%; top: 146px; transform: translateX(-50%);">
                                        <div class="flex flex-col items-center">
                                            <!-- Point sur la timeline -->
                                            <div class="w-3 h-3 rounded-full ${skill.was_successful ? 'bg-green-500 border-green-300' : 'bg-red-500 border-red-300'} border-2 shadow-md"></div>
                                            <!-- Ligne vers carte -->
                                            <div class="w-px ${skill.was_successful ? 'bg-green-400/40' : 'bg-red-400/40'}" style="height: 15px;"></div>
                                            <!-- Carte compacte -->
                                            <div class="bg-[#04071A]/95 px-2 py-1 rounded border ${skill.was_successful ? 'border-green-500/30' : 'border-red-500/30'} backdrop-blur-sm shadow-md">
                                                <div class="flex items-center gap-1">
                                                    <span class="text-lg">üí•</span>
                                                    <div class="text-xs ${isLeft ? 'text-blue-300' : 'text-orange-300'} font-semibold whitespace-nowrap">${event.player}</div>
                                                    <span class="text-xs ${skill.was_successful ? 'text-green-400' : 'text-red-400'}">${skill.was_successful ? '‚úì' : '‚úó'}</span>
                                                </div>
                                                <div class="text-xs text-white/40 text-center">${event.time.toFixed(1)}s</div>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            } else {
                                const powerUp = event.data as PowerUpUsed;
                                const powerUpIcon = powerUp.power_up_type === 'split' ? '‚ö°' : 
                                                  powerUp.power_up_type === 'blackout' ? 'üåë' : 'üåÄ';
                                const powerUpColor = powerUp.power_up_type === 'split' ? 'border-yellow-500/30' : 
                                                   powerUp.power_up_type === 'blackout' ? 'border-purple-500/30' : 'border-cyan-500/30';
                                return `
                                    <div class="absolute timeline-event ${eventClass}" style="left: ${timePercent}%; top: 146px; transform: translateX(-50%);">
                                        <div class="flex flex-col items-center">
                                            <!-- Point sur la timeline -->
                                            <div class="w-3 h-3 rounded-full bg-cyan-500 border-2 border-cyan-300 shadow-md"></div>
                                            <!-- Ligne vers carte -->
                                            <div class="w-px bg-cyan-400/40" style="height: 15px;"></div>
                                            <!-- Carte compacte -->
                                            <div class="bg-[#04071A]/95 px-2 py-1 rounded border ${powerUpColor} backdrop-blur-sm shadow-md">
                                                <div class="flex items-center gap-1">
                                                    <span class="text-lg">${powerUpIcon}</span>
                                                    <div class="text-xs ${isLeft ? 'text-blue-300' : 'text-orange-300'} font-semibold whitespace-nowrap">${event.player}</div>
                                                </div>
                                                <div class="text-xs text-white/40 text-center">${event.time.toFixed(1)}s</div>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }
                        }).join('')}
                        
                        <!-- Marqueurs de temps -->
                        <div class="absolute left-0" style="top: 140px; transform: translateY(-50%);">
                            <div class="w-2 h-2 rounded-full bg-white/50"></div>
                        </div>
                        <div class="absolute right-0" style="top: 140px; transform: translateY(-50%);">
                            <div class="w-2 h-2 rounded-full bg-white/50"></div>
                        </div>
                    </div>
                    
                    <!-- Labels de temps -->
                    <div class="flex justify-between text-white/40 text-xs mt-2 px-2">
                        <span>üïê 0:00</span>
                        ${game.duration_seconds ? `<span>üèÅ ${Math.floor(game.duration_seconds / 60)}:${(game.duration_seconds % 60).toString().padStart(2, '0')}</span>` : ''}
                    </div>
                    
                    <!-- L√©gende -->
                    <div class="flex flex-wrap justify-center gap-4 mt-6 text-xs">
                        <div class="flex items-center gap-1">
                            <div class="w-3 h-3 rounded-full bg-blue-500 border border-blue-300"></div>
                            <span class="text-white/60">Goal ${game.player_left_username}</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <div class="w-3 h-3 rounded-full bg-orange-500 border border-orange-300"></div>
                            <span class="text-white/60">Goal ${game.player_right_username}</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="text-lg">üí•</span>
                            <span class="text-white/60">Skill</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="text-lg">‚ö°üåëüåÄ</span>
                            <span class="text-white/60">Power-ups</span>
                        </div>
                    </div>
                    
                    <style>
                        .timeline-event {
                            z-index: 1;
                            transition: opacity 0.3s ease;
                        }
                        .timeline-event:hover {
                            z-index: 100;
                        }
                        .timeline-event:hover > div > div:last-child {
                            transform: scale(1.15);
                            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
                        }
                        .timeline-event.hidden {
                            opacity: 0;
                            pointer-events: none;
                        }
                    </style>
                </div>
            ` : ''}

            ${game.tournament_id ? `
                <div class="mt-6 text-center">
                    <a href="/tournament/${game.tournament_id}" class="inline-block px-6 py-3 bg-purple-500/20 border border-purple-500/40 rounded-lg text-purple-300 hover:bg-purple-500/30 transition-all">
                        ‚Üí Voir le tournoi complet
                    </a>
                </div>
            ` : ''}
        `;

        contentElement.style.display = 'block';

        // Animations d'entr√©e
        gsap.fromTo('#game-content > *', 
            { opacity: 0, y: 20 },
            { 
                opacity: 1, 
                y: 0, 
                duration: 0.6, 
                stagger: 0.1,
                ease: 'power2.out'
            }
        );
    };

    const hideLoading = (): void => {
        const loading = document.getElementById('game-loading');
        if (loading) loading.style.display = 'none';
    };

    const showError = (): void => {
        hideLoading();
        const error = document.getElementById('game-error');
        if (error) error.style.display = 'block';
    };

    // Gestion des filtres de timeline
    const setupTimelineFilters = (): void => {
        const filterButtons = document.querySelectorAll('.timeline-filter');
        
        filterButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const target = e.target as HTMLElement;
                const filter = target.dataset.filter;
                
                if (!filter) return;
                
                // Mettre √† jour les boutons actifs
                filterButtons.forEach(btn => {
                    btn.classList.remove('active', 'bg-white/20', 'border-white/30');
                    btn.classList.add('bg-white/10', 'border-white/20');
                });
                target.classList.add('active', 'bg-white/20', 'border-white/30');
                target.classList.remove('bg-white/10', 'border-white/20');
                
                // Filtrer les √©v√©nements
                const allEvents = document.querySelectorAll('.timeline-event');
                
                allEvents.forEach(event => {
                    event.classList.remove('hidden');
                });
                
                if (filter === 'goals') {
                    document.querySelectorAll('.timeline-skill, .timeline-powerup').forEach(el => {
                        el.classList.add('hidden');
                    });
                } else if (filter === 'skills') {
                    document.querySelectorAll('.timeline-goal, .timeline-powerup').forEach(el => {
                        el.classList.add('hidden');
                    });
                } else if (filter === 'powerups') {
                    document.querySelectorAll('.timeline-goal, .timeline-skill').forEach(el => {
                        el.classList.add('hidden');
                    });
                }
            });
        });
    };

    // Charger les d√©tails
    fetchGameDetails().then(() => {
        // Setup des filtres apr√®s que le contenu soit charg√©
        setTimeout(setupTimelineFilters, 100);
    });

    // Cleanup
    return (): void => {
        // Pas de listeners √† nettoyer pour le moment
    };
};

// ==============================================
// üìÑ ./src/views/GameView.ts
// ==============================================
import type { ViewFunction } from "../router/types";
import { Pong } from "../components/PongGame/PongGame";
import { gsap } from "gsap";

export const GameView: ViewFunction = () => {
	return `
		<!-- Fond avec grille anim√©e -->
		<div class="fixed inset-0 bg-black overflow-hidden">
			<!-- Grille de fond -->
			<div class="absolute inset-0" style="
				background-image: 
					linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
					linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
				background-size: 50px 50px;
				animation: gridMove 20s linear infinite;
			"></div>
			
			<style>
				@keyframes gridMove {
					0% { transform: translateY(0); }
					100% { transform: translateY(50px); }
				}
				
				@keyframes neonPulse {
					0%, 100% { 
						text-shadow: 
							0 0 10px rgba(59, 130, 246, 0.8),
							0 0 20px rgba(59, 130, 246, 0.6),
							0 0 30px rgba(59, 130, 246, 0.4);
					}
					50% { 
						text-shadow: 
							0 0 20px rgba(59, 130, 246, 1),
							0 0 30px rgba(59, 130, 246, 0.8),
							0 0 40px rgba(59, 130, 246, 0.6);
					}
				}
				
				@keyframes scanline {
					0% { transform: translateY(-100%); }
					100% { transform: translateY(100vh); }
				}

				@keyframes glitch {
					0%, 100% { transform: translate(0); }
					20% { transform: translate(-2px, 2px); }
					40% { transform: translate(-2px, -2px); }
					60% { transform: translate(2px, 2px); }
					80% { transform: translate(2px, -2px); }
				}
				
				.pixel-font {
					font-family: 'Courier New', monospace;
					font-weight: bold;
					letter-spacing: 0.1em;
				}
				
				.neon-border {
					box-shadow: 
						0 0 10px rgba(59, 130, 246, 0.5),
						inset 0 0 10px rgba(59, 130, 246, 0.2);
					border: 3px solid rgba(59, 130, 246, 0.8);
				}

				.neon-border-green {
					box-shadow: 
						0 0 10px rgba(34, 197, 94, 0.5),
						inset 0 0 10px rgba(34, 197, 94, 0.2);
					border: 3px solid rgba(34, 197, 94, 0.8);
				}

				.neon-border-red {
					box-shadow: 
						0 0 10px rgba(239, 68, 68, 0.5),
						inset 0 0 10px rgba(239, 68, 68, 0.2);
					border: 3px solid rgba(239, 68, 68, 0.8);
				}

				.game-hud {
					background: rgba(4, 7, 26, 0.85);
					backdrop-filter: blur(10px);
				}

				.player-info {
					transition: all 0.3s ease;
				}

				.player-info:hover {
					transform: translateY(-2px);
				}

				#pong-canvas {
					box-shadow: 
						0 0 30px rgba(59, 130, 246, 0.4),
						0 0 60px rgba(59, 130, 246, 0.2),
						inset 0 0 30px rgba(59, 130, 246, 0.1);
					border: 3px solid rgba(59, 130, 246, 0.6);
				}

				.action-button {
					transition: all 0.2s ease;
					position: relative;
					overflow: hidden;
				}

				.action-button::before {
					content: '';
					position: absolute;
					top: 50%;
					left: 50%;
					width: 0;
					height: 0;
					border-radius: 50%;
					background: rgba(255, 255, 255, 0.1);
					transform: translate(-50%, -50%);
					transition: width 0.6s, height 0.6s;
				}

				.action-button:hover::before {
					width: 300px;
					height: 300px;
				}

				.action-button:active {
					transform: scale(0.95);
				}

				.forfeit-button:hover {
					box-shadow: 
						0 0 20px rgba(239, 68, 68, 0.6),
						inset 0 0 20px rgba(239, 68, 68, 0.3);
				}

				.status-indicator {
					animation: neonPulse 2s ease-in-out infinite;
				}

				.game-container {
					animation: fadeIn 0.8s ease-out;
				}

				@keyframes fadeIn {
					from { opacity: 0; transform: scale(0.95); }
					to { opacity: 1; transform: scale(1); }
				}

				.corner-decoration {
					position: absolute;
					width: 20px;
					height: 20px;
				}

				.corner-decoration-blue {
					border: 2px solid rgba(59, 130, 246, 0.5);
				}

				.corner-decoration-green {
					border: 2px solid rgba(34, 197, 94, 0.5);
				}

				.corner-decoration-red {
					border: 2px solid rgba(239, 68, 68, 0.5);
				}

				.corner-tl { top: -2px; left: -2px; border-right: none; border-bottom: none; }
				.corner-tr { top: -2px; right: -2px; border-left: none; border-bottom: none; }
				.corner-bl { bottom: -2px; left: -2px; border-right: none; border-top: none; }
				.corner-br { bottom: -2px; right: -2px; border-left: none; border-top: none; }

				.stat-good { color: #4ade80; }
				.stat-medium { color: #fbbf24; }
				.stat-bad { color: #ef4444; }
			</style>
			
			<!-- Scanline effect -->
			<div class="absolute inset-0 pointer-events-none opacity-10">
				<div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
			</div>

			<!-- Particules flottantes -->
			${Array.from({length: 30}, (_, i) => `
				<div 
					class="absolute bg-blue-400 rounded-full opacity-20"
					style="
						width: ${2 + Math.random() * 3}px;
						height: ${2 + Math.random() * 3}px;
						left: ${Math.random() * 100}%;
						top: ${Math.random() * 100}%;
						animation: float ${10 + Math.random() * 20}s ease-in-out ${Math.random() * 5}s infinite;
					"
				></div>
			`).join('')}

			<style>
				@keyframes float {
					0%, 100% { transform: translateY(0) translateX(0); }
					25% { transform: translateY(-20px) translateX(10px); }
					50% { transform: translateY(-10px) translateX(-10px); }
					75% { transform: translateY(-30px) translateX(5px); }
				}
			</style>
		</div>

		<!-- Contenu principal -->
		<div class="relative z-10 min-h-screen flex flex-col game-container">
			
			<!-- Header HUD -->
			<div class="game-hud border-b border-white/10">
				<div class="container mx-auto px-4 py-4">
					<div class="flex items-center justify-between">
						
						<!-- Left: Back button -->
						<button 
							onclick="history.back()" 
							class="action-button pixel-font px-4 py-2 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all text-sm"
							id="back-button"
						>
							<span class="relative z-10">‚Üê EXIT</span>
						</button>

						<!-- Center: Status indicator -->
						<div class="flex items-center gap-3">
							<div id="connection-indicator" class="status-indicator w-3 h-3 bg-green-400 rounded-full"></div>
							<span class="pixel-font text-sm text-blue-300">
								LIVE MATCH
							</span>
						</div>

						<!-- Right: Forfeit button (si pas mode local) -->
						<button 
							id="forfeit-btn"
							class="action-button forfeit-button pixel-font px-4 py-2 neon-border-red bg-red-500/10 text-red-400 hover:bg-red-500/20 transition-all text-sm relative z-10"
						>
							<span class="relative z-10">üè≥Ô∏è SURRENDER</span>
						</button>
					</div>
				</div>
			</div>

			<!-- Game Area -->
			<div class="flex-1 flex items-center justify-center px-4 py-8">
				<div class="w-full max-w-[95vw]">
					
					<!-- Players Info Bar -->
					<div class="mb-6 grid grid-cols-3 gap-4 items-center">
						
						<!-- Player Left -->
						<div class="player-info neon-border bg-blue-500/5 backdrop-blur-sm rounded-lg p-4 relative">
							<div class="corner-decoration corner-decoration-blue corner-tl"></div>
							<div class="corner-decoration corner-decoration-blue corner-bl"></div>
							
							<div class="flex items-center gap-3">
								<div class="w-12 h-12 rounded-full bg-blue-500/20 flex items-center justify-center border-2 border-blue-500/50">
									<!-- PP du player -->
								</div>
								<div class="flex-1">
									<div id="player-left-name" class="pixel-font text-lg text-blue-500 mb-1">
										Player 1
									</div>
									<div class="flex items-center gap-2">
										<div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
										<span class="pixel-font text-xs text-blue-300/60">READY</span>
									</div>
								</div>
							</div>
						</div>

						<!-- Center: VS -->
						<div class="text-center">
							<div class="inline-block neon-border bg-blue-500/10 backdrop-blur-sm rounded-lg px-6 py-3">
								<span class="pixel-font text-3xl text-blue-400" style="animation: neonPulse 2s ease-in-out infinite;">
									VS
								</span>
							</div>
						</div>

						<!-- Player Right -->
						<div class="player-info neon-border-red bg-red-500/5 backdrop-blur-sm rounded-lg p-4 relative">
							<div class="corner-decoration corner-decoration-red corner-tr"></div>
							<div class="corner-decoration corner-decoration-red corner-br"></div>
							
							<div class="flex items-center gap-3 justify-end">
								<div class="flex-1 text-right">
									<div id="player-right-name" class="pixel-font text-lg text-red-400 mb-1">
										Player 2
									</div>
									<div class="flex items-center gap-2 justify-end">
										<span class="pixel-font text-xs text-red-300/60">READY</span>
										<div class="w-2 h-2 bg-red-400 rounded-full animate-pulse"></div>
									</div>
								</div>
								<div class="w-12 h-12 rounded-full bg-red-500/20 flex items-center justify-center border-2 border-red-500/50">
									<!-- PP du player -->
								</div>
							</div>
						</div>
					</div>

					<!-- Canvas Container avec decorations -->
					<div class="relative">
						<!-- Corner decorations for canvas -->
						<div class="absolute -top-3 -left-3 w-8 h-8 border-l-2 border-t-2 border-blue-400/50"></div>
						<div class="absolute -top-3 -right-3 w-8 h-8 border-r-2 border-t-2 border-blue-400/50"></div>
						<div class="absolute -bottom-3 -left-3 w-8 h-8 border-l-2 border-b-2 border-blue-400/50"></div>
						<div class="absolute -bottom-3 -right-3 w-8 h-8 border-r-2 border-b-2 border-blue-400/50"></div>

						<!-- Pong Game Component -->
						<div data-component="pong-game">
							<canvas id="pong-canvas"></canvas>
						</div>
					</div>

					<!-- Controls Info -->
					<div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
						
						<!-- Left Player Controls -->
						<div class="neon-border bg-blue-500/5 backdrop-blur-sm rounded-lg p-4">
							<div class="pixel-font text-sm text-blue-300 mb-3 flex items-center gap-2">
								<span>PLAYER 1 CONTROLS</span>
							</div>
							<div class="space-y-2 pixel-font text-xs text-blue-300/60">
								<div class="flex items-center gap-2">
									<kbd class="px-2 py-1 bg-blue-500/20 rounded border border-blue-500/30">W</kbd>
									<kbd class="px-2 py-1 bg-blue-500/20 rounded border border-blue-500/30">S</kbd>
									<span>Move paddle</span>
								</div>
								<div class="flex items-center gap-2">
									<kbd class="px-3 py-1 bg-blue-500/20 rounded border border-blue-500/30">SPACE</kbd>
									<span>Use skill</span>
								</div>
								<div class="flex items-center gap-2">
									<kbd class="px-2 py-1 bg-blue-500/20 rounded border border-blue-500/30">P</kbd>
									<kbd class="px-2 py-1 bg-blue-500/20 rounded border border-blue-500/30">ESC</kbd>
									<span>Pause</span>
								</div>
							</div>
						</div>

						<!-- Right Player Controls -->
						<div class="neon-border bg-red-500/5 backdrop-blur-sm rounded-lg p-4">
							<div class="pixel-font text-sm text-red-300 mb-3 flex items-center gap-2 justify-end">
								<span>PLAYER 2 CONTROLS</span>
							</div>
							<div class="space-y-2 pixel-font text-xs text-red-300/60 text-right">
								<div class="flex items-center gap-2 justify-end">
									<span>Move paddle</span>
									<kbd class="px-2 py-1 bg-red-500/20 rounded border border-red-500/30">‚Üë</kbd>
									<kbd class="px-2 py-1 bg-red-500/20 rounded border border-red-500/30">‚Üì</kbd>
								</div>
								<div class="flex items-center gap-2 justify-end">
									<span>Use skill</span>
									<kbd class="px-3 py-1 bg-red-500/20 rounded border border-red-500/30">ENTER</kbd>
								</div>
								<div class="flex items-center gap-2 justify-end">
									<span>Pause</span>
									<kbd class="px-2 py-1 bg-red-500/20 rounded border border-red-500/30">P</kbd>
									<kbd class="px-2 py-1 bg-red-500/20 rounded border border-red-500/30">ESC</kbd>
								</div>
							</div>
						</div>
					</div>

					<!-- Power-ups Legend -->
					<div class="mt-4 neon-border bg-green-300/5 backdrop-blur-sm rounded-lg p-4">
						<div class="pixel-font text-sm text-green-300 mb-3 text-center">
							‚ö° POWER-UPS LEGEND
						</div>
						<div class="grid grid-cols-3 gap-4 pixel-font text-xs text-green-300/60">
							<div class="text-center">
								<div class="text-2xl mb-1">‚ö°</div>
								<div>SPLIT</div>
								<div class="text-green-300/40 text-[10px]">Duplicate ball</div>
							</div>
							<div class="text-center">
								<div class="text-2xl mb-1">üåë</div>
								<div>BLACKOUT</div>
								<div class="text-green-300/40 text-[10px]">Blind opponent</div>
							</div>
							<div class="text-center">
								<div class="text-2xl mb-1">üåÄ</div>
								<div>BLACKHOLE</div>
								<div class="text-green-300/40 text-[10px]">Gravity pull</div>
							</div>
						</div>
					</div>
				</div>
			</div>

			<!-- Footer HUD avec vraies stats -->
			<div class="game-hud border-t border-white/10">
				<div class="container mx-auto px-4 py-3">
					<div class="flex items-center justify-center gap-8 pixel-font text-xs text-blue-300/60">
						<div class="flex items-center gap-2">
							<div id="ws-indicator" class="w-2 h-2 bg-gray-400 rounded-full"></div>
							<span id="connection-status">CONNECTION: CONNECTING...</span>
						</div>
						<div>|</div>
						<div>PING: <span id="ping-value" class="stat-medium">--ms</span></div>
						<div>|</div>
						<div>FPS: <span id="fps-value" class="stat-good">--</span></div>
					</div>
				</div>
			</div>
		</div>
	`;
};

// ==============================================
// üìÑ ./src/views/TournamentView.ts
// ==============================================
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";

export const TournamentView: ViewFunction = () => {
    return `
        <!-- Fond avec grille anim√©e -->
        <div class="fixed inset-0 bg-black overflow-hidden">
            <!-- Grille de fond -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
                background-size: 50px 50px;
                animation: gridMove 20s linear infinite;
            "></div>
            
            <style>
                @keyframes gridMove {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(50px); }
                }
                
                @keyframes neonPulse {
                    0%, 100% { 
                        text-shadow: 
                            0 0 10px rgba(59, 130, 246, 0.8),
                            0 0 20px rgba(59, 130, 246, 0.6),
                            0 0 30px rgba(59, 130, 246, 0.4);
                    }
                    50% { 
                        text-shadow: 
                            0 0 20px rgba(59, 130, 246, 1),
                            0 0 30px rgba(59, 130, 246, 0.8),
                            0 0 40px rgba(59, 130, 246, 0.6);
                    }
                }
                
                @keyframes scanline {
                    0% { transform: translateY(-100%); }
                    100% { transform: translateY(100vh); }
                }
                
                .pixel-font {
                    font-family: 'Courier New', monospace;
                    font-weight: bold;
                    letter-spacing: 0.1em;
                }
                
                .neon-border {
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    border: 3px solid rgba(59, 130, 246, 0.8);
                }
                
                .neon-border:hover {
                    box-shadow: 
                        0 0 20px rgba(59, 130, 246, 0.8),
                        inset 0 0 20px rgba(59, 130, 246, 0.3);
                    border-color: rgba(59, 130, 246, 1);
                }

                .tournament-card {
                    transition: all 0.3s ease;
                    background: rgba(15, 23, 42, 0.6);
                    backdrop-filter: blur(10px);
                    cursor: pointer;
                }

                .tournament-card:hover:not(.disabled) {
                    transform: translateY(-5px) scale(1.02);
                    background: rgba(30, 41, 59, 0.8);
                }

                .tournament-card.disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }

                .neon-input {
                    background: rgba(15, 23, 42, 0.6);
                    border: 2px solid rgba(59, 130, 246, 0.5);
                    color: #60A5FA;
                    transition: all 0.3s ease;
                }
                
                .neon-input:focus {
                    outline: none;
                    border-color: rgba(59, 130, 246, 1);
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    background: rgba(15, 23, 42, 0.8);
                }
                
                .neon-input::placeholder {
                    color: rgba(96, 165, 250, 0.4);
                }

                .countdown-modal {
                    backdrop-filter: blur(10px);
                }
            </style>
            
            <!-- Scanline effect -->
            <div class="absolute inset-0 pointer-events-none opacity-10">
                <div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
            </div>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header avec BackButton et Sign in -->
            <header class="flex justify-between items-center px-8 py-6">
                <button 
                    onclick="history.back()" 
                    class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
                    id="back-button"
                >
                    ‚Üê BACK
                </button>
                
                <!-- Bouton Sign in -->
                <a href="/login" 
                   class="pixel-font bg-blue-500 text-black px-6 py-3 text-sm md:text-base hover:bg-blue-400 transition-all neon-border flex items-center gap-2">
                    <span>SIGN IN</span>
                </a>
            </header>

            <!-- Zone centrale -->
            <div class="flex-1 flex items-center justify-center px-4 py-12">
                <div class="w-full max-w-4xl">
                    
					<!-- Titre principal -->
					<div class="text-center mb-12">
						<h1 class="pixel-font text-6xl md:text-8xl text-blue-400 mb-4" 
							style="animation: neonPulse 2s ease-in-out infinite;"
							id="tournament-title">
							TOURNAMENT
						</h1>
						<p class="pixel-font text-lg md:text-xl text-blue-300 tracking-wider">
							>>> SKILL ISSUE <<<
						</p>
					</div>

                    <!-- Input Username -->
                    <div class="mb-8 neon-border bg-black/50 backdrop-blur-sm rounded-lg p-6" id="username-section">
                        <label for="usernameInput" class="block mb-3 pixel-font text-sm text-blue-300 text-center">
                            ENTER YOUR USERNAME:
                        </label>
                        <input 
                            type="text" 
                            name="username" 
                            id="usernameInput" 
                            value="Anon"
                            maxlength="20"
                            class="w-full p-3 rounded pixel-font text-center text-lg neon-input"
                            placeholder="Your username..."
                        />
                    </div>

                    <!-- Cartes de tournois -->
					<div class="grid grid-cols-1 md:grid-cols-3 gap-6" id="tournament-cards">
						<!-- 4 Players -->
						<div 
							class="tournament-card neon-border rounded-lg p-8 relative flex flex-col items-center"
							data-component="joinTournament"
							data-slots="4"
							data-tournament-id=""
							id="tournament-4"
						>
							<!-- Badge de statut -->
							<div class="absolute top-4 right-4 pixel-font text-xs text-green-400 bg-green-500/20 px-3 py-1 rounded border border-green-500/50">
								OPEN
							</div>

							<!-- Ic√¥ne -->
							<div class="text-6xl md:text-7xl mb-6 text-blue-500">
								‚ö°
							</div>
							
							<!-- Titre -->
							<h3 class="pixel-font text-4xl text-blue-400 mb-2">
								4
							</h3>
							<p class="pixel-font text-sm text-blue-300 mb-6 opacity-80">
								PLAYERS
							</p>
							
							<!-- Compteur -->
							<div class="mb-6">
								<span class="pixel-font text-3xl text-yellow-400" data-player-count>0/4</span>
							</div>

							<!-- Description -->
							<p class="pixel-font text-xs text-blue-300/60 text-center mb-8">
								Quick bracket - 2 rounds
							</p>

							<!-- Fl√®ches d√©coratives sym√©triques -->
							<div class="absolute bottom-4 left-0 right-0 flex justify-between px-4">
								<span class="text-red-500 text-2xl opacity-50">‚Üê</span>
								<span class="text-red-500 text-2xl opacity-50">‚Üí</span>
							</div>
						</div>

						<!-- 8 Players -->
						<div 
							class="tournament-card neon-border rounded-lg p-8 relative flex flex-col items-center"
							data-component="joinTournament"
							data-slots="8"
							data-tournament-id=""
							id="tournament-8"
						>
							<!-- Badge de statut -->
							<div class="absolute top-4 right-4 pixel-font text-xs text-green-400 bg-green-500/20 px-3 py-1 rounded border border-green-500/50">
								OPEN
							</div>

							<!-- Ic√¥ne -->
							<div class="text-6xl md:text-7xl mb-6 text-blue-500">
								‚ö°
							</div>
							
							<!-- Titre -->
							<h3 class="pixel-font text-4xl text-blue-400 mb-2">
								8
							</h3>
							<p class="pixel-font text-sm text-blue-300 mb-6 opacity-80">
								PLAYERS
							</p>
							
							<!-- Compteur -->
							<div class="mb-6">
								<span class="pixel-font text-3xl text-yellow-400" data-player-count>0/8</span>
							</div>

							<!-- Description -->
							<p class="pixel-font text-xs text-blue-300/60 text-center mb-8">
								Standard bracket - 3 rounds
							</p>

							<!-- Fl√®ches d√©coratives sym√©triques -->
							<div class="absolute bottom-4 left-0 right-0 flex justify-between px-4">
								<span class="text-blue-500 text-2xl opacity-80">‚Üê</span>
								<span class="text-blue-500 text-2xl opacity-80">‚Üí</span>
							</div>
						</div>

						<!-- 16 Players -->
						<div 
							class="tournament-card neon-border rounded-lg p-8 relative flex flex-col items-center"
							data-component="joinTournament"
							data-slots="16"
							data-tournament-id=""
							id="tournament-16"
						>
							<!-- Badge de statut -->
							<div class="absolute top-4 right-4 pixel-font text-xs text-green-400 bg-green-500/20 px-3 py-1 rounded border border-green-500/50">
								OPEN
							</div>

							<!-- Ic√¥ne -->
							<div class="text-6xl md:text-7xl mb-6 text-blue-500">
								‚ö°
							</div>
							
							<!-- Titre -->
							<h3 class="pixel-font text-4xl text-blue-400 mb-2">
								16
							</h3>
							<p class="pixel-font text-sm text-blue-300 mb-6 opacity-80">
								PLAYERS
							</p>
							
							<!-- Compteur -->
							<div class="mb-6">
								<span class="pixel-font text-3xl text-yellow-400" data-player-count>0/16</span>
							</div>

							<!-- Description -->
							<p class="pixel-font text-xs text-blue-300/60 text-center mb-8">
								Epic bracket - 4 rounds
							</p>

							<!-- Fl√®ches d√©coratives sym√©triques -->
							<div class="absolute bottom-4 left-0 right-0 flex justify-between px-4">
								<span class="text-red-500 text-2xl opacity-50">‚Üê</span>
								<span class="text-red-500 text-2xl opacity-50">‚Üí</span>
							</div>
						</div>
					</div>


                </div>
            </div>

            <!-- Footer -->
            <footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
                <p>¬© 2025 PONG - SKILL ISSUE</p>
            </footer>
        </div>

        <!-- Modal de countdown (cach√© par d√©faut) -->
        <div id="countdown" class="fixed inset-0 bg-black/80 countdown-modal hidden flex items-center justify-center z-50">
            <div class="neon-border bg-black/90 backdrop-blur-sm rounded-lg p-12 text-center">
                <h2 class="pixel-font text-3xl text-blue-400 mb-6">
                    TOURNAMENT IS STARTING...
                </h2>
                <div id="countdown-text" class="pixel-font text-8xl text-pink-500 mb-4" style="animation: neonPulse 1s ease-in-out infinite;">
                    3
                </div>
                <p class="pixel-font text-sm text-blue-300/60">
                    Get ready for battle!
                </p>
            </div>
        </div>
    `;
};

export const tournamentLogic = (): CleanupFunction => {
    console.log('üéÆ TournamentView: Initializing...');

    const tournamentBtns = document.querySelectorAll('[data-component="joinTournament"]');
    const usernameInput = document.getElementById("usernameInput") as HTMLInputElement;
    
    let pollInterval: number | null = null;
    let currentTournamentId: string | null = null;
    let countdownInterval: number | null = null;

    // ‚úÖ Forcer les pointer-events sur les cartes IMM√âDIATEMENT
    tournamentBtns.forEach(btn => {
        (btn as HTMLElement).style.pointerEvents = 'auto';
        (btn as HTMLElement).style.cursor = 'pointer';
        (btn as HTMLElement).style.position = 'relative';
        (btn as HTMLElement).style.zIndex = '10';
    });

    // Animations d'entr√©e
    gsap.fromTo('#tournament-title', 
        { scale: 0.5, opacity: 0 },
        { scale: 1, opacity: 1, duration: 1, ease: 'back.out(1.7)' }
    );

    gsap.fromTo('#username-section', 
        { y: 50, opacity: 0 },
        { y: 0, opacity: 1, duration: 0.8, delay: 0.3, ease: 'power2.out' }
    );

    gsap.fromTo('.tournament-card', 
        { y: 100, opacity: 0 },
        { 
            y: 0, 
            opacity: 1, 
            duration: 1, 
            stagger: 0.2, 
            delay: 0.5, 
            ease: 'power3.out',
            onComplete: () => {
                // ‚úÖ Re-forcer apr√®s animation
                tournamentBtns.forEach(btn => {
                    (btn as HTMLElement).style.pointerEvents = 'auto';
                    (btn as HTMLElement).style.cursor = 'pointer';
                });
            }
        }
    );

    // ‚úÖ Fonction pour nettoyer tous les intervals
    const cleanupIntervals = () => {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
            console.log('üßπ Polling interval cleared');
        }
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            console.log('üßπ Countdown interval cleared');
        }
    };

    // Fonction pour r√©cup√©rer et mettre √† jour les tournois
    const fetchTournaments = async () => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/tournamentback/tournaments`);
            const data = await response.json();

            if (data.success) {
                tournamentBtns.forEach(btn => {
                    const countSpan = btn.querySelector("[data-player-count]");
                    const badge = btn.querySelector('.absolute.top-3.right-3');
                    const slots = btn.getAttribute('data-slots');
                    
                    data.registrations.forEach((tournament: any) => {
                        if (tournament.name === slots + 'p') {
                            if (countSpan) {
                                countSpan.textContent = `${tournament.currentPlayerCount}/${slots}`;
                            }
                            btn.setAttribute("data-tournament-id", tournament.id);
                            
                            // D√©sactiver si plein
                            if (tournament.currentPlayerCount >= parseInt(slots || '0')) {
                                btn.classList.add('disabled');
                                (btn as HTMLElement).style.cursor = 'not-allowed';
                                if (badge) {
                                    badge.textContent = 'FULL';
                                    badge.classList.remove('bg-green-500/20', 'border-green-500/50', 'text-green-400');
                                    badge.classList.add('bg-red-500/20', 'border-red-500/50', 'text-red-400');
                                }
                            } else {
                                btn.classList.remove('disabled');
                                (btn as HTMLElement).style.cursor = 'pointer';
                                (btn as HTMLElement).style.pointerEvents = 'auto';
                                if (badge) {
                                    badge.textContent = 'OPEN';
                                    badge.classList.remove('bg-red-500/20', 'border-red-500/50', 'text-red-400');
                                    badge.classList.add('bg-green-500/20', 'border-green-500/50', 'text-green-400');
                                }
                            }
                        }
                    });
                });
            }
        } catch (err) {
            console.error('Error fetching tournaments:', err);
        }
    };

    // Polling pour v√©rifier si le tournoi a d√©marr√©
    const startPollingForStart = (tournamentId: string) => {
        // ‚úÖ Nettoyer l'ancien polling avant d'en cr√©er un nouveau
        if (pollInterval) {
            clearInterval(pollInterval);
        }

        pollInterval = setInterval(async () => {
            try {
                const host = import.meta.env.VITE_HOST || 'localhost:8443';
                const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}`);
                const data = await response.json();

                if (data.success && data.tournament.status === 'in_progress') {
                    cleanupIntervals(); // ‚úÖ Nettoyer avant de continuer
                    startCountdownAndRedirect(tournamentId);
                }
            } catch (err) {
                console.error('Error polling tournament status:', err);
            }
        }, 1000);
        
        console.log('üîÑ Started polling for tournament start');
    };

    // Countdown avant redirection
    const startCountdownAndRedirect = (tournamentId: string): void => {
        const countdownModal = document.getElementById('countdown');
        const countdownText = document.getElementById('countdown-text');
        
        if (!countdownModal || !countdownText) return;

        let count = 3;
        countdownModal.classList.remove('hidden');
        countdownModal.classList.add('flex');
        countdownText.textContent = count.toString();

        // Animation du modal
        gsap.from(countdownModal.querySelector('.neon-border'), {
            scale: 0.5,
            opacity: 0,
            duration: 0.5,
            ease: 'back.out(1.7)'
        });

        // ‚úÖ Nettoyer l'ancien countdown avant d'en cr√©er un nouveau
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }

        countdownInterval = setInterval(() => {
            count--;
            
            if (count > 0) {
                countdownText.textContent = count.toString();
                // Animation du chiffre
                gsap.fromTo(countdownText, 
                    { scale: 1.5, opacity: 0 },
                    { scale: 1, opacity: 1, duration: 0.5, ease: 'back.out' }
                );
            } else {
                cleanupIntervals(); // ‚úÖ Nettoyer avant redirect
                countdownModal.classList.add('hidden');
                countdownModal.classList.remove('flex');
                window.router.navigate(`/tournament/${tournamentId}`);
            }
        }, 1000);
        
        console.log('‚è±Ô∏è Countdown started');
    };

    // Fonction pour rejoindre un tournoi
    const handleJoinTournament = async (e: Event) => {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('üéØ Tournament card clicked!');
        
        const target = e.currentTarget as HTMLElement;
        
        // V√©rifier si le tournoi est plein
        if (target.classList.contains('disabled')) {
            console.log('‚ùå Tournament is full');
            return;
        }

        const username = usernameInput.value.trim() || 'Anon';
        window.simpleAuth.setUsername(username);
        
        const tournamentId = target.getAttribute('data-tournament-id');

        if (!tournamentId) {
            console.error('No tournament ID found');
            return;
        }

        currentTournamentId = tournamentId;

        // Animation du clic
        gsap.to(target, {
            scale: 0.95,
            duration: 0.1,
            yoyo: true,
            repeat: 1
        });

        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const playerId = window.simpleAuth.getPlayerId();
            
            const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}/join`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, playerId })
            });

            const data = await response.json();

            if (data.success) {
                if (data.tournamentStarted) {
                    // Le tournoi d√©marre imm√©diatement
                    startCountdownAndRedirect(data.tournamentId);
                } else {
                    // En attente d'autres joueurs
                    console.log(`‚úÖ Joined tournament: ${data.currentPlayers}/${data.maxPlayers} players`);
                    startPollingForStart(tournamentId);
                }
            } else {
                alert(data.error || 'Failed to join tournament');
            }
        } catch (err) {
            console.error('Error joining tournament:', err);
            alert('Failed to join tournament');
        }
    };

    // ‚úÖ Stocker les handlers pour pouvoir les retirer
    const handlers = new Map<Element, EventListener>();

    // Attacher les event listeners
    tournamentBtns.forEach(tournamentBtn => {
        const handler = handleJoinTournament as EventListener;
        tournamentBtn.addEventListener("click", handler, { capture: true });
        handlers.set(tournamentBtn, handler);
    });

    // Polling initial et r√©gulier pour les stats
    fetchTournaments();
    const updateInterval = setInterval(fetchTournaments, 2000);
    console.log('üîÑ Started tournament stats polling');

    // ‚úÖ FONCTION DE CLEANUP COMPL√àTE
    return (): void => {
        console.log('üßπ TournamentView: Cleaning up...');

        // 1. Nettoyer tous les intervals
        cleanupIntervals();
        
        if (updateInterval) {
            clearInterval(updateInterval);
            console.log('üßπ Update interval cleared');
        }

        // 2. Retirer tous les event listeners
        handlers.forEach((handler, element) => {
            element.removeEventListener("click", handler, { capture: true });
        });
        handlers.clear();
        console.log('üßπ Event listeners removed');

        // 3. Se d√©sinscrire du tournoi si on quitte la page
        if (currentTournamentId) {
            const playerId = window.simpleAuth.getPlayerId();
            if (playerId) {
                const host = import.meta.env.VITE_HOST || 'localhost:8443';
                fetch(`https://${host}/tournamentback/tournaments/leave/${playerId}`, {
                    method: 'DELETE'
                }).catch(err => console.error('Error leaving tournament:', err));
                console.log('üö™ Left tournament');
            }
        }

        console.log('‚úÖ TournamentView: Cleanup complete');
    };
};

// ==============================================
// üìÑ ./src/views/HistoryView.ts
// ==============================================
import type { ViewFunction } from "../router/types";
import { BackButton } from "../components/Button";
import { gsap } from "gsap";

interface GameHistory {
    id: string;
    room_id: string;
    game_type: 'quickplay' | 'tournament';
    player_left_username: string;
    player_right_username: string;
    winner_username?: string;
    score_left: number;
    score_right: number;
    end_reason?: 'score' | 'timeout' | 'forfeit';
    created_at: string;
    duration_seconds?: number;
    tournament_id?: string;
}

export const HistoryView: ViewFunction = () => {
    return `
        <!-- Fond √©toil√© -->
        <div class="fixed inset-0 bg-[#04071A] overflow-hidden">
            ${Array.from({length: 150}, (_, i) => `
                <div 
                    class="absolute bg-white rounded-full ${i % 7 === 0 ? 'animate-pulse' : ''}"
                    style="
                        width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                        height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        opacity: ${0.3 + Math.random() * 0.7};
                        ${i % 7 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
                    "
                ></div>
            `).join('')}
            
            <!-- √âtoiles qui scintillent fort -->
            ${Array.from({length: 50}, (_) => `
                <div 
                    class="absolute"
                    style="
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        animation: strong-sparkle ${4 + Math.random() * 3}s ease-in-out ${Math.random() * 10}s infinite;
                    "
                >
                    <div class="w-[4px] h-[4px] bg-white rounded-full"></div>
                </div>
            `).join('')}
            
            <style>
                @keyframes strong-sparkle {
                    0%, 100% {
                        opacity: 0.3;
                        filter: blur(0px);
                    }
                    50% {
                        opacity: 1;
                        filter: blur(0px) drop-shadow(0 0 10px white) drop-shadow(0 0 20px white);
                    }
                }
            </style>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen">
            <!-- Header avec BackButton -->
            <div class="p-8">
                ${BackButton({
                    size: "lg",
                    className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
                })}
            </div>

            <!-- Container principal -->
            <div class="container mx-auto px-8 pb-8">
                <!-- Titre -->
                <div class="text-center mb-8">
                    <h1 class="text-5xl font-bold text-white mb-2">Historique Global</h1>
                    <p class="text-white/60 text-lg">Toutes les parties jou√©es</p>
                </div>

                <!-- Filtres -->
                <div class="bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6 mb-6">
                    <div class="flex flex-wrap gap-4 items-center justify-between">
                        <div class="flex gap-4">
                            <button 
                                id="filter-all" 
                                class="filter-btn active px-6 py-2 rounded-lg bg-white/10 border border-white/20 text-white hover:bg-white/20 transition-all"
                                data-filter="all"
                            >
                                Toutes
                            </button>
                            <button 
                                id="filter-quickplay" 
                                class="filter-btn px-6 py-2 rounded-lg bg-white/10 border border-white/20 text-white hover:bg-white/20 transition-all"
                                data-filter="quickplay"
                            >
                                QuickPlay
                            </button>
                            <button 
                                id="filter-tournament" 
                                class="filter-btn px-6 py-2 rounded-lg bg-white/10 border border-white/20 text-white hover:bg-white/20 transition-all"
                                data-filter="tournament"
                            >
                                Tournois
                            </button>
                        </div>
                        
                        <div class="flex gap-4 items-center">
                            <span class="text-white/60">Trier par:</span>
                            <select 
                                id="sort-select" 
                                class="px-4 py-2 rounded-lg bg-[#101C69]/40 border border-white/20 text-white focus:outline-none focus:ring-2 focus:ring-white/50"
                            >
                                <option value="recent">Plus r√©cent</option>
                                <option value="oldest">Plus ancien</option>
                                <option value="duration">Dur√©e</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Stats globales -->
                <div id="global-stats" class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                    <!-- Stats seront inject√©es ici -->
                </div>

                <!-- Loading state -->
                <div id="history-loading" class="text-center py-12">
                    <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
                    <p class="text-white/60 mt-4">Chargement de l'historique...</p>
                </div>

                <!-- Liste des parties -->
                <div id="history-list" style="display: none;" class="space-y-4">
                    <!-- Les parties seront inject√©es ici -->
                </div>

                <!-- Empty state -->
                <div id="history-empty" style="display: none;" class="text-center py-12">
                    <div class="text-6xl mb-4">üéÆ</div>
                    <h3 class="text-2xl font-bold text-white mb-2">Aucune partie trouv√©e</h3>
                    <p class="text-white/60">Commencez √† jouer pour voir votre historique !</p>
                </div>

                <!-- Error state -->
                <div id="history-error" style="display: none;" class="text-center py-12">
                    <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                    <h3 class="text-2xl font-bold text-red-400 mb-2">Erreur de chargement</h3>
                    <p class="text-white/60">Impossible de charger l'historique</p>
                </div>
            </div>
        </div>
    `;
};

export const historyLogic = (): (() => void) => {
    let allGames: GameHistory[] = [];
    let filteredGames: GameHistory[] = [];
    let currentFilter: 'all' | 'quickplay' | 'tournament' = 'all';
    let currentSort: 'recent' | 'oldest' | 'duration' = 'recent';

    // Fonction pour r√©cup√©rer l'historique global
    const fetchHistory = async (): Promise<void> => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/gamedb/games/history`);
            
            if (!response.ok) {
                throw new Error('Failed to fetch history');
            }

            const data = await response.json();
            
            if (data.success) {
                allGames = data.games;
				console.log(allGames)
                applyFiltersAndSort();
                displayGames();
                displayGlobalStats();
                hideLoading();
            } else {
                showError();
            }
        } catch (err) {
            console.error('Error fetching history:', err);
            showError();
        }
    };

    // Appliquer les filtres et le tri
    const applyFiltersAndSort = (): void => {
        // Filtrer
        if (currentFilter === 'all') {
            filteredGames = [...allGames];
        } else {
            filteredGames = allGames.filter(game => game.game_type === currentFilter);
        }

        // Trier
        switch (currentSort) {
            case 'recent':
                filteredGames.sort((a, b) => 
                    new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
                );
                break;
            case 'oldest':
                filteredGames.sort((a, b) => 
                    new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
                );
                break;
            case 'duration':
                filteredGames.sort((a, b) => 
                    (b.duration_seconds || 0) - (a.duration_seconds || 0)
                );
                break;
        }
    };

    // Afficher les parties
    const displayGames = (): void => {
        const listElement = document.getElementById('history-list');
        const emptyElement = document.getElementById('history-empty');
        
        if (!listElement || !emptyElement) return;

        if (filteredGames.length === 0) {
            listElement.style.display = 'none';
            emptyElement.style.display = 'block';
            return;
        }

        listElement.style.display = 'block';
        emptyElement.style.display = 'none';

        listElement.innerHTML = filteredGames.map(game => {
            const isWinner = game.score_left > game.score_right;
            const isDraw = game.score_left === game.score_right;
            const resultIcon = isWinner ? 'üèÜ' : isDraw ? 'ü§ù' : 'üíÄ';
            const winnerName = game.winner_username || (isWinner ? game.player_left_username : game.player_right_username);

            const date = new Date(game.created_at);
            const formattedDate = date.toLocaleDateString('fr-FR', {
                day: '2-digit',
                month: 'short',
                year: 'numeric'
            });
            const formattedTime = date.toLocaleTimeString('fr-FR', {
                hour: '2-digit',
                minute: '2-digit'
            });

            const duration = game.duration_seconds 
                ? `${Math.floor(game.duration_seconds / 60)}:${(game.duration_seconds % 60).toString().padStart(2, '0')}`
                : '-';

            const gameTypeLabel = game.game_type === 'tournament' ? 'üèÜ Tournoi' : '‚ö° QuickPlay';
            const gameTypeBg = game.game_type === 'tournament' ? 'bg-purple-500/20' : 'bg-blue-500/20';

            return `
                <a href="/history/${game.id}" class="block game-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6 hover:border-white/40 hover:bg-[#0C154D]/40 transition-all cursor-pointer">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center gap-4">
                            <div class="text-4xl">${resultIcon}</div>
                            <div>
                                <div class="text-2xl font-bold text-white">
                                    ${isDraw ? '√âGALIT√â' : `Victoire de ${winnerName}`}
                                </div>
                                <div class="text-white/60 text-sm">${formattedDate} √† ${formattedTime}</div>
                            </div>
                        </div>
                        <div class="text-right">
                            <div class="${gameTypeBg} px-4 py-2 rounded-lg text-white text-sm mb-2">
                                ${gameTypeLabel}
                            </div>
                            ${game.end_reason ? `
                                <div class="text-white/60 text-xs">
                                    ${game.end_reason === 'score' ? 'üéØ Score' : 
                                      game.end_reason === 'timeout' ? '‚è±Ô∏è Timeout' : 
                                      'üö´ Forfait'}
                                </div>
                            ` : ''}
                        </div>
                    </div>

                    <div class="grid grid-cols-3 gap-4 items-center">
                        <!-- Joueur gauche -->
                        <div class="text-center">
                            <div class="text-white font-semibold text-lg mb-2">
                                ${game.player_left_username}
                            </div>
                            <div class="text-4xl font-bold ${game.score_left > game.score_right ? 'text-green-400' : 'text-white/60'}">
                                ${game.score_left}
                            </div>
                        </div>

                        <!-- VS -->
                        <div class="text-center">
                            <div class="text-white/40 text-2xl font-bold">VS</div>
                            ${duration !== '-' ? `
                                <div class="text-white/60 text-sm mt-2">
                                    ‚è±Ô∏è ${duration}
                                </div>
                            ` : ''}
                        </div>

                        <!-- Joueur droit -->
                        <div class="text-center">
                            <div class="text-white font-semibold text-lg mb-2">
                                ${game.player_right_username}
                            </div>
                            <div class="text-4xl font-bold ${game.score_right > game.score_left ? 'text-green-400' : 'text-white/60'}">
                                ${game.score_right}
                            </div>
                        </div>
                    </div>

                    <div class="mt-4 pt-4 border-t border-white/10 text-center">
                        <span class="text-blue-400 hover:text-blue-300 text-sm">
                            ‚Üí Voir les d√©tails
                        </span>
                    </div>
                </a>
            `;
        }).join('');

        // Animation d'entr√©e
        gsap.fromTo('.game-card', 
            { opacity: 0, y: 20 },
            { 
                opacity: 1, 
                y: 0, 
                duration: 0.5, 
                stagger: 0.1,
                ease: 'power2.out'
            }
        );
    };

    // Afficher les stats globales
    const displayGlobalStats = (): void => {
        const statsElement = document.getElementById('global-stats');
        if (!statsElement) return;

        const totalGames = allGames.length;
        const quickplayGames = allGames.filter(g => g.game_type === 'quickplay').length;
        const tournamentGames = allGames.filter(g => g.game_type === 'tournament').length;

        const totalDuration = allGames.reduce((sum, game) => sum + (game.duration_seconds || 0), 0);
        let avgDuration = '0:00';
        if (totalGames > 0) {
            const avgSeconds = totalDuration / totalGames;
            const minutes = Math.floor(avgSeconds / 60);
            const seconds = Math.floor(avgSeconds % 60);
            avgDuration = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        statsElement.innerHTML = `
            <div class="stat-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                <div class="text-white/60 text-sm mb-2">Total Parties</div>
                <div class="text-4xl font-bold text-white">${totalGames}</div>
            </div>
            
            <div class="stat-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                <div class="text-white/60 text-sm mb-2">QuickPlay</div>
                <div class="text-4xl font-bold text-blue-400">${quickplayGames}</div>
            </div>
            
            <div class="stat-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                <div class="text-white/60 text-sm mb-2">Tournois</div>
                <div class="text-4xl font-bold text-purple-400">${tournamentGames}</div>
            </div>
            
            <div class="stat-card bg-[#0C154D]/30 backdrop-blur-md border border-white/20 rounded-lg p-6">
                <div class="text-white/60 text-sm mb-2">Dur√©e Moyenne</div>
                <div class="text-4xl font-bold text-green-400">${avgDuration}</div>
            </div>
        `;

        // Animation des stats
        gsap.fromTo('.stat-card', 
            { scale: 0.8, opacity: 0 },
            { 
                scale: 1, 
                opacity: 1, 
                duration: 0.5, 
                stagger: 0.1,
                ease: 'back.out(1.7)'
            }
        );
    };

    // Gestion des filtres
    const handleFilterClick = (e: Event): void => {
        const target = e.target as HTMLElement;
        const filter = target.dataset.filter as 'all' | 'quickplay' | 'tournament';
        
        if (!filter) return;

        currentFilter = filter;

        // Mettre √† jour l'UI des boutons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.remove('active', 'bg-white/30');
        });
        target.classList.add('active', 'bg-white/30');

        applyFiltersAndSort();
        displayGames();
    };

    // Gestion du tri
    const handleSortChange = (e: Event): void => {
        const target = e.target as HTMLSelectElement;
        currentSort = target.value as 'recent' | 'oldest' | 'duration';
        
        applyFiltersAndSort();
        displayGames();
    };

    // Utilitaires d'affichage
    const hideLoading = (): void => {
        const loading = document.getElementById('history-loading');
        if (loading) loading.style.display = 'none';
    };

    const showError = (): void => {
        hideLoading();
        const error = document.getElementById('history-error');
        if (error) error.style.display = 'block';
    };

    // Attacher les event listeners
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', handleFilterClick);
    });

    const sortSelect = document.getElementById('sort-select');
    if (sortSelect) {
        sortSelect.addEventListener('change', handleSortChange);
    }

    // Charger l'historique
    fetchHistory();

    // Fonction de cleanup
    return (): void => {
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.removeEventListener('click', handleFilterClick);
        });
        
        if (sortSelect) {
            sortSelect.removeEventListener('change', handleSortChange);
        }
    };
};

// ==============================================
// üìÑ ./src/views/CreateAccountView.ts
// ==============================================
import type { ViewFunction } from "../router/types";
import { gsap } from "gsap";

export const CreateAccountView: ViewFunction = () => {
    return `
        <!-- Fond avec grille anim√©e (m√™me que HomeView) -->
        <div class="fixed inset-0 bg-black overflow-hidden">
            <!-- Grille de fond -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
                background-size: 50px 50px;
                animation: gridMove 20s linear infinite;
            "></div>
            
            <style>
                @keyframes gridMove {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(50px); }
                }
                
                @keyframes neonPulse {
                    0%, 100% { 
                        text-shadow: 
                            0 0 10px rgba(59, 130, 246, 0.8),
                            0 0 20px rgba(59, 130, 246, 0.6),
                            0 0 30px rgba(59, 130, 246, 0.4);
                    }
                    50% { 
                        text-shadow: 
                            0 0 20px rgba(59, 130, 246, 1),
                            0 0 30px rgba(59, 130, 246, 0.8),
                            0 0 40px rgba(59, 130, 246, 0.6);
                    }
                }
                
                @keyframes scanline {
                    0% { transform: translateY(-100%); }
                    100% { transform: translateY(100vh); }
                }
                
                .pixel-font {
                    font-family: 'Courier New', monospace;
                    font-weight: bold;
                    letter-spacing: 0.1em;
                }
                
                .neon-border {
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    border: 3px solid rgba(59, 130, 246, 0.8);
                }
                
                .neon-border:hover {
                    box-shadow: 
                        0 0 20px rgba(59, 130, 246, 0.8),
                        inset 0 0 20px rgba(59, 130, 246, 0.3);
                    border-color: rgba(59, 130, 246, 1);
                }
                
                .neon-input {
                    background: rgba(15, 23, 42, 0.6);
                    border: 2px solid rgba(59, 130, 246, 0.5);
                    color: #60A5FA;
                    transition: all 0.3s ease;
                }
                
                .neon-input:focus {
                    outline: none;
                    border-color: rgba(59, 130, 246, 1);
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    background: rgba(15, 23, 42, 0.8);
                }
                
                .neon-input::placeholder {
                    color: rgba(96, 165, 250, 0.4);
                }

                .neon-input.error {
                    border-color: rgba(239, 68, 68, 0.8);
                    box-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
                }
            </style>
            
            <!-- Scanline effect -->
            <div class="absolute inset-0 pointer-events-none opacity-10">
                <div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
            </div>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header avec BackButton -->
            <div class="p-8">
                <button 
                    onclick="history.back()" 
                    class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
                    id="back-button"
                >
                    ‚Üê BACK
                </button>
            </div>

            <!-- Zone centrale -->
            <div class="flex-1 flex items-center justify-center px-4 py-12">
                <div class="w-full max-w-6xl grid grid-cols-1 md:grid-cols-2 gap-8">
                    
                    <!-- C√¥t√© gauche - Animation/Image -->
                    <div class="flex items-center justify-center p-8" id="left-panel">
                        <div class="relative w-full h-full min-h-[500px] neon-border bg-black/50 backdrop-blur-sm rounded-lg overflow-hidden flex items-center justify-center">
                            <!-- GIF ou animation -->
                            <img 
                                src="/sprites/dancing-cat.gif" 
                                alt="Animation"
                                class="w-full h-full object-contain"
                                style="image-rendering: pixelated;"
                            />
                            
                            <!-- Overlay avec effet n√©on -->
                            <div class="absolute inset-0 pointer-events-none" style="
                                background: radial-gradient(circle at center, transparent 40%, rgba(59, 130, 246, 0.1) 100%);
                            "></div>
                        </div>
                    </div>

                    <!-- C√¥t√© droit - Formulaire -->
                    <div class="flex flex-col justify-center p-8 neon-border bg-black/50 backdrop-blur-sm rounded-lg relative" id="right-panel">
                        <!-- Titre -->
                        <div class="text-center mb-8">
                            <h1 class="pixel-font text-4xl md:text-5xl text-blue-400 mb-2" 
                                style="animation: neonPulse 2s ease-in-out infinite;"
                                id="create-title">
                                HELLO!
                            </h1>
                            <h2 class="pixel-font text-xl md:text-2xl text-blue-300 opacity-80">
                                Create your account
                            </h2>
                        </div>

                        <!-- Message d'erreur -->
                        <div id="error-message" class="hidden mb-4 p-3 neon-border bg-red-500/10 rounded">
                            <p class="pixel-font text-xs text-red-400 text-center"></p>
                        </div>

                        <!-- Formulaire -->
                        <form action="/create" method="POST" id="createForm" class="space-y-6">
                            <!-- Username -->
                            <div>
                                <label for="username" class="block mb-2 pixel-font text-sm text-blue-300">
                                    USERNAME:
                                </label>
                                <input 
                                    type="text" 
                                    id="username" 
                                    name="username"
                                    placeholder="Enter username"
                                    required
                                    minlength="3"
                                    maxlength="20"
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Password -->
                            <div>
                                <label for="password" class="block mb-2 pixel-font text-sm text-blue-300">
                                    PASSWORD:
                                </label>
                                <input 
                                    type="password" 
                                    id="password" 
                                    name="password"
                                    placeholder="Enter password"
                                    required
                                    minlength="6"
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Confirm Password -->
                            <div>
                                <label for="confirmpassword" class="block mb-2 pixel-font text-sm text-blue-300">
                                    CONFIRM PASSWORD:
                                </label>
                                <input 
                                    type="password" 
                                    id="confirmpassword" 
                                    name="confirmpassword"
                                    placeholder="Confirm your password"
                                    required
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Bouton Submit -->
                            <button 
                                type="submit" 
                                class="w-full py-3 pixel-font text-sm neon-border bg-blue-500/20 text-blue-400 hover:bg-blue-500/40 hover:text-white transition-all"
                                id="submit-btn"
                            >
                                >>> CREATE ACCOUNT <<<
                            </button>
                        </form>

                        <!-- Lien vers login -->
                        <div class="mt-6 text-center">
                            <p class="pixel-font text-xs text-blue-300/60 mb-3">
                                Already have an account?
                            </p>
                            <a 
                                href="/login" 
                                class="pixel-font text-sm text-blue-400 hover:text-blue-300 transition-colors inline-block"
                            >
                                >>> LOGIN <<<
                            </a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
                <p>¬© 2025 PONG - SKILL ISSUE</p>
            </footer>
        </div>
    `;
};

export const createAccountLogic = (): (() => void) => {
    gsap.from('#create-title', {
        scale: 0.5,
        opacity: 0,
        duration: 1,
        ease: 'back.out(1.7)'
    });

    gsap.from('#left-panel', {
        x: -100,
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
    });

    gsap.from('#right-panel', {
        x: 100,
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
    });

    // Gestion du formulaire
    const form = document.getElementById('createForm') as HTMLFormElement;
    const errorMessage = document.getElementById('error-message');
    const errorText = errorMessage?.querySelector('p');
    
    const showError = (message: string) => {
        if (errorMessage && errorText) {
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
            
            // Animation de l'erreur
            gsap.fromTo(errorMessage, 
                { scale: 0.8, opacity: 0 },
                { scale: 1, opacity: 1, duration: 0.3, ease: 'back.out' }
            );
        }
    };

    const hideError = () => {
        if (errorMessage) {
            errorMessage.classList.add('hidden');
        }
    };

    const handleSubmit = (e: Event) => {
        e.preventDefault();
        hideError();
        
        const username = (document.getElementById('username') as HTMLInputElement).value;
        const password = (document.getElementById('password') as HTMLInputElement).value;
        const confirmPassword = (document.getElementById('confirmpassword') as HTMLInputElement).value;

        // Validation
        if (username.length < 3 || username.length > 20) {
            showError('‚ö†Ô∏è Username must be between 3 and 20 characters');
            return;
        }

        if (password.length < 6) {
            showError('‚ö†Ô∏è Password must be at least 6 characters');
            return;
        }

        if (password !== confirmPassword) {
            showError('‚ö†Ô∏è Passwords do not match');
            
            // Ajouter classe error aux champs password
            const passwordInput = document.getElementById('password') as HTMLInputElement;
            const confirmInput = document.getElementById('confirmpassword') as HTMLInputElement;
            passwordInput?.classList.add('error');
            confirmInput?.classList.add('error');
            
            // Retirer apr√®s 2 secondes
            setTimeout(() => {
                passwordInput?.classList.remove('error');
                confirmInput?.classList.remove('error');
            }, 2000);
            
            return;
        }

        // Animation du bouton
        const submitBtn = document.getElementById('submit-btn');
        if (submitBtn) {
            gsap.to(submitBtn, {
                scale: 0.95,
                duration: 0.1,
                yoyo: true,
                repeat: 1
            });
        }

        // TODO: Logique de cr√©ation de compte r√©elle
        console.log('Create account attempt:', { username, password });
        
        // Animation de succ√®s
        gsap.to('#right-panel', {
            scale: 1.05,
            duration: 0.2,
            yoyo: true,
            repeat: 1,
            onComplete: () => {
                // Exemple de redirection apr√®s succ√®s
                // window.router.navigate('/login');
            }
        });
    };

    if (form) {
        form.addEventListener('submit', handleSubmit);
    }

    // Cleanup
    return () => {
        if (form) {
            form.removeEventListener('submit', handleSubmit);
        }
    };
};

// ==============================================
// üìÑ ./src/views/LocalTournamentSetupView.ts
// ==============================================
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { LocalTournamentManager, type LocalPlayer } from "../utils/localTournamentManager";

export const LocalTournamentSetupView: ViewFunction = () => {
	return `
		<!-- Fond avec grille anim√©e -->
		<div class="fixed inset-0 bg-black overflow-hidden">
			<div class="absolute inset-0" style="
				background-image:
					linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
					linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
				background-size: 50px 50px;
				animation: gridMove 20s linear infinite;
			"></div>

			<style>
				@keyframes gridMove {
					0% { transform: translateY(0); }
					100% { transform: translateY(50px); }
				}

				@keyframes neonPulse {
					0%, 100% {
						text-shadow:
							0 0 10px rgba(59, 130, 246, 0.8),
							0 0 20px rgba(59, 130, 246, 0.6),
							0 0 30px rgba(59, 130, 246, 0.4);
					}
					50% {
						text-shadow:
							0 0 20px rgba(59, 130, 246, 1),
							0 0 30px rgba(59, 130, 246, 0.8),
							0 0 40px rgba(59, 130, 246, 0.6);
					}
				}

				.pixel-font {
					font-family: 'Courier New', monospace;
					font-weight: bold;
					letter-spacing: 0.1em;
				}

				.neon-border {
					box-shadow:
						0 0 10px rgba(59, 130, 246, 0.5),
						inset 0 0 10px rgba(59, 130, 246, 0.2);
					border: 3px solid rgba(59, 130, 246, 0.8);
				}

				.neon-border:hover {
					box-shadow:
						0 0 20px rgba(59, 130, 246, 0.8),
						inset 0 0 20px rgba(59, 130, 246, 0.3);
					border-color: rgba(59, 130, 246, 1);
				}

				.neon-input {
					background: rgba(15, 23, 42, 0.6);
					border: 2px solid rgba(59, 130, 246, 0.5);
					color: #60A5FA;
					transition: all 0.3s ease;
				}

				.neon-input:focus {
					outline: none;
					border-color: rgba(59, 130, 246, 1);
					box-shadow:
						0 0 10px rgba(59, 130, 246, 0.5),
						inset 0 0 10px rgba(59, 130, 246, 0.2);
					background: rgba(15, 23, 42, 0.8);
				}

				.neon-input::placeholder {
					color: rgba(96, 165, 250, 0.4);
				}

				.player-card {
					transition: all 0.3s ease;
					background: rgba(15, 23, 42, 0.6);
					backdrop-filter: blur(10px);
				}

				.size-selector {
					cursor: pointer;
					transition: all 0.3s ease;
				}

				.size-selector.active {
					background: rgba(59, 130, 246, 0.3);
					border-color: #60A5FA;
					transform: scale(1.05);
				}
			</style>

			<div class="absolute inset-0 pointer-events-none opacity-10">
				<div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
			</div>
		</div>

		<!-- Contenu principal -->
		<div class="relative z-10 min-h-screen flex flex-col">
			<header class="flex justify-between items-center px-8 py-6">
				<button
					onclick="history.back()"
					class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
					id="back-button"
				>
					‚Üê BACK
				</button>
			</header>

			<div class="flex-1 flex items-center justify-center px-4 py-12">
				<div class="w-full max-w-6xl">

					<!-- Titre principal -->
					<div class="text-center mb-8">
						<h1 class="pixel-font text-4xl md:text-6xl text-blue-400 mb-4"
							style="animation: neonPulse 2s ease-in-out infinite;"
							id="tournament-title">
							üèÜ LOCAL TOURNAMENT üèÜ
						</h1>
						<p class="pixel-font text-lg text-blue-300 opacity-80">
							>>> MULTIPLAYER CHAMPIONSHIP <<<
						</p>
					</div>

					<!-- S√©lection de la taille -->
					<div id="size-selection" class="mb-8">
						<div class="text-center mb-4">
							<p class="pixel-font text-sm text-blue-300">SELECT TOURNAMENT SIZE:</p>
						</div>
						<div class="flex justify-center gap-4">
							<div
								class="size-selector neon-border rounded-lg p-6 text-center active"
								data-size="4"
							>
								<div class="pixel-font text-3xl text-blue-400 mb-2">4</div>
								<div class="pixel-font text-xs text-blue-300">PLAYERS</div>
							</div>
							<div
								class="size-selector neon-border rounded-lg p-6 text-center"
								data-size="8"
							>
								<div class="pixel-font text-3xl text-blue-400 mb-2">8</div>
								<div class="pixel-font text-xs text-blue-300">PLAYERS</div>
							</div>
						</div>
					</div>

					<!-- Formulaire des joueurs -->
					<form id="tournament-setup-form" class="space-y-6">
						<div id="players-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
							<!-- Players will be generated dynamically -->
						</div>

						<!-- Bouton START -->
						<div class="flex justify-center mt-8">
							<button
								type="submit"
								class="pixel-font px-12 py-4 text-xl neon-border bg-blue-500/20 text-blue-400 hover:bg-blue-500/40 transition-all"
								id="start-tournament-btn"
							>
								START TOURNAMENT
							</button>
						</div>
					</form>

				</div>
			</div>
		</div>
	`;
};

const generateId = (): string => {
	if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
		return crypto.randomUUID();
	}
	return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
};

const generatePlayerCards = (count: number): string => {
	const colors = [
		'blue', 'red', 'green', 'yellow',
		'purple', 'pink', 'cyan', 'orange'
	];

	let html = '';
	for (let i = 0; i < count; i++) {
		const color = colors[i % colors.length];
		html += `
			<div class="player-card neon-border rounded-lg p-4" data-player-index="${i}">
				<div class="mb-3">
					<h3 class="pixel-font text-lg text-${color}-400 mb-2">PLAYER ${i + 1}</h3>
				</div>

				<div class="mb-3">
					<label class="block mb-1 pixel-font text-xs text-${color}-300">
						USERNAME:
					</label>
					<input
						type="text"
						name="player-${i}-name"
						placeholder="Player ${i + 1}"
						maxlength="24"
						required
						class="w-full p-2 rounded pixel-font text-sm neon-input"
					/>
				</div>

				<div>
					<label class="block mb-1 pixel-font text-xs text-${color}-300">
						SKILL:
					</label>
					<select
						name="player-${i}-skill"
						class="w-full p-2 rounded pixel-font text-xs neon-input cursor-pointer"
					>
						<option value="smash">üí• Smash</option>
						<option value="dash">‚ö° Dash</option>
					</select>
				</div>
			</div>
		`;
	}
	return html;
};

export const localTournamentSetupLogic = (): CleanupFunction => {
	let currentSize = 4;

	// Fonction pour mettre √† jour les cartes de joueurs
	const updatePlayerCards = (size: number) => {
		const container = document.getElementById('players-container');
		if (container) {
			container.innerHTML = generatePlayerCards(size);

			// Animer l'apparition des cartes
			gsap.fromTo(
				'.player-card',
				{ opacity: 0, y: 20 },
				{ opacity: 1, y: 0, duration: 0.3, stagger: 0.05 }
			);
		}
	};

	// Initialiser avec 4 joueurs
	updatePlayerCards(currentSize);

	// G√©rer la s√©lection de la taille
	const sizeSelectors = document.querySelectorAll('.size-selector');
	sizeSelectors.forEach(selector => {
		selector.addEventListener('click', () => {
			const size = parseInt(selector.getAttribute('data-size') || '4');
			currentSize = size;

			// Mettre √† jour l'√©tat actif
			sizeSelectors.forEach(s => s.classList.remove('active'));
			selector.classList.add('active');

			// Mettre √† jour les cartes de joueurs
			updatePlayerCards(size);
		});
	});

	// Animer le titre
	const title = document.getElementById('tournament-title');
	if (title) {
		gsap.fromTo(
			title,
			{ opacity: 0, scale: 0.5 },
			{ opacity: 1, scale: 1, duration: 0.8, ease: 'back.out(1.7)' }
		);
	}

	// G√©rer la soumission du formulaire
	const form = document.getElementById('tournament-setup-form') as HTMLFormElement;
	const handleSubmit = (e: Event) => {
		e.preventDefault();

		const formData = new FormData(form);
		const players: Omit<LocalPlayer, 'eliminated'>[] = [];

		// Collecter les donn√©es des joueurs
		for (let i = 0; i < currentSize; i++) {
			const username = formData.get(`player-${i}-name`) as string;
			const selectedSkill = formData.get(`player-${i}-skill`) as 'smash' | 'dash';

			if (!username || username.trim() === '') {
				alert(`Please enter a name for Player ${i + 1}`);
				return;
			}

			players.push({
				id: generateId(),
				username: username.trim(),
				selectedSkill,
			});
		}

		// V√©rifier les noms en double
		const usernames = players.map(p => p.username.toLowerCase());
		const hasDuplicates = usernames.some((name, index) => usernames.indexOf(name) !== index);
		if (hasDuplicates) {
			alert('Player names must be unique!');
			return;
		}

		try {
			// Cr√©er le tournoi
			const tournament = LocalTournamentManager.createTournament(
				currentSize as 4 | 8,
				players
			);

			console.log('Tournament created:', tournament);

			// Rediriger vers la vue du bracket
			window.router.navigate('/local-tournament-bracket');
		} catch (error) {
			console.error('Error creating tournament:', error);
			alert('Failed to create tournament. Please try again.');
		}
	};

	form?.addEventListener('submit', handleSubmit);

	// Cleanup
	return () => {
		form?.removeEventListener('submit', handleSubmit);
	};
};

// ==============================================
// üìÑ ./src/views/QuickPlayView.ts
// ==============================================
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";

export const QuickPlayView: ViewFunction = () => {
	return `
		<!-- Fond avec grille anim√©e -->
		<div class="fixed inset-0 bg-black overflow-hidden">
			<!-- Grille de fond -->
			<div class="absolute inset-0" style="
				background-image: 
					linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
					linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
				background-size: 50px 50px;
				animation: gridMove 20s linear infinite;
			"></div>
			
			<style>
				@keyframes gridMove {
					0% { transform: translateY(0); }
					100% { transform: translateY(50px); }
				}
				
				@keyframes neonPulse {
					0%, 100% { 
						text-shadow: 
							0 0 10px rgba(59, 130, 246, 0.8),
							0 0 20px rgba(59, 130, 246, 0.6),
							0 0 30px rgba(59, 130, 246, 0.4);
					}
					50% { 
						text-shadow: 
							0 0 20px rgba(59, 130, 246, 1),
							0 0 30px rgba(59, 130, 246, 0.8),
							0 0 40px rgba(59, 130, 246, 0.6);
					}
				}
				
				@keyframes scanline {
					0% { transform: translateY(-100%); }
					100% { transform: translateY(100vh); }
				}
				
				.pixel-font {
					font-family: 'Courier New', monospace;
					font-weight: bold;
					letter-spacing: 0.1em;
				}
				
				.neon-border {
					box-shadow: 
						0 0 10px rgba(59, 130, 246, 0.5),
						inset 0 0 10px rgba(59, 130, 246, 0.2);
					border: 3px solid rgba(59, 130, 246, 0.8);
				}
				
				.neon-border:hover {
					box-shadow: 
						0 0 20px rgba(59, 130, 246, 0.8),
						inset 0 0 20px rgba(59, 130, 246, 0.3);
					border-color: rgba(59, 130, 246, 1);
				}
				
				.skill-card {
					transition: all 0.3s ease;
					background: rgba(15, 23, 42, 0.6);
					backdrop-filter: blur(10px);
					cursor: pointer;
					min-height: 320px;
					display: flex;
					flex-direction: column;
				}
				
				.skill-card:hover {
					transform: translateY(-5px);
					background: rgba(30, 41, 59, 0.8);
				}
				
				.skill-card.selected {
					background: rgba(59, 130, 246, 0.2);
					border-color: rgba(59, 130, 246, 1);
					box-shadow: 
						0 0 20px rgba(59, 130, 246, 0.6),
						inset 0 0 20px rgba(59, 130, 246, 0.3);
				}

				.mode-button {
					transition: all 0.3s ease;
					background: rgba(15, 23, 42, 0.6);
					backdrop-filter: blur(10px);
				}

				.mode-button:hover:not(:disabled) {
					transform: translateY(-3px);
					background: rgba(30, 41, 59, 0.8);
				}

				.mode-button:disabled {
					opacity: 0.4;
					cursor: not-allowed;
				}

				.switch-button {
					background: rgba(15, 23, 42, 0.6);
				}
				.switch-button:before{
					content: "3D";
					position: absolute;
					top: 0;
					bottom: 0;
					right: 0;
					width: 120px;
					display: flex;
					align-items: center;
					justify-content: center;
					z-index: 3;
					pointer-events: none;
				}
				.switch-button-checkbox:checked + .switch-button-label:before {
					transform: translateX(120px);
					transition: transform 300ms linear;
				}
				.switch-button-label:before {
					content: "";
					background: rgba(59, 130, 246, 0.2);
					height: 100%;
					width: 100%;
					position: absolute;
					left: 0;
					top: 0;
					transform: translateX(0);
					transition: transform 300ms;
					border-radius: 4px;
					border: 3px solid rgba(59, 130, 246, 0.8);
				}
			</style>
			
			<!-- Scanline effect -->
			<div class="absolute inset-0 pointer-events-none opacity-10">
				<div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
			</div>
		</div>

		<!-- Contenu principal -->
		<div class="relative z-10 min-h-screen flex flex-col">
			<!-- Header avec BackButton et Sign in -->
			<header class="flex justify-between items-center px-8 py-6">
				<button 
					onclick="history.back()" 
					class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
					id="back-button"
				>
					‚Üê BACK
				</button>
				
				<!-- Bouton Sign in -->
				<a href="/login" 
				   class="pixel-font bg-blue-500 text-black px-6 py-3 text-sm md:text-base hover:bg-blue-400 transition-all neon-border flex items-center gap-2">
					<span>SIGN IN</span>
				</a>
			</header>

			<!-- Zone centrale -->
			<div class="flex-1 flex items-center justify-center px-4 py-12">
				<div class="w-full max-w-4xl">
					
					<!-- Titre principal -->
					<div class="text-center mb-12">
						<h1 class="pixel-font text-5xl md:text-6xl text-blue-400 mb-4" 
							style="animation: neonPulse 2s ease-in-out infinite;"
							id="quickplay-title">
							‚ö° QUICKPLAY ‚ö°
						</h1>
						<p class="pixel-font text-lg text-blue-300 opacity-80">
							>>> SELECT YOUR SKILL <<<
						</p>
					</div>
					<!-- 2d-3d toggle -->
					<div id="view-mode-toggle-container" class="switch-button mx-auto mb-8 neon-border rounded-lg pixel-font text-blue-400 overflow-hidden w-60 text-center text-lg tracking-[1px] relative pl-[5px] pr-[125px] py-[5px]">
						<input id="view-mode-toggle" class="switch-button-checkbox cursor-pointer absolute w-full h-full opacity-0 z-[2] left-0 inset-y-0" type="checkbox" />
						<label class="switch-button-label relative block select-none pointer-events-none px-0 py-[15px]" for="view-mode-toggle"><span class="switch-button-label-span relative">2D</span></label>
					</div>
					<!-- Section Skills -->
					<div class="mb-12 neon-border bg-black/50 backdrop-blur-sm rounded-lg p-8" id="skills-section">
						<h2 class="pixel-font text-2xl text-blue-400 mb-6 text-center">
							CHOOSE YOUR ABILITY
						</h2>
						
						<div class="grid grid-cols-1 md:grid-cols-2 gap-6" data-skill-options>
							<!-- Smash Card -->
							<div 
								class="skill-card neon-border rounded-lg p-6 relative selected" 
								data-skill-option="smash"
								id="skill-smash"
							>
								<!-- Badge s√©lectionn√© -->
								<div class="absolute top-3 right-3 pixel-font text-xs text-green-400 bg-green-500/20 px-2 py-1 rounded border border-green-500/50">
									‚úì SELECTED
								</div>
							
								<!-- Ic√¥ne -->
								<div class="text-5xl mb-4 text-center">üí•</div>
								
								<!-- Titre -->
								<h3 class="pixel-font text-xl text-blue-400 mb-3 text-center uppercase">
									Smash
								</h3>
								
								<!-- Description -->
								<p class="pixel-font text-sm text-blue-300 opacity-80 text-center leading-relaxed flex-grow">
									Charge a powerful strike that sends the ball back faster and can surprise your opponent
								</p>
							
								<!-- Stats -->
								<div class="mt-4 pt-4 border-t border-blue-500/30 space-y-2">
									<div class="flex justify-between pixel-font text-xs text-blue-300">
										<span>Cooldown:</span>
										<span class="text-yellow-400">3s</span>
									</div>
									<div class="flex justify-between pixel-font text-xs text-blue-300">
										<span>Power:</span>
										<span class="text-green-400">‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</span>
									</div>
								</div>
							
								<!-- Fl√®ches d√©coratives MIEUX POSITIONN√âES -->
								<div class="absolute bottom-2 left-0 right-0 flex justify-between px-3 pointer-events-none">
									<div class="text-red-500 text-sm opacity-80">‚Üê</div>
									<div class="text-red-500 text-sm opacity-80">‚Üí</div>
								</div>
							</div>
							
							<!-- Dash Card -->
							<div 
								class="skill-card neon-border rounded-lg p-6 relative" 
								data-skill-option="dash"
								id="skill-dash"
							>
								<!-- Badge s√©lectionn√© (cach√© par d√©faut) -->
								<div class="absolute top-3 right-3 pixel-font text-xs text-green-400 bg-green-500/20 px-2 py-1 rounded border border-green-500/50 hidden">
									‚úì SELECTED
								</div>
							
								<!-- Ic√¥ne -->
								<div class="text-5xl mb-4 text-center text-blue-500">‚ö°</div>
								
								<!-- Titre -->
								<h3 class="pixel-font text-xl text-blue-400 mb-3 text-center uppercase">
									Dash
								</h3>
								
								<!-- Description -->
								<p class="pixel-font text-sm text-blue-300 opacity-80 text-center leading-relaxed flex-grow">
									Make a quick move with your paddle to catch difficult balls
								</p>
							
								<!-- Stats -->
								<div class="mt-4 pt-4 border-t border-blue-500/30 space-y-2">
									<div class="flex justify-between pixel-font text-xs text-blue-300">
										<span>Cooldown:</span>
										<span class="text-yellow-400">5s</span>
									</div>
									<div class="flex justify-between pixel-font text-xs text-blue-300">
										<span>Speed:</span>
										<span class="text-green-400">‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</span>
									</div>
								</div>
							
								<!-- Fl√®ches d√©coratives MIEUX POSITIONN√âES -->
								<div class="absolute bottom-2 left-0 right-0 flex justify-between px-3 pointer-events-none">
									<div class="text-blue-500 text-sm opacity-80">‚Üê</div>
									<div class="text-blue-500 text-sm opacity-80">‚Üí</div>
								</div>
							</div>
						</div>

						<!-- Skill s√©lectionn√© -->
						<div class="mt-6 text-center">
							<p id="selected-skill-label" class="pixel-font text-sm text-blue-300">
								Selected skill: <span class="text-blue-400 font-bold">SMASH</span>
							</p>
						</div>
					</div>

					<!-- Section Modes de jeu -->
					<div class="space-y-4" id="modes-section">
						<!-- Play Online -->
						<button 
							id="play-online" 
							class="mode-button w-full p-6 neon-border rounded-lg pixel-font text-lg text-blue-400 hover:text-white transition-all relative group"
						>
							<div class="flex items-center justify-between">
								<div class="flex items-center gap-4">
									<span class="text-3xl">üåê</span>
									<div class="text-left">
										<div class="text-xl">PLAY ONLINE</div>
										<div class="text-xs opacity-60 font-normal">Find an opponent and start playing</div>
									</div>
								</div>
								<span class="text-2xl group-hover:translate-x-2 transition-transform">‚Üí</span>
							</div>
						</button>

						<!-- Play Local -->
						<button
							id="play-local"
							class="mode-button w-full p-6 neon-border rounded-lg pixel-font text-lg text-blue-400 hover:text-white transition-all relative group"
						>
							<div class="flex items-center justify-between">
								<div class="flex items-center gap-4">
									<span class="text-3xl">üéÆ</span>
									<div class="text-left">
										<div class="text-xl">PLAY LOCAL</div>
										<div class="text-xs opacity-60 font-normal">Two players, one screen</div>
									</div>
								</div>
								<span class="text-2xl group-hover:translate-x-2 transition-transform">‚Üí</span>
							</div>
						</button>

						<!-- Local Tournament -->
						<button
							id="play-local-tournament"
							class="mode-button w-full p-6 neon-border rounded-lg pixel-font text-lg text-blue-400 hover:text-white transition-all relative group"
						>
							<div class="flex items-center justify-between">
								<div class="flex items-center gap-4">
									<span class="text-3xl">üèÜ</span>
									<div class="text-left">
										<div class="text-xl">LOCAL TOURNAMENT</div>
										<div class="text-xs opacity-60 font-normal">4 or 8 players championship</div>
									</div>
								</div>
								<span class="text-2xl group-hover:translate-x-2 transition-transform">‚Üí</span>
							</div>
						</button>

						<!-- Play vs AI -->
						<button
							id="play-vs-ai"
							class="mode-button w-full p-6 neon-border rounded-lg pixel-font text-lg text-blue-400 hover:text-white transition-all relative group"
						>
							<div class="flex items-center justify-between">
								<div class="flex items-center gap-4">
									<span class="text-3xl">ü§ñ</span>
									<div class="text-left">
										<div class="text-xl">PLAY VS AI</div>
										<div class="text-xs opacity-60 font-normal">Let the AI control your paddle</div>
									</div>
								</div>
								<span class="text-2xl group-hover:translate-x-2 transition-transform">‚Üí</span>
							</div>
						</button>
					</div>

				</div>
			</div>

			<!-- Footer -->
			<footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
				<p>¬© 2025 PONG - SKILL ISSUE</p>
			</footer>
		</div>
	`;
};

export const quickPlayLogic = (): CleanupFunction => {
	// Animations d'entr√©e
	gsap.from('#quickplay-title', {
		scale: 0.5,
		opacity: 0,
		duration: 1,
		ease: 'back.out(1.7)'
	});

	gsap.from('#skills-section', {
		y: 50,
		opacity: 0,
		duration: 0.8,
		delay: 0.3,
		ease: 'power2.out'
	});

	gsap.from('#modes-section', {
		y: 50,
		opacity: 0,
		duration: 0.8,
		delay: 0.5,
		ease: 'power2.out'
	});

	const skillButtons = Array.from(
		document.querySelectorAll<HTMLButtonElement>('[data-skill-option]')
	);
	const playButton = document.getElementById('play-online') as HTMLButtonElement | null;
	const playVsAIButton = document.getElementById('play-vs-ai') as HTMLButtonElement | null;
	const localButton = document.getElementById('play-local') as HTMLButtonElement | null;
	const localTournamentButton = document.getElementById('play-local-tournament') as HTMLButtonElement | null;
	const label = document.getElementById('selected-skill-label');

	let selectedSkill = (sessionStorage.getItem('selectedSkill') as 'smash' | 'dash' | null) || 'smash';
	sessionStorage.setItem('selectedSkill', selectedSkill);

	const updateUI = () => {
		skillButtons.forEach(btn => {
			const isActive = btn.dataset.skillOption === selectedSkill;
			const badge = btn.querySelector('.absolute.top-3.right-3');
			
			if (isActive) {
				btn.classList.add('selected');
				badge?.classList.remove('hidden');
			} else {
				btn.classList.remove('selected');
				badge?.classList.add('hidden');
			}
			
			btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
		});

		if (label) {
			const skillName = selectedSkill === 'smash' ? 'SMASH' : 'DASH';
			label.innerHTML = `Selected skill: <span class="text-blue-400 font-bold">${skillName}</span>`;
		}
	};

	const handleSkillClick = (event: Event) => {
		event.preventDefault();
		const target = event.currentTarget as HTMLButtonElement | null;
		const skill = target?.dataset.skillOption;
		if (!skill || (skill !== 'smash' && skill !== 'dash')) {
			return;
		}
		
		// Animation de s√©lection
		gsap.to(target, {
			scale: 0.95,
			duration: 0.1,
			yoyo: true,
			repeat: 1
		});

		selectedSkill = skill;
		sessionStorage.setItem('selectedSkill', selectedSkill);
		updateUI();
	};

	const listeners: Array<{ element: HTMLElement; handler: (event: Event) => void }> = [];

	skillButtons.forEach(btn => {
		const handler = handleSkillClick.bind(btn);
		btn.addEventListener('click', handler);
		listeners.push({ element: btn, handler });
	});

	if (playButton) {
		const playHandler = (event: MouseEvent) => {
			event.preventDefault();
			if (!selectedSkill) {
				selectedSkill = 'smash';
				sessionStorage.setItem('selectedSkill', selectedSkill);
			}
			// which view mode selected
			const viewModeToggle = document.getElementById('view-mode-toggle') as HTMLInputElement | null;
			const is3D = viewModeToggle?.checked || false;
			sessionStorage.setItem('viewMode', is3D ? '3d' : '2d');
			// Animation du bouton
			gsap.to(playButton, {
				scale: 0.95,
				duration: 0.1,
				yoyo: true,
				repeat: 1,
				onComplete: () => {
					window.router.navigate('/play/waiting');
				}
			});
		};
		playButton.addEventListener('click', playHandler);
		listeners.push({ element: playButton, handler: playHandler as unknown as (e: Event) => void });
	}

	if (playVsAIButton) {
		const playAIHandler = async (event: MouseEvent) => {
			event.preventDefault();
			if (!selectedSkill) {
				selectedSkill = 'smash';
				sessionStorage.setItem('selectedSkill', selectedSkill);
			}

			const host = import.meta.env.VITE_HOST || 'localhost:8443';
			const createEndpoint = import.meta.env.VITE_CREATEGAME_ENDPOINT || '/gameback/create';
			const gameEndpoint = import.meta.env.VITE_GAME_ENDPOINT || '/gameback/game';
			const makeId = () => {
				if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
					return crypto.randomUUID();
				}
				return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
			};

			const roomId = makeId();
			const aiId = `ai-${makeId()}`;
			const username = window.simpleAuth.getUsername?.() || 'Player';
			const playerId = window.simpleAuth.getPlayerId?.();
			if (!playerId) {
				console.warn('QuickPlay: no playerId, redirecting to login');
				window.router.navigate('/login');
				return;
			}

			try {
				const response = await fetch(`https://${host}${createEndpoint}`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						roomId,
						player1: { id: playerId, username, selectedSkill },
						player2: { id: aiId, username: 'AI', selectedSkill: 'smash' }
					})
				});
				if (!response.ok) {
					throw new Error(`Server error (${response.status})`);
				}

				const wsUrl = `wss://${host}${gameEndpoint}/${roomId}`;
				sessionStorage.setItem('gameWsURL', wsUrl);
				sessionStorage.setItem('aiPlayerId', aiId);
				sessionStorage.setItem('aiSide', 'right');

				gsap.to(playVsAIButton, {
					scale: 0.95,
					duration: 0.1,
					yoyo: true,
					repeat: 1,
					onComplete: () => {
						window.router.navigate(`/game/${roomId}`);
					}
				});
			} catch (err) {
				console.error('QuickPlay: failed to create AI match', err);
			}
		};
		playVsAIButton.addEventListener('click', playAIHandler);
		listeners.push({ element: playVsAIButton, handler: playAIHandler as unknown as (e: Event) => void });
	}

	if (localButton) {
		const localHandler = (event: MouseEvent) => {
			event.preventDefault();
			gsap.to(localButton, {
				scale: 0.95,
				duration: 0.1,
				yoyo: true,
				repeat: 1,
				onComplete: () => {
					window.router?.navigateTo('/local');
				}
			});
		};
		localButton.addEventListener('click', localHandler);
		listeners.push({ element: localButton, handler: localHandler as unknown as (e: Event) => void });
	}

	if (localTournamentButton) {
		const localTournamentHandler = (event: MouseEvent) => {
			event.preventDefault();
			gsap.to(localTournamentButton, {
				scale: 0.95,
				duration: 0.1,
				yoyo: true,
				repeat: 1,
				onComplete: () => {
					window.router?.navigateTo('/local-tournament-setup');
				}
			});
		};
		localTournamentButton.addEventListener('click', localTournamentHandler);
		listeners.push({ element: localTournamentButton, handler: localTournamentHandler as unknown as (e: Event) => void });
	}

	updateUI();

	return () => {
		listeners.forEach(({ element, handler }) => {
			element.removeEventListener('click', handler);
		});
	};
};

// ==============================================
// üìÑ ./src/views/StartGameView.ts
// ==============================================
import type { ViewFunction } from "../router/types";
import { 
	Button,
	BackButton,
	SettingsButton
		} from "../components/Button";  // Ajoute BackButton
import { gsap } from "gsap";

export const StartGameView: ViewFunction = () => {
    // Animation GSAP apr√®s le rendu
    setTimeout(() => {
        // Timeline pour contr√¥ler toute l'animation
        const tl = gsap.timeline();
        
        // Variables pour le contr√¥le du vaisseau
        let mouseY = window.innerHeight / 2;
        const spaceship = document.getElementById("spaceship");
        
        // 1. Suivre la souris
        document.addEventListener('mousemove', (e) => {
            mouseY = e.clientY;
            
            if (spaceship) {
                // Position relative au centre de l'√©cran
                const centerY = window.innerHeight / 2;
                const offsetY = mouseY - centerY;
                
                // Limiter le mouvement (max 300px du centre)
                const clampedY = Math.max(-300, Math.min(200, offsetY));
                
                // Animation fluide vers la position de la souris
                gsap.to("#spaceship", {
                    y: clampedY,
                    duration: 0.3,  // D√©lai pour un mouvement plus smooth
                    ease: "power2.out"
                });
            }
        });
        
        // 2. Fonction pour cr√©er un projectile
        function createProjectile() {
            const spaceship = document.getElementById("spaceship");
            const gameAnimation = document.getElementById("game-animation");
            
            if (!spaceship || !gameAnimation) return;
            
            const rect = spaceship.getBoundingClientRect();
            
            const projectile = document.createElement("div");
            projectile.className = "absolute bg-yellow-400";
            projectile.style.cssText = `
                width: 10px;
                height: 4px;
                left: ${rect.right}px;
                top: ${rect.top + rect.height/2}px;
                border-radius: 1px;
            `;
            
            gameAnimation.appendChild(projectile);
            
            gsap.to(projectile, {
                x: window.innerWidth,
                duration: 2,
                ease: "none",
                onComplete: () => {
                    projectile.remove();
                }
            });
        }
        
        // 3. Tir avec la barre espace
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();  // Emp√™che le scroll
                createProjectile();
            }
        });
        
        // 4. Tir automatique toutes les secondes
        const shootInterval = setInterval(createProjectile, 1000);
        
        // 5. Animation du background
        tl.to("#stars-bg", {
            x: "-80%",
            duration: 3,
            ease: "power2.out"
        })
        
        // 6. Faire appara√Ætre les boutons
        .to("#menu-buttons", {
            opacity: 1,
            pointerEvents: "auto",
            duration: 1,
            ease: "power2.out",
        });
    }, 0);
    
    return `
        <!-- Instructions de contr√¥le EN BAS √Ä GAUCHE -->
        <div class="fixed bottom-4 left-4 text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white">
            <p>üñ±Ô∏è Souris : Contr√¥ler l'avion</p>
            <p>Espace : Tirer</p>
        </div>
        
        <!-- Canvas pour l'animation -->
        <div id="game-animation" class="fixed inset-0 w-full h-full bg-[#04071A] overflow-hidden">
            <!-- Background √©toil√© -->
            <div id="stars-bg" class="absolute inset-0 w-[200%]">
                ${Array.from({length: 100}, (_, i) => `
                    <div 
                        class="absolute bg-white rounded-full ${i % 5 === 0 ? 'animate-pulse' : ''}"
                        style="
                            width: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                            height: ${i % 3 === 0 ? '3px' : i % 2 === 0 ? '2px' : '1px'};
                            left: ${Math.random() * 100}%;
                            top: ${Math.random() * 100}%;
                            opacity: ${0.3 + Math.random() * 0.7};
                            ${i % 5 === 0 ? `animation-delay: ${Math.random() * 5}s;` : ''}
                        "
                    ></div>
                `).join('')}
            </div>
            
            <!-- Avion -->
            <div id="spaceship" class="absolute" style="
                width: 128px;
                height: 128px;
                top: 50%;
                left: 20%;
                transform: translate(-50%, -50%);
            ">
                <img 
                    src="/sprites/spaceship.png" 
                    alt="spaceship"
                    class="w-full h-full"
                    style="image-rendering: pixelated;"
                />
            </div>
        </div>

        <!-- Container des boutons -->
		<div id="menu-buttons" class="fixed inset-0 flex flex-col items-center justify-center opacity-0 pointer-events-none">

			<div class="absolute top-8 left-8">
				${BackButton({
					size: "lg",
					className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
				})}
			</div>

			<div class="absolute top-8 right-8">
			${SettingsButton({
				size: "lg",
				className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
			})}
			</div>
		

			<!-- Texte central qui change -->
			<div id="center-text" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white/70 text-4xl font-bold text-center">
				Choisissez votre destination !
			</div>

			<div class="absolute bottom-32 left-1/2 -translate-x-1/2 flex flex-col items-center gap-4">
				<a href="/local"
					class="px-6 py-3 rounded-lg border border-white/20 bg-white/10 hover:bg-white/20 text-white font-semibold transition-all"
					onmouseover="document.getElementById('center-text').textContent = 'üéÆ Mode Local 2 Joueurs'"
					onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					Mode Local
				</a>
			</div>

			<div class="absolute right-0 top-0 w-1/3 h-full">
				<!-- Bouton Quickplay -->
				<a href="/game" 
				class="absolute block w-[350px] h-[250px]" 
				style="top: 10%; right: 30%;"
				onmouseover="document.getElementById('center-text').textContent = '‚ö° Partie Rapide'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/blackhole.png" 
						alt="Quickplay"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
				
				<!-- Bouton Tournament -->
				<a href="/tournament" 
				class="absolute block w-[900px] h-[800px]" 
				style="top: 65%; right: 50%;"
				onmouseover="document.getElementById('center-text').textContent = 'üèÜ Mode Tournoi'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/earth.png" 
						alt="Tournament"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
				
				<!-- Bouton Skin -->
				<a href="/skin" 
				class="absolute block w-[125px] h-[125px]" 
				style="top: 65%; right: 175px;"
				onmouseover="document.getElementById('center-text').textContent = 'üé® Personnalisation'"
				onmouseout="document.getElementById('center-text').textContent = 'Choisissez votre destination !'">
					<img 
						src="/sprites/satellite.png" 
						alt="Skin"
						class="w-full h-full hover:scale-110 transition-transform cursor-pointer"
						style="image-rendering: pixelated;"
					/>
				</a>
		</div>

    `;
};

// ==============================================
// üìÑ ./src/views/LoginView.ts
// ==============================================
import type { ViewFunction } from "../router/types";
import { gsap } from "gsap";

export const LoginView: ViewFunction = () => {
    return `
        <!-- Fond avec grille anim√©e (m√™me que HomeView) -->
        <div class="fixed inset-0 bg-black overflow-hidden">
            <!-- Grille de fond -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
                background-size: 50px 50px;
                animation: gridMove 20s linear infinite;
            "></div>
            
            <style>
                @keyframes gridMove {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(50px); }
                }
                
                @keyframes neonPulse {
                    0%, 100% { 
                        text-shadow: 
                            0 0 10px rgba(59, 130, 246, 0.8),
                            0 0 20px rgba(59, 130, 246, 0.6),
                            0 0 30px rgba(59, 130, 246, 0.4);
                    }
                    50% { 
                        text-shadow: 
                            0 0 20px rgba(59, 130, 246, 1),
                            0 0 30px rgba(59, 130, 246, 0.8),
                            0 0 40px rgba(59, 130, 246, 0.6);
                    }
                }
                
                @keyframes scanline {
                    0% { transform: translateY(-100%); }
                    100% { transform: translateY(100vh); }
                }
                
                .pixel-font {
                    font-family: 'Courier New', monospace;
                    font-weight: bold;
                    letter-spacing: 0.1em;
                }
                
                .neon-border {
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    border: 3px solid rgba(59, 130, 246, 0.8);
                }
                
                .neon-border:hover {
                    box-shadow: 
                        0 0 20px rgba(59, 130, 246, 0.8),
                        inset 0 0 20px rgba(59, 130, 246, 0.3);
                    border-color: rgba(59, 130, 246, 1);
                }
                
                .neon-input {
                    background: rgba(15, 23, 42, 0.6);
                    border: 2px solid rgba(59, 130, 246, 0.5);
                    color: #60A5FA;
                    transition: all 0.3s ease;
                }
                
                .neon-input:focus {
                    outline: none;
                    border-color: rgba(59, 130, 246, 1);
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    background: rgba(15, 23, 42, 0.8);
                }
                
                .neon-input::placeholder {
                    color: rgba(96, 165, 250, 0.4);
                }
            </style>
            
            <!-- Scanline effect -->
            <div class="absolute inset-0 pointer-events-none opacity-10">
                <div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
            </div>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header avec BackButton -->
            <div class="p-8">
                <button 
                    onclick="history.back()" 
                    class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
                    id="back-button"
                >
                    ‚Üê BACK
                </button>
            </div>

            <!-- Zone centrale -->
            <div class="flex-1 flex items-center justify-center px-4 py-12">
                <div class="w-full max-w-6xl grid grid-cols-1 md:grid-cols-2 gap-8">
                    
                    <!-- C√¥t√© gauche - Animation/Image -->
                    <div class="flex items-center justify-center p-8" id="left-panel">
                        <div class="relative w-full h-full min-h-[400px] neon-border bg-black/50 backdrop-blur-sm rounded-lg overflow-hidden flex items-center justify-center">
                            <!-- GIF ou animation -->
                            <img 
                                src="/sprites/cat.gif" 
                                alt="Animation"
                                class="w-full h-full object-contain"
                                style="image-rendering: pixelated;"
                            />
                            
                            <!-- Overlay avec effet n√©on -->
                            <div class="absolute inset-0 pointer-events-none" style="
                                background: radial-gradient(circle at center, transparent 40%, rgba(59, 130, 246, 0.1) 100%);
                            "></div>
                        </div>
                    </div>

                    <!-- C√¥t√© droit - Formulaire -->
                    <div class="flex flex-col justify-center p-8 neon-border bg-black/50 backdrop-blur-sm rounded-lg" id="right-panel">
                        <!-- Titre -->
                        <div class="text-center mb-8">
                            <h1 class="pixel-font text-4xl md:text-5xl text-blue-400 mb-2" 
                                style="animation: neonPulse 2s ease-in-out infinite;"
                                id="login-title">
                                HELLO!
                            </h1>
                            <h2 class="pixel-font text-xl md:text-2xl text-blue-300 opacity-80">
                                Login your account
                            </h2>
                        </div>

                        <!-- Formulaire -->
                        <form action="/login" method="POST" id="loginForm" class="space-y-6">
                            <!-- Username -->
                            <div>
                                <label for="username" class="block mb-2 pixel-font text-sm text-blue-300">
                                    USERNAME:
                                </label>
                                <input 
                                    type="text" 
                                    id="username" 
                                    name="username"
                                    placeholder="Enter your username"
                                    required
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Password -->
                            <div>
                                <label for="password" class="block mb-2 pixel-font text-sm text-blue-300">
                                    PASSWORD:
                                </label>
                                <input 
                                    type="password" 
                                    id="password" 
                                    name="password"
                                    placeholder="Enter your password"
                                    required
                                    class="w-full p-3 rounded pixel-font text-sm neon-input"
                                >
                            </div>

                            <!-- Bouton Submit -->
                            <button 
                                type="submit" 
                                class="w-full py-3 pixel-font text-sm neon-border bg-blue-500/20 text-blue-400 hover:bg-blue-500/40 hover:text-white transition-all"
                                id="submit-btn"
                            >
                                >>> SUBMIT <<<
                            </button>
                        </form>

                        <!-- Lien vers cr√©ation de compte -->
                        <div class="mt-6 text-center">
                            <p class="pixel-font text-xs text-blue-300/60 mb-3">
                                Don't have an account?
                            </p>
                            <a 
                                href="/create" 
                                class="pixel-font text-sm text-blue-400 hover:text-blue-300 transition-colors inline-block"
                            >
                                >>> CREATE ACCOUNT <<<
                            </a>
                        </div>c
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
                <p>¬© 2025 PONG - SKILL ISSUE</p>
            </footer>
        </div>
    `;
};

export const loginLogic = (): (() => void) => {
    // Animations d'entr√©e avec GSAP
    gsap.from('#login-title', {
        scale: 0.5,
        opacity: 0,
        duration: 1,
        ease: 'back.out(1.7)'
    });

    gsap.from('#left-panel', {
        x: -100,
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
    });

    gsap.from('#right-panel', {
        x: 100,
        opacity: 0,
        duration: 0.8,
        ease: 'power2.out'
    });

    // Gestion du formulaire
    const form = document.getElementById('loginForm') as HTMLFormElement;
    
    const handleSubmit = (e: Event) => {
        e.preventDefault();
        
        const username = (document.getElementById('username') as HTMLInputElement).value;
        const password = (document.getElementById('password') as HTMLInputElement).value;

        // Animation du bouton
        const submitBtn = document.getElementById('submit-btn');
        if (submitBtn) {
            gsap.to(submitBtn, {
                scale: 0.95,
                duration: 0.1,
                yoyo: true,
                repeat: 1
            });
        }

        // TODO: Logique de connexion r√©elle
        console.log('Login attempt:', { username, password });
        
        // Exemple de redirection apr√®s succ√®s
        // window.router.navigate('/');
    };

    if (form) {
        form.addEventListener('submit', handleSubmit);
    }

    // Cleanup
    return () => {
        if (form) {
            form.removeEventListener('submit', handleSubmit);
        }
    };
};

// ==============================================
// üìÑ ./src/views/HomeView.ts
// ==============================================
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";

export const HomeView: ViewFunction = () => {
    return `
        <!-- Fond avec grille anim√©e -->
        <div class="fixed inset-0 bg-black overflow-hidden">
            <!-- Grille de fond -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
                background-size: 50px 50px;
                animation: gridMove 20s linear infinite;
            "></div>
            
            <style>
                @keyframes gridMove {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(50px); }
                }
                
                @keyframes neonPulse {
                    0%, 100% { 
                        text-shadow: 
                            0 0 10px rgba(59, 130, 246, 0.8),
                            0 0 20px rgba(59, 130, 246, 0.6),
                            0 0 30px rgba(59, 130, 246, 0.4);
                    }
                    50% { 
                        text-shadow: 
                            0 0 20px rgba(59, 130, 246, 1),
                            0 0 30px rgba(59, 130, 246, 0.8),
                            0 0 40px rgba(59, 130, 246, 0.6);
                    }
                }
                
                @keyframes scanline {
                    0% { transform: translateY(-100%); }
                    100% { transform: translateY(100vh); }
                }
                
                .pixel-font {
                    font-family: 'Courier New', monospace;
                    font-weight: bold;
                    letter-spacing: 0.1em;
                }
                
                .neon-border {
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    border: 3px solid rgba(59, 130, 246, 0.8);
                }
                
                .neon-border:hover {
                    box-shadow: 
                        0 0 20px rgba(59, 130, 246, 0.8),
                        inset 0 0 20px rgba(59, 130, 246, 0.3);
                    border-color: rgba(59, 130, 246, 1);
                }
                
                .game-card {
                    transition: all 0.3s ease;
                    background: rgba(15, 23, 42, 0.8);
                    backdrop-filter: blur(10px);
                }
                
                .game-card:hover {
                    transform: translateY(-10px) scale(1.02);
                    background: rgba(30, 41, 59, 0.9);
                }
            </style>
            
            <!-- Scanline effect -->
            <div class="absolute inset-0 pointer-events-none opacity-10">
                <div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
            </div>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header avec PONG et bouton connexion -->
            <header class="flex justify-between items-center px-8 py-6">
                <!-- Logo PONG -->
                <div class="pixel-font text-4xl md:text-5xl text-blue-400" style="animation: neonPulse 2s ease-in-out infinite;">
                    PONG
                </div>
                
                <!-- Bouton Connexion -->
                <a href="/login" 
                   class="pixel-font bg-blue-500 opacity-80 text-black px-6 py-3 text-sm md:text-base hover:bg-blue-400 transition-all neon-border flex items-center gap-2">
                    <span>SIGN IN</span>
                </a>
            </header>

            <!-- Ligne horizontale n√©on -->
            <div class="w-full h-1 bg-gradient-to-r from-transparent via-blue-500 to-transparent opacity-50"></div>

            <!-- Zone centrale -->
            <div class="flex-1 flex flex-col items-center justify-center px-4 py-12">
                <!-- Titre principal -->
                <div class="text-center mb-8">
                    <h1 class="pixel-font text-6xl md:text-8xl text-blue-400 mb-4" 
                        style="animation: neonPulse 2s ease-in-out infinite;"
                        id="main-title">
                        PONG
                    </h1>
                    <p class="pixel-font text-lg md:text-xl text-blue-300 tracking-wider">
                        >>> SKILL ISSUE <<<
                    </p>
                </div>

                <!-- Stats en temps r√©el -->
                <div class="flex gap-8 md:gap-16 mb-16" id="stats-display">
                    <div class="text-center">
                        <div class="pixel-font text-5xl md:text-6xl text-blue-400" id="players-count">0</div>
                        <div class="pixel-font text-xs md:text-sm text-blue-300 mt-2">PLAYER</div>
                    </div>
                    <div class="text-center">
                        <div class="pixel-font text-5xl md:text-6xl text-blue-400" id="games-count">0</div>
                        <div class="pixel-font text-xs md:text-sm text-blue-300 mt-2">IN GAME</div>
                    </div>
                    <div class="text-center">
                        <div class="pixel-font text-5xl md:text-6xl text-blue-400" id="online-count">0</div>
                        <div class="pixel-font text-xs md:text-sm text-blue-300 mt-2">ONLINE</div>
                    </div>
                </div>

                <!-- Cartes de jeu -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 w-full max-w-4xl mb-12">
                    <!-- QuickPlay Card -->
                    <a href="/play" 
                       class="game-card group relative p-8 md:p-12 neon-border hover:cursor-pointer"
                       id="quickplay-card"
                       style="opacity: 0; transform: translateY(100px);">
                        <!-- Ic√¥ne -->
                        <div class="text-6xl md:text-7xl mb-6 text-center text-blue-500">
                            ‚ö°
                        </div>
                        
                        <!-- Titre -->
                        <h2 class="pixel-font text-2xl md:text-3xl text-blue-400 text-center opacity-80 mb-4">
                            QUICKPLAY
                        </h2>
                        
                        <!-- Description -->
                        <p class="pixel-font text-sm text-blue-300 text-center opacity-80">
                            Time to train
                        </p>
                        
                        <!-- Fl√®ches d√©coratives -->
                        <div class="absolute top-4 left-4 text-red-500 text-2xl opacity-80">‚Üê</div>
                        <div class="absolute bottom-4 right-4 text-red-500 text-2xl opacity-80">‚Üí</div>
                    </a>

                    <!-- Tournois Card -->
                    <a href="/tournament" 
                       class="game-card group relative p-8 md:p-12 neon-border hover:cursor-pointer"
                       id="tournament-card"
                       style="opacity: 0; transform: translateY(100px);">
                        <!-- Ic√¥ne -->
                        <div class="text-6xl md:text-7xl mb-6 text-center">
                            üèÜ
                        </div>
                        
                        <!-- Titre -->
                        <h2 class="pixel-font text-2xl md:text-3xl text-red-500 text-center opacity-80 mb-4">
                            TOURNAMENT
                        </h2>
                        
                        <!-- Description -->
                        <p class="pixel-font text-sm text-blue-300 text-center opacity-80">
							Compete against the best players
                        </p>
                        
                        <!-- Fl√®ches d√©coratives -->
                        <div class="absolute top-4 left-4 text-blue-500 text-2xl opacity-80">‚Üê</div>
                        <div class="absolute bottom-4 right-4 text-blue-500 text-2xl opacity-80">‚Üí</div>
                    </a>
                </div>

                <!-- Leaderboard -->
                <div class="w-full max-w-4xl neon-border p-6" style="background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(10px);">
                    <h3 class="pixel-font text-xl md:text-2xl text-blue-400 mb-6 flex items-center gap-2">
                        <span>üëë</span>
                        <span>RANKING</span>
                    </h3>
                    
                    <div id="leaderboard-container" class="overflow-hidden">
                        <p class="pixel-font text-sm text-blue-300 text-center py-4">Loading...</p>
                    </div>
                </div>
				<div class="mt-8">
					<a href="/blockchain" class="pixel-font text-purple-400 hover:text-purple-300 text-sm flex items-center justify-center gap-2 transition-colors">
						<span>VIEW BLOCKCHAIN REGISTRY</span>
					</a>
				</div>
            </div>

            <!-- Footer -->
            <footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
                <p>¬© 2025 PONG - SKILL ISSUE</p>
            </footer>
        </div>
    `;
};

export const homeLogic = (): CleanupFunction => {
    // Animation d'entr√©e du titre
    gsap.to('#main-title', {
        scale: 1,
        opacity: 1,
        duration: 1,
        ease: 'back.out(1.7)'
    });

    // Animation des stats (depuis l'√©tat initial dans le HTML)
    gsap.to('#stats-display > div', {
        y: 0,
        opacity: 1,
        duration: 0.8,
        stagger: 0.2,
        ease: 'power2.out'
    });

    // Animation des cartes de jeu - UNE SEULE FOIS
    gsap.to('#quickplay-card', {
        y: 0,
        opacity: 1,
        duration: 1,
        delay: 0.5,
        ease: 'power3.out'
    });

    gsap.to('#tournament-card', {
        y: 0,
        opacity: 1,
        duration: 1,
        delay: 0.8,
        ease: 'power3.out'
    });

    // Animation des chiffres (compteur)
    const animateCounter = (id: string, target: number) => {
        const element = document.getElementById(id);
        if (!element) return;

        gsap.to({ val: 0 }, {
            val: target,
            duration: 2,
            ease: 'power1.inOut',
            onUpdate: function() {
                element.textContent = Math.floor(this.targets()[0].val).toString();
            }
        });
    };

    // Charger les stats globales
    const loadGlobalStats = async () => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/gamedb/stats/global`);
            const data = await response.json();
            
            if (data.success && data.stats) {
                animateCounter('players-count', data.stats.total_users);
                animateCounter('games-count', data.stats.active_games);
                animateCounter('online-count', data.stats.online_players);
            }
        } catch (err) {
            console.error('Error loading global stats:', err);
            // Valeurs par d√©faut en cas d'erreur
            animateCounter('players-count', 0);
            animateCounter('games-count', 0);
            animateCounter('online-count', 0);
        }
    };

    // Charger les stats du leaderboard
    const loadLeaderboard = async () => {
        try {
            const response = await fetch('/gamedb/users/leaderboard');
            const data = await response.json();
            
            if (data.success && data.leaderboard) {
                const container = document.getElementById('leaderboard-container');
                if (container) {
                    const topPlayers = data.leaderboard.slice(0, 5);
                    
                    container.innerHTML = `
                        <div class="space-y-2">
                            ${topPlayers.map((user: any, index: number) => `
                                <div class="flex items-center justify-between p-3 ${index % 2 === 0 ? 'bg-blue-950/20' : 'bg-transparent'} hover:bg-blue-900/30 transition-colors">
                                    <div class="flex items-center gap-4">
                                        <span class="pixel-font text-xl ${index === 0 ? 'text-yellow-400' : index === 1 ? 'text-gray-300' : index === 2 ? 'text-orange-600' : 'text-blue-400'}">
                                            ${index + 1}
                                        </span>
                                        <span class="pixel-font text-sm text-blue-300">${user.username}</span>
                                    </div>
                                    <div class="flex gap-6 text-xs pixel-font">
                                        <span class="text-blue-400">${user.total_games || 0} parties</span>
                                        <span class="text-green-400">${user.total_wins || 0} victoires</span>
                                        <span class="text-pink-400">${user.win_rate || 0}%</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <a href="/history" class="block mt-4 text-center pixel-font text-sm text-blue-400 hover:text-blue-300 transition-colors">
                            >>> View the complete history <<<
                        </a>
                    `;
                }
            }
        } catch (err) {
            console.error('Error loading leaderboard:', err);
            const container = document.getElementById('leaderboard-container');
            if (container) {
                container.innerHTML = `
                    <p class="pixel-font text-sm text-pink-500 text-center py-4">
                        ‚ö†Ô∏è Loading error
                    </p>
                `;
            }
        }
    };

    // Charger les donn√©es au d√©marrage
    loadGlobalStats();
    loadLeaderboard();

    // Rafra√Æchir les stats toutes les 30 secondes
    const statsInterval = setInterval(loadGlobalStats, 30000);

    // Arr√™ter le polling si l'utilisateur quitte l'onglet
    const handleVisibilityChange = () => {
        if (document.hidden) {
            clearInterval(statsInterval);
        } else {
            loadGlobalStats(); // Refresh imm√©diat au retour
        }
    };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // Cleanup
    return () => {
        clearInterval(statsInterval);
        document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
};

// ==============================================
// üìÑ ./src/views/WaitingRoomView.ts
// ==============================================
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";

export const WaitingRoomView: ViewFunction = () => {
    return `
        <!-- Fond avec grille anim√©e -->
        <div class="fixed inset-0 bg-black overflow-hidden">
            <!-- Grille de fond -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
                background-size: 50px 50px;
                animation: gridMove 20s linear infinite;
            "></div>
            
            <style>
                @keyframes gridMove {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(50px); }
                }
                
                @keyframes neonPulse {
                    0%, 100% { 
                        text-shadow: 
                            0 0 10px rgba(59, 130, 246, 0.8),
                            0 0 20px rgba(59, 130, 246, 0.6),
                            0 0 30px rgba(59, 130, 246, 0.4);
                    }
                    50% { 
                        text-shadow: 
                            0 0 20px rgba(59, 130, 246, 1),
                            0 0 30px rgba(59, 130, 246, 0.8),
                            0 0 40px rgba(59, 130, 246, 0.6);
                    }
                }
                
                @keyframes scanline {
                    0% { transform: translateY(-100%); }
                    100% { transform: translateY(100vh); }
                }

                @keyframes rotate {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }

                @keyframes float {
                    0%, 100% { transform: translateY(0px); }
                    50% { transform: translateY(-20px); }
                }

                @keyframes ping {
                    0% { transform: scale(1); opacity: 1; }
                    75%, 100% { transform: scale(2); opacity: 0; }
                }
                
                .pixel-font {
                    font-family: 'Courier New', monospace;
                    font-weight: bold;
                    letter-spacing: 0.1em;
                }
                
                .neon-border {
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    border: 3px solid rgba(59, 130, 246, 0.8);
                }
                
                .neon-border:hover {
                    box-shadow: 
                        0 0 20px rgba(59, 130, 246, 0.8),
                        inset 0 0 20px rgba(59, 130, 246, 0.3);
                    border-color: rgba(59, 130, 246, 1);
                }

                .spinner {
                    border: 4px solid rgba(59, 130, 246, 0.1);
                    border-left-color: rgba(59, 130, 246, 1);
                    border-radius: 50%;
                    width: 120px;
                    height: 120px;
                    animation: rotate 1s linear infinite;
                }

                .pulse-ring {
                    position: absolute;
                    border: 4px solid rgba(59, 130, 246, 0.6);
                    border-radius: 50%;
                    animation: ping 1.5s cubic-bezier(0, 0, 0.2, 1) infinite;
                }

                .player-card {
                    transition: all 0.3s ease;
                    background: rgba(15, 23, 42, 0.6);
                    backdrop-filter: blur(10px);
                }

                .status-indicator {
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: #10b981;
                    box-shadow: 0 0 10px #10b981;
                    animation: neonPulse 2s ease-in-out infinite;
                }
            </style>
            
            <!-- Scanline effect -->
            <div class="absolute inset-0 pointer-events-none opacity-10">
                <div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
            </div>

            <!-- Particules flottantes -->
            ${Array.from({length: 30}, (_, i) => `
                <div 
                    class="absolute bg-blue-400 rounded-full opacity-20"
                    style="
                        width: ${2 + Math.random() * 3}px;
                        height: ${2 + Math.random() * 3}px;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        animation: float ${10 + Math.random() * 20}s ease-in-out ${Math.random() * 5}s infinite;
                    "
                ></div>
            `).join('')}
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header avec BackButton -->
            <header class="flex justify-between items-center px-8 py-6">
                <button 
                    onclick="history.back()" 
                    class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
                    id="back-button"
                >
                    ‚Üê BACK
                </button>
                
                <!-- Status indicator -->
                <div class="flex items-center gap-3 neon-border bg-black/50 backdrop-blur-sm rounded-lg px-4 py-2">
                    <div class="status-indicator"></div>
                    <span class="pixel-font text-sm text-blue-300">SEARCHING</span>
                </div>
            </header>

            <!-- Zone centrale -->
            <div class="flex-1 flex items-center justify-center px-4 py-12">
                <div class="w-full max-w-4xl">
                    
                    <!-- Titre principal -->
                    <div class="text-center mb-12">
                        <h1 class="pixel-font text-5xl md:text-7xl text-blue-400 mb-4" 
                            style="animation: neonPulse 2s ease-in-out infinite;"
                            id="waiting-title">
                            SEARCHING FOR OPPONENT
                        </h1>
                        <p class="pixel-font text-lg text-blue-300 opacity-80" id="waiting-subtitle">
                            >>> PREPARING YOUR MATCH <<<
                        </p>
                    </div>

                    <!-- Animation de recherche -->
                    <div class="flex justify-center mb-12" id="search-animation">
                        <div class="relative">
                            <!-- Spinner principal -->
                            <div class="spinner"></div>
                            
                            <!-- Anneaux de pulse -->
                            <div class="pulse-ring" style="width: 120px; height: 120px; animation-delay: 0s;"></div>
                            <div class="pulse-ring" style="width: 120px; height: 120px; animation-delay: 0.5s;"></div>
                            <div class="pulse-ring" style="width: 120px; height: 120px; animation-delay: 1s;"></div>
                        </div>
                    </div>

                    <!-- Informations du joueur -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                        <!-- Votre carte -->
                        <div class="player-card neon-border rounded-lg p-6" id="your-card">
                            <div class="flex items-center gap-4 mb-4">
                                <div class="w-16 h-16 rounded-full bg-blue-500/20 flex items-center justify-center border-2 border-blue-500/50">
                                    <span class="text-3xl">üë§</span>
                                </div>
                                <div class="flex-1">
                                    <div class="pixel-font text-xs text-blue-300/60 mb-1">YOU</div>
                                    <div class="pixel-font text-xl text-blue-400" id="your-username">Player</div>
                                </div>
                                <div class="status-indicator"></div>
                            </div>
                            
                            <!-- Skill s√©lectionn√© -->
                            <div class="mt-4 pt-4 border-t border-blue-500/30">
                                <div class="pixel-font text-xs text-blue-300/60 mb-2">SELECTED SKILL:</div>
                                <div class="flex items-center gap-2" id="your-skill">
                                    <span class="text-2xl">üí•</span>
                                    <span class="pixel-font text-lg text-blue-300">SMASH</span>
                                </div>
                            </div>
                        </div>

                        <!-- Carte adversaire (en attente) -->
                        <div class="player-card neon-border rounded-lg p-6 opacity-50" id="opponent-card">
                            <div class="flex items-center gap-4 mb-4">
                                <div class="w-16 h-16 rounded-full bg-gray-500/20 flex items-center justify-center border-2 border-gray-500/50">
                                    <span class="text-3xl">‚ùì</span>
                                </div>
                                <div class="flex-1">
                                    <div class="pixel-font text-xs text-gray-400 mb-1">OPPONENT</div>
                                    <div class="pixel-font text-xl text-gray-400">Waiting...</div>
                                </div>
                                <div class="w-3 h-3 rounded-full bg-gray-500"></div>
                            </div>
                            
                            <div class="mt-4 pt-4 border-t border-gray-500/30">
                                <div class="pixel-font text-xs text-gray-400 mb-2">SKILL:</div>
                                <div class="pixel-font text-lg text-gray-400">???</div>
                            </div>
                        </div>
                    </div>

                    <!-- Status message -->
                    <div class="neon-border bg-black/50 backdrop-blur-sm rounded-lg p-6 mb-6" id="status-container">
                        <div class="flex items-center justify-center gap-3">
                            <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                            <p class="pixel-font text-sm text-blue-300 text-center" id="status-message">
                                Looking for available players...
                            </p>
                            <div class="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                        </div>
                    </div>

                    <!-- Bouton Cancel -->
                    <div class="text-center">
                        <button 
                            id="cancel-btn"
                            class="pixel-font px-8 py-4 neon-border bg-red-500/20 text-red-400 hover:bg-red-500/40 hover:text-white transition-all relative group"
                        >
                            <span class="relative z-10">>>> CANCEL SEARCH <<<</span>
                            <div class="absolute inset-0 bg-red-500/0 group-hover:bg-red-500/10 transition-all rounded"></div>
                        </button>
                    </div>

                    <!-- Tips -->
                    <div class="mt-8 text-center">
                        <div class="inline-block neon-border bg-blue-500/10 rounded-lg px-6 py-3">
                            <p class="pixel-font text-xs text-blue-300/60">
                                üí° TIP: Use SPACE to activate your skill at the right moment!
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
                <p>¬© 2025 PONG - SKILL ISSUE</p>
            </footer>
        </div>
    `;
};

export const waitingRoomLogic = (): CleanupFunction => {
    console.log('üéÆ WaitingRoomView: Initializing...');

    let pollInterval: number | null = null;
    let roomId: string | null = null;
    const skill = (sessionStorage.getItem('selectedSkill') as 'smash' | 'dash' | null) || 'smash';

    // ‚úÖ D√âFINIR l'√©tat initial AVANT d'animer
    gsap.set('#waiting-title', { scale: 0.5, opacity: 0 });
    gsap.set('#waiting-subtitle', { y: 20, opacity: 0 });
    gsap.set('#search-animation', { scale: 0, opacity: 0 });
    gsap.set('#your-card', { x: -100, opacity: 0 });
    gsap.set('#opponent-card', { x: 100, opacity: 0 });
    gsap.set('#status-container', { y: 50, opacity: 0 });
    gsap.set('#cancel-btn', { y: 50, opacity: 0 });

    // ‚úÖ PUIS animer vers l'√©tat final
    setTimeout(() => {
        gsap.to('#waiting-title', {
            scale: 1,
            opacity: 1,
            duration: 1,
            ease: 'back.out(1.7)'
        });

        gsap.to('#waiting-subtitle', {
            y: 0,
            opacity: 1,
            duration: 0.8,
            delay: 0.3,
            ease: 'power2.out'
        });

        gsap.to('#search-animation', {
            scale: 1,
            opacity: 1,
            duration: 0.8,
            delay: 0.5,
            ease: 'back.out(1.7)'
        });

        gsap.to('#your-card', {
            x: 0,
            opacity: 1,
            duration: 0.8,
            delay: 0.7,
            ease: 'power2.out'
        });

        gsap.to('#opponent-card', {
            x: 0,
            opacity: 1,
            duration: 0.8,
            delay: 0.7,
            ease: 'power2.out'
        });

        gsap.to('#status-container', {
            y: 0,
            opacity: 1,
            duration: 0.8,
            delay: 0.9,
            ease: 'power2.out'
        });

        gsap.to('#cancel-btn', {
            y: 0,
            opacity: 1,
            duration: 0.8,
            delay: 1.1,
            ease: 'power2.out'
        });
    }, 50);

    // Mettre √† jour l'affichage du username et du skill
    const updatePlayerInfo = (): void => {
        const username = window.simpleAuth.getUsername() || 'Player';
        const usernameElement = document.getElementById('your-username');
        if (usernameElement) {
            usernameElement.textContent = username;
        }

        const skillElement = document.getElementById('your-skill');
        if (skillElement) {
            const skillIcon = skill === 'dash' ? '‚ö°' : 'üí•';
            const skillName = skill === 'dash' ? 'DASH' : 'SMASH';
            skillElement.innerHTML = `
                <span class="text-2xl">${skillIcon}</span>
                <span class="pixel-font text-lg text-blue-300">${skillName}</span>
            `;
        }
    };

    const updateStatus = (message: string): void => {
        const statusMessage = document.getElementById('status-message');
        if (statusMessage) {
            statusMessage.textContent = message;
        }
    };

    const handleJoin = async (): Promise<void> => {
        const username = window.simpleAuth.getUsername() || 'Player';
        const playerId = window.simpleAuth.getPlayerId();

        updateStatus('Connecting to matchmaking...');

        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/quickplay/join`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, playerId, selectedSkill: skill })
            });
            const data = await response.json();
            
            if (data.success) {
                roomId = data.roomId;
                updateStatus('Waiting for opponent...');
                startPolling();
            } else {
                updateStatus('Error: ' + (data.error || 'Failed to join'));
            }
        } catch (err) {
            console.error(err);
            updateStatus('Connection error');
        }
    };

    const startPolling = (): void => {
        pollInterval = setInterval(async () => {
            if (!roomId) return;
            
            try {
                const host = import.meta.env.VITE_HOST || 'localhost:8443';
                const response = await fetch(`https://${host}/quickplay/status/${roomId}`);
                const data = await response.json();
                
                if (data.status === 'ready') {
                    updateStatus('Opponent found! Preparing game...');
                    
                    // Animation de transition
                    const opponentCard = document.getElementById('opponent-card');
                    if (opponentCard) {
                        gsap.to(opponentCard, {
                            opacity: 1,
                            duration: 0.5,
                            ease: 'power2.out'
                        });
                    }
                    
                    stopPolling();
                    sessionStorage.setItem('gameWsURL', data.gameServerURL);
                    
                    setTimeout(() => {
						// set "game3d/" path or "game/"
						const viewMode = sessionStorage.getItem('viewMode') || '2d';
						const viewPath = viewMode === '3d' ? 'game3d' : 'game';
                        window.router.navigate(`/${viewPath}/${roomId}`);
                    }, 1000);
                }
            } catch (err) {
                console.error('Polling error:', err);
            }
        }, 2000);
        
        console.log('üîÑ Started polling for opponent');
    };

    const stopPolling = (): void => {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
            console.log('üõë Stopped polling');
        }
    };

    const handleCancel = (): void => {
        stopPolling();
        
        // Animation de sortie
        gsap.to('#waiting-title, #search-animation, #your-card, #opponent-card, #status-container', {
            opacity: 0,
            y: -50,
            duration: 0.5,
            ease: 'power2.in',
            onComplete: () => {
                window.router.navigate('/play');
            }
        });
    };

    // D√©marrer apr√®s un court d√©lai
    setTimeout(() => {
        updatePlayerInfo();
        handleJoin();
    }, 100);

    // Attacher le handler du bouton Cancel
    const cancelBtn = document.getElementById('cancel-btn');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', handleCancel);
    }

    // Cleanup
    return (): void => {
        console.log('üßπ WaitingRoomView: Cleaning up...');
        stopPolling();
        if (cancelBtn) {
            cancelBtn.removeEventListener('click', handleCancel);
        }
    };
};

// ==============================================
// üìÑ ./src/views/BlockchainView.ts
// ==============================================
// apps/frontend/src/views/BlockchainView.ts
import type { ViewFunction, CleanupFunction } from "../router/types";
import { BackButton } from "../components/Button";
import { gsap } from "gsap";

interface BlockchainTournament {
    tournamentName: string;
    maxPlayers: number;
    winnerId: string;
    winnerUsername: string;
    timestamp: string; // BigInt serialis√©
}

interface LocalGame {
    tournament_id?: string;
    game_type: string;
    created_at: string;
}

export const BlockchainView: ViewFunction = () => {
    return `
        <!-- Fond "Blockchain" -->
        <div class="fixed inset-0 bg-[#02040a] overflow-hidden">
            <!-- Grille Hexagonale ou Digitale -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(139, 92, 246, 0.05) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(139, 92, 246, 0.05) 1px, transparent 1px);
                background-size: 30px 30px;
                transform: perspective(500px) rotateX(60deg);
                transform-origin: center 80%;
                animation: gridFlow 20s linear infinite;
            "></div>

            <!-- Flux de donn√©es binaire en arri√®re plan -->
            ${Array.from({length: 20}, () => `
                <div class="absolute text-[#3b82f6] opacity-10 font-mono text-xs select-none" 
                     style="
                        left: ${Math.random() * 100}%; 
                        top: -20px; 
                        animation: binaryRain ${5 + Math.random() * 10}s linear infinite;
                        animation-delay: ${Math.random() * 5}s;
                     ">
                    ${Math.random().toString(2).substring(2, 10)}
                </div>
            `).join('')}

            <style>
                @keyframes gridFlow {
                    0% { background-position: 0 0; }
                    100% { background-position: 0 60px; }
                }
                @keyframes binaryRain {
                    0% { transform: translateY(-100%); opacity: 0; }
                    10% { opacity: 0.2; }
                    90% { opacity: 0.2; }
                    100% { transform: translateY(110vh); opacity: 0; }
                }
                @keyframes pulse-purple {
                    0%, 100% { box-shadow: 0 0 10px rgba(139, 92, 246, 0.3); border-color: rgba(139, 92, 246, 0.5); }
                    50% { box-shadow: 0 0 20px rgba(139, 92, 246, 0.6); border-color: rgba(139, 92, 246, 0.8); }
                }
                
                .crypto-card {
                    background: rgba(10, 10, 25, 0.7);
                    backdrop-filter: blur(12px);
                    border: 1px solid rgba(139, 92, 246, 0.3);
                    transition: all 0.3s ease;
                }
                .crypto-card:hover {
                    transform: translateY(-5px);
                    border-color: #8b5cf6;
                    box-shadow: 0 0 30px rgba(139, 92, 246, 0.2);
                }
                
                .hash-text {
                    font-family: 'Courier New', monospace;
                    letter-spacing: -0.5px;
                }
            </style>
        </div>

        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header -->
            <div class="p-8 flex justify-between items-start">
                ${BackButton({
                    size: "lg",
                    className: "text-center text-white z-10 p-4 rounded bg-[#0C154D]/20 backdrop-blur-sm border border-white/20 text-white hover:bg-[#1D31B8]/20"
                })}
                
                <!-- Badge Avalanche -->
                <div class="flex flex-col items-center gap-2">
                    <div class="flex items-center gap-2 px-4 py-2 rounded-full bg-red-500/10 border border-red-500/30">
                        <div class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
                        <span class="pixel-font text-xs text-red-400">AVALANCHE C-CHAIN</span>
                    </div>
                    <div class="text-xs text-white/30 mt-1 font-mono">CONTRACT: REGISTERED</div>
                </div>
            </div>

            <!-- Contenu -->
            <div class="container mx-auto px-8 pb-12">
                <div class="text-center mb-12">
                    <h1 class="pixel-font text-5xl font-bold md:text-6xl text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 mb-4 filter drop-shadow-lg">
                        BLOCKCHAIN REGISTRY
                    </h1>
                    <p class="pixel-font text-blue-300/60 tracking-widest">
                        IMMUTABLE TOURNAMENT RECORDS
                    </p>
                </div>

                <!-- Stats Bar -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12 max-w-4xl mx-auto">
                    <div class="crypto-card rounded-xl p-6 text-center">
                        <div class="text-purple-400 text-xs pixel-font mb-2">TOTAL VERIFIED</div>
                        <div id="total-tournaments" class="text-4xl font-bold text-white font-mono">0</div>
                    </div>
                    <div class="crypto-card rounded-xl p-6 text-center">
                        <div class="text-blue-400 text-xs pixel-font mb-2">NETWORK STATUS</div>
                        <div class="text-xl font-bold text-green-400 pixel-font mt-2">ONLINE</div>
                    </div>
                    <div class="crypto-card rounded-xl p-6 text-center">
                        <div class="text-pink-400 text-xs pixel-font mb-2">LATEST BLOCK</div>
                        <div id="block-height" class="text-xl font-bold text-white font-mono mt-2 animate-pulse">SYNCING...</div>
                    </div>
                </div>

                <!-- Loading -->
                <div id="blockchain-loading" class="flex flex-col items-center justify-center py-20">
                    <div class="relative w-24 h-24 mb-8">
                        <div class="absolute inset-0 border-4 border-purple-500/30 rounded-full"></div>
                        <div class="absolute inset-0 border-4 border-t-purple-500 rounded-full animate-spin"></div>
                        <div class="absolute inset-4 border-4 border-blue-500/30 rounded-full"></div>
                        <div class="absolute inset-4 border-4 border-b-blue-500 rounded-full animate-spin" style="animation-direction: reverse;"></div>
                    </div>
                    <p class="pixel-font text-purple-300 animate-pulse">CONNECTING TO NODE...</p>
                </div>

                <!-- Liste des Tournois -->
                <div id="blockchain-list" class="grid grid-cols-1 gap-6 max-w-5xl mx-auto hidden">
                    <!-- Les cartes seront inject√©es ici -->
                </div>

                <!-- Empty State -->
                <div id="blockchain-empty" class="hidden text-center py-20">
                    <div class="text-6xl mb-4 opacity-50">‚õìÔ∏è</div>
                    <h3 class="pixel-font text-2xl text-white mb-2">NO RECORDS FOUND</h3>
                    <p class="text-white/40 font-mono text-sm">The ledger is empty.</p>
                </div>
            </div>
        </div>
    `;
};

export const blockchainLogic = (): CleanupFunction => {
    const host = import.meta.env.VITE_HOST || 'localhost:8443';
    let isComponentMounted = true;

    gsap.from("h1", { y: -50, opacity: 0, duration: 1, ease: "power3.out" });
    gsap.from(".crypto-card", { 
        y: 50, opacity: 0, duration: 0.8, stagger: 0.1, delay: 0.3, ease: "back.out(1.7)" 
    });

    const blockInterval = setInterval(() => {
        const blockEl = document.getElementById('block-height');
        if (blockEl) {
            const height = Math.floor(Math.random() * 1000000) + 12000000;
            blockEl.textContent = `#${height}`;
        }
    }, 3000);

    const fetchBlockchainData = async () => {
        try {
            const response = await fetch(`https://${host}/blockchainback/tournaments/all`);
            
            if (!response.ok) throw new Error("Network response was not ok");
            
            const data = await response.json();

            if (isComponentMounted) {
                if (data.success) {
                    updateUI(data.tournaments);
                } else {
                    throw new Error(data.error || "Unknown error");
                }
            }

        } catch (err) {
            console.error("Blockchain fetch error:", err);
            if (isComponentMounted) {
                const loading = document.getElementById('blockchain-loading');
                if (loading) loading.innerHTML = `<p class="text-red-500 pixel-font">CONNECTION ERROR</p>`;
            }
        }
    };

    const updateUI = (tournaments: Array<{id: string, data: BlockchainTournament}>) => {
        const loading = document.getElementById('blockchain-loading');
        const list = document.getElementById('blockchain-list');
        const empty = document.getElementById('blockchain-empty');
        const countEl = document.getElementById('total-tournaments');

        if (loading) loading.style.display = 'none';
        if (countEl) countEl.textContent = tournaments.length.toString();

        if (tournaments.length === 0) {
            if (empty) empty.style.display = 'block';
            return;
        }

        if (list) {
            list.style.display = 'grid';
            list.innerHTML = tournaments.map((t) => {
                const date = new Date(Number(t.data.timestamp) * 1000).toLocaleString();
                const visualHash = '0x' + btoa(t.id).substring(0, 40).toLowerCase() + '...';

                return `
                <div class="crypto-card rounded-xl p-6 relative overflow-hidden group opacity-0 translate-y-4 tournament-item">
                    <!-- Effet shimmer -->
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent -translate-x-full group-hover:animate-[shimmer_1.5s_infinite]"></div>
                    
                    <div class="flex flex-col md:flex-row justify-between items-center gap-6">
                        <!-- Info Gauche -->
                        <div class="flex items-center gap-6">
                            <div class="w-16 h-16 rounded-lg bg-purple-900/30 border border-purple-500/30 flex items-center justify-center text-3xl">
                                üèÜ
                            </div>
                            <div>
                                <div class="flex items-center gap-3 mb-1">
                                    <h3 class="text-2xl font-bold text-white pixel-font">${t.data.tournamentName}</h3>
                                    <span class="px-2 py-0.5 rounded text-[10px] font-bold bg-green-500/20 text-green-400 border border-green-500/30">
                                        VERIFIED
                                    </span>
                                </div>
                                <div class="flex items-center gap-4 text-sm text-blue-200/60 font-mono">
                                    <span>Players: ${t.data.maxPlayers}</span>
                                    <span>‚Ä¢</span>
                                    <span>${date}</span>
                                </div>
                            </div>
                        </div>

                        <!-- Info Droite (Winner) -->
                        <div class="text-right">
                            <div class="text-xs text-purple-400 mb-1 pixel-font">WINNER</div>
                            <div class="text-xl text-white font-bold flex items-center justify-end gap-2">
                                <span>${t.data.winnerUsername}</span>
                                <span class="text-yellow-400">üëë</span>
                            </div>
                            <div class="mt-2 p-2 bg-black/40 rounded border border-white/10 flex items-center gap-2 cursor-help" title="Transaction Hash">
                                <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                                <span class="text-[10px] text-white/40 hash-text">${visualHash}</span>
                            </div>
                        </div>
                    </div>
                </div>
                `;
            }).join('');

            gsap.to(".tournament-item", {
                opacity: 1,
                y: 0,
                duration: 0.5,
                stagger: 0.1,
                ease: "power2.out"
            });
        }
    };

    fetchBlockchainData();

    return () => {
        isComponentMounted = false;
        clearInterval(blockInterval);
    };
};

// ==============================================
// üìÑ ./src/views/LocalTournamentBracketView.ts
// ==============================================
import type { ViewFunction, CleanupFunction } from "../router/types";
import { gsap } from "gsap";
import { LocalTournamentManager, type LocalTournament, type LocalMatch } from "../utils/localTournamentManager";

export const LocalTournamentBracketView: ViewFunction = () => {
	return `
		<!-- Fond avec grille anim√©e -->
		<div class="fixed inset-0 bg-black overflow-hidden">
			<div class="absolute inset-0" style="
				background-image:
					linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
					linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
				background-size: 50px 50px;
				animation: gridMove 20s linear infinite;
			"></div>

			<style>
				@keyframes gridMove {
					0% { transform: translateY(0); }
					100% { transform: translateY(50px); }
				}

				@keyframes neonPulse {
					0%, 100% {
						text-shadow:
							0 0 10px rgba(59, 130, 246, 0.8),
							0 0 20px rgba(59, 130, 246, 0.6),
							0 0 30px rgba(59, 130, 246, 0.4);
					}
					50% {
						text-shadow:
							0 0 20px rgba(59, 130, 246, 1),
							0 0 30px rgba(59, 130, 246, 0.8),
							0 0 40px rgba(59, 130, 246, 0.6);
					}
				}

				@keyframes scanline {
					0% { transform: translateY(-100%); }
					100% { transform: translateY(100vh); }
				}

				.pixel-font {
					font-family: 'Courier New', monospace;
					font-weight: bold;
					letter-spacing: 0.1em;
				}

				.neon-border {
					box-shadow:
						0 0 10px rgba(59, 130, 246, 0.5),
						inset 0 0 10px rgba(59, 130, 246, 0.2);
					border: 3px solid rgba(59, 130, 246, 0.8);
				}

				.match-card {
					transition: all 0.3s ease;
					background: rgba(15, 23, 42, 0.8);
					backdrop-filter: blur(10px);
					position: relative;
					min-width: 200px;
				}

				.match-card.finished {
					border-color: rgba(34, 197, 94, 0.8);
				}

				.match-card.ready {
					border-color: rgba(234, 179, 8, 0.8);
					animation: matchPulse 2s ease-in-out infinite;
				}

				.match-card.in_progress {
					border-color: rgba(239, 68, 68, 0.8);
					animation: matchPulse 2s ease-in-out infinite;
				}

				@keyframes matchPulse {
					0%, 100% {
						box-shadow: 0 0 10px currentColor;
					}
					50% {
						box-shadow: 0 0 20px currentColor;
					}
				}

				.player-slot {
					transition: all 0.2s ease;
				}

				.player-slot.winner {
					background: rgba(34, 197, 94, 0.2);
					border-color: rgba(34, 197, 94, 0.5);
				}

				.player-slot.loser {
					opacity: 0.5;
				}

				.bracket-tree {
					display: flex;
					gap: 80px;
					padding: 40px;
					overflow-x: auto;
					min-height: 600px;
				}

				.round-column {
					display: flex;
					flex-direction: column;
					justify-content: space-around;
					min-width: 220px;
					position: relative;
				}

				.round-header {
					text-align: center;
					margin-bottom: 20px;
					position: sticky;
					top: 0;
					background: rgba(4, 7, 26, 0.9);
					padding: 10px;
					border-radius: 8px;
					z-index: 10;
				}

				.winner-modal {
					position: fixed;
					top: 0;
					left: 0;
					width: 100%;
					height: 100%;
					background: rgba(0, 0, 0, 0.9);
					display: flex;
					align-items: center;
					justify-content: center;
					z-index: 1000;
				}

				.winner-modal.hidden {
					display: none;
				}
			</style>

			<div class="absolute inset-0 pointer-events-none opacity-10">
				<div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
			</div>
		</div>

		<!-- Contenu principal -->
		<div class="relative z-10 min-h-screen flex flex-col">
			<header class="flex justify-between items-center px-8 py-6">
				<button
					id="exit-tournament-btn"
					class="pixel-font px-6 py-3 neon-border bg-transparent text-red-400 hover:bg-red-500/10 transition-all"
				>
					EXIT TOURNAMENT
				</button>

				<div class="pixel-font text-blue-400 text-sm">
					<span id="tournament-status">Round 1</span>
				</div>
			</header>

			<div class="flex-1 overflow-y-auto">
				<!-- Titre -->
				<div class="text-center py-6">
					<h1 class="pixel-font text-4xl md:text-5xl text-blue-400"
						style="animation: neonPulse 2s ease-in-out infinite;">
						üèÜ TOURNAMENT BRACKET üèÜ
					</h1>
				</div>

				<!-- Bracket Tree -->
				<div id="bracket-container" class="bracket-tree">
					<!-- Rounds will be generated here -->
				</div>

				<!-- Next Match Panel -->
				<div id="next-match-panel" class="fixed bottom-8 left-1/2 transform -translate-x-1/2 hidden">
					<div class="neon-border rounded-lg p-6 bg-black/90 backdrop-blur-lg">
						<div class="pixel-font text-center">
							<div class="text-blue-400 text-sm mb-2">NEXT MATCH</div>
							<div class="text-white text-lg mb-4" id="next-match-text">
								Player 1 vs Player 2
							</div>
							<button
								id="play-match-btn"
								class="pixel-font px-8 py-3 neon-border bg-green-500/20 text-green-400 hover:bg-green-500/40 transition-all"
							>
								PLAY MATCH
							</button>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Winner Modal -->
		<div id="winner-modal" class="winner-modal hidden">
			<div class="neon-border rounded-lg p-12 bg-black/90 backdrop-blur-lg text-center">
				<div class="pixel-font text-6xl text-yellow-400 mb-6" style="animation: neonPulse 2s ease-in-out infinite;">
					üèÜ CHAMPION üèÜ
				</div>
				<div class="pixel-font text-4xl text-blue-400 mb-8" id="winner-name">
					Player Name
				</div>
				<div class="flex gap-4 justify-center">
					<button
						id="new-tournament-btn"
						class="pixel-font px-8 py-3 neon-border bg-blue-500/20 text-blue-400 hover:bg-blue-500/40 transition-all"
					>
						NEW TOURNAMENT
					</button>
					<button
						id="exit-to-menu-btn"
						class="pixel-font px-8 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
					>
						MAIN MENU
					</button>
				</div>
			</div>
		</div>
	`;
};

const generateMatchCard = (match: LocalMatch): string => {
	const statusClass = match.status;
	const isFinished = match.status === 'finished';

	const player1Class = isFinished
		? (match.winner?.id === match.player1?.id ? 'winner' : 'loser')
		: '';
	const player2Class = isFinished
		? (match.winner?.id === match.player2?.id ? 'winner' : 'loser')
		: '';

	return `
		<div class="match-card neon-border rounded-lg p-4 mb-4 ${statusClass}" data-match-id="${match.id}">
			<div class="space-y-2">
				<!-- Player 1 -->
				<div class="player-slot neon-border rounded p-2 ${player1Class}">
					<div class="pixel-font text-sm text-blue-300">
						${match.player1?.username || 'TBD'}
						${isFinished && match.winner?.id === match.player1?.id ? ' üëë' : ''}
					</div>
				</div>

				<div class="text-center pixel-font text-xs text-blue-400">VS</div>

				<!-- Player 2 -->
				<div class="player-slot neon-border rounded p-2 ${player2Class}">
					<div class="pixel-font text-sm text-blue-300">
						${match.player2?.username || 'TBD'}
						${isFinished && match.winner?.id === match.player2?.id ? ' üëë' : ''}
					</div>
				</div>
			</div>

			${match.status === 'ready' ? `
				<div class="text-center mt-3">
					<div class="pixel-font text-xs text-yellow-400">READY TO PLAY</div>
				</div>
			` : ''}

			${match.status === 'in_progress' ? `
				<div class="text-center mt-3">
					<div class="pixel-font text-xs text-red-400">IN PROGRESS...</div>
				</div>
			` : ''}
		</div>
	`;
};

const generateRoundColumn = (tournament: LocalTournament, round: number): string => {
	const matches = LocalTournamentManager.getMatchesForRound(tournament, round);
	const totalRounds = LocalTournamentManager.getTotalRounds(tournament.size);
	const roundName = LocalTournamentManager.getRoundName(round, totalRounds);

	const matchesHtml = matches.map(match => generateMatchCard(match)).join('');

	return `
		<div class="round-column">
			<div class="round-header">
				<div class="pixel-font text-lg text-blue-400">${roundName}</div>
				<div class="pixel-font text-xs text-blue-300">Round ${round}</div>
			</div>
			<div class="matches-container">
				${matchesHtml}
			</div>
		</div>
	`;
};

const renderBracket = (tournament: LocalTournament): void => {
	const container = document.getElementById('bracket-container');
	if (!container) return;

	const totalRounds = LocalTournamentManager.getTotalRounds(tournament.size);
	let html = '';

	for (let round = 1; round <= totalRounds; round++) {
		const matches = LocalTournamentManager.getMatchesForRound(tournament, round);
		if (matches.length > 0) {
			html += generateRoundColumn(tournament, round);
		}
	}

	container.innerHTML = html;

	// Animer l'apparition
	gsap.fromTo(
		'.round-column',
		{ opacity: 0, x: -50 },
		{ opacity: 1, x: 0, duration: 0.5, stagger: 0.2 }
	);
};

const updateNextMatchPanel = (tournament: LocalTournament): void => {
	const panel = document.getElementById('next-match-panel');
	const textEl = document.getElementById('next-match-text');

	if (!panel || !textEl) return;

	const nextMatch = LocalTournamentManager.getNextMatch(tournament);

	if (nextMatch && nextMatch.player1 && nextMatch.player2) {
		textEl.textContent = `${nextMatch.player1.username} vs ${nextMatch.player2.username}`;
		panel.classList.remove('hidden');

		// Animer l'apparition
		gsap.fromTo(
			panel,
			{ y: 100, opacity: 0 },
			{ y: 0, opacity: 1, duration: 0.5 }
		);
	} else {
		panel.classList.add('hidden');
	}
};

const updateTournamentStatus = (tournament: LocalTournament): void => {
	const statusEl = document.getElementById('tournament-status');
	if (!statusEl) return;

	const totalRounds = LocalTournamentManager.getTotalRounds(tournament.size);
	const roundName = LocalTournamentManager.getRoundName(tournament.currentRound, totalRounds);

	statusEl.textContent = `${roundName} (Round ${tournament.currentRound}/${totalRounds})`;
};

const showWinnerModal = (winner: { username: string }): void => {
	const modal = document.getElementById('winner-modal');
	const nameEl = document.getElementById('winner-name');

	if (!modal || !nameEl) return;

	nameEl.textContent = winner.username;
	modal.classList.remove('hidden');

	// Animer l'apparition
	gsap.fromTo(
		modal,
		{ opacity: 0, scale: 0.8 },
		{ opacity: 1, scale: 1, duration: 0.8, ease: 'back.out(1.7)' }
	);
};

export const localTournamentBracketLogic = (): CleanupFunction => {
	const tournament = LocalTournamentManager.getCurrentTournament();

	if (!tournament) {
		console.error('No tournament found');
		window.router.navigate('/local-tournament-setup');
		return () => {};
	}

	// Rendu initial
	renderBracket(tournament);
	updateNextMatchPanel(tournament);
	updateTournamentStatus(tournament);

	// V√©rifier si le tournoi est termin√©
	if (tournament.status === 'finished' && tournament.winner) {
		showWinnerModal(tournament.winner);
	}

	// Handler pour jouer le prochain match
	const playMatchBtn = document.getElementById('play-match-btn');
	const handlePlayMatch = () => {
		const nextMatch = LocalTournamentManager.getNextMatch(tournament);
		if (!nextMatch || !nextMatch.player1 || !nextMatch.player2) return;

		// Marquer le match comme en cours
		LocalTournamentManager.markMatchInProgress(nextMatch.id);

		// Cr√©er la config pour le mode local
		const roomId = `local-tournament-${Date.now()}`;
		const localGameConfig = {
			roomId,
			left: {
				id: nextMatch.player1.id,
				username: nextMatch.player1.username,
				selectedSkill: nextMatch.player1.selectedSkill,
			},
			right: {
				id: nextMatch.player2.id,
				username: nextMatch.player2.username,
				selectedSkill: nextMatch.player2.selectedSkill,
			},
		};

		// Stocker les infos du match de tournoi
		sessionStorage.setItem('localGameConfig', JSON.stringify(localGameConfig));
		sessionStorage.setItem('localTournamentMatch', nextMatch.id);
		sessionStorage.setItem('gameWsURL', `wss://${window.location.hostname}:8443/gameback/game/${roomId}`);

		// Cr√©er la config pour le backend (qui attend player1/player2)
		const backendConfig = {
			roomId,
			player1: localGameConfig.left,
			player2: localGameConfig.right,
		};

		// Cr√©er la partie sur le backend
		fetch(`https://${window.location.hostname}:8443/gameback/create`, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(backendConfig),
		})
			.then(response => {
				if (!response.ok) throw new Error('Failed to create game');
				return response.json();
			})
			.then(() => {
				// Rediriger vers le jeu
				window.router.navigate(`/game/${roomId}`);
			})
			.catch(error => {
				console.error('Error creating game:', error);
				alert('Failed to create game. Please try again.');
			});
	};

	playMatchBtn?.addEventListener('click', handlePlayMatch);

	// Handler pour quitter le tournoi
	const exitBtn = document.getElementById('exit-tournament-btn');
	const handleExit = () => {
		if (confirm('Are you sure you want to exit the tournament? All progress will be lost.')) {
			LocalTournamentManager.clearTournament();
			window.router.navigate('/play');
		}
	};

	exitBtn?.addEventListener('click', handleExit);

	// Handlers pour le modal de victoire
	const newTournamentBtn = document.getElementById('new-tournament-btn');
	const exitToMenuBtn = document.getElementById('exit-to-menu-btn');

	const handleNewTournament = () => {
		LocalTournamentManager.clearTournament();
		window.router.navigate('/local-tournament-setup');
	};

	const handleExitToMenu = () => {
		LocalTournamentManager.clearTournament();
		window.router.navigate('/play');
	};

	newTournamentBtn?.addEventListener('click', handleNewTournament);
	exitToMenuBtn?.addEventListener('click', handleExitToMenu);

	// Cleanup
	return () => {
		playMatchBtn?.removeEventListener('click', handlePlayMatch);
		exitBtn?.removeEventListener('click', handleExit);
		newTournamentBtn?.removeEventListener('click', handleNewTournament);
		exitToMenuBtn?.removeEventListener('click', handleExitToMenu);
	};
};

// ==============================================
// üìÑ ./src/views/BracketView.ts
// ==============================================
import type { ViewFunction, CleanupFunction, RouteParams } from "../router/types";
import { gsap } from "gsap";

interface Player {
    id: string;
    username: string;
    currentTournament?: string;
    isEleminated: boolean;
}

interface Match {
    id: string;
    tournamentId: string;
    round: number;
    position: number;
    player1?: Player;
    player2?: Player;
    winner?: Player;
    roomId?: string;
    status: 'pending' | 'ready' | 'in_progress' | 'finished';
    scheduledAt?: Date;
    finishedAt?: Date;
}

interface Tournament {
    id: string;
    name: string;
    status: 'registration' | 'in_progress' | 'finished';
    maxPlayers: number;
    currentPlayers: Player[];
    bracket: Match[];
    currentRound: number;
    winner?: Player;
    createdAt: Date;
    StartedAt?: Date;
    finishedAt?: Date;
}

export const BracketView: ViewFunction = () => {
    return `
        <!-- Fond avec grille anim√©e -->
        <div class="fixed inset-0 bg-black overflow-hidden">
            <!-- Grille de fond -->
            <div class="absolute inset-0" style="
                background-image: 
                    linear-gradient(rgba(59, 130, 246, 0.1) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(59, 130, 246, 0.1) 1px, transparent 1px);
                background-size: 50px 50px;
                animation: gridMove 20s linear infinite;
            "></div>
            
            <style>
                @keyframes gridMove {
                    0% { transform: translateY(0); }
                    100% { transform: translateY(50px); }
                }
                
                @keyframes neonPulse {
                    0%, 100% { 
                        text-shadow: 
                            0 0 10px rgba(59, 130, 246, 0.8),
                            0 0 20px rgba(59, 130, 246, 0.6),
                            0 0 30px rgba(59, 130, 246, 0.4);
                    }
                    50% { 
                        text-shadow: 
                            0 0 20px rgba(59, 130, 246, 1),
                            0 0 30px rgba(59, 130, 246, 0.8),
                            0 0 40px rgba(59, 130, 246, 0.6);
                    }
                }
                
                @keyframes scanline {
                    0% { transform: translateY(-100%); }
                    100% { transform: translateY(100vh); }
                }
                
                .pixel-font {
                    font-family: 'Courier New', monospace;
                    font-weight: bold;
                    letter-spacing: 0.1em;
                }
                
                .neon-border {
                    box-shadow: 
                        0 0 10px rgba(59, 130, 246, 0.5),
                        inset 0 0 10px rgba(59, 130, 246, 0.2);
                    border: 3px solid rgba(59, 130, 246, 0.8);
                }
                
                .match-card {
                    transition: all 0.3s ease;
                    background: rgba(15, 23, 42, 0.8);
                    backdrop-filter: blur(10px);
                    position: relative;
                    min-width: 200px;
                }

                .match-card.finished {
                    border-color: rgba(34, 197, 94, 0.8);
                }

                .match-card.in_progress {
                    border-color: rgba(234, 179, 8, 0.8);
                    animation: matchPulse 2s ease-in-out infinite;
                }

                @keyframes matchPulse {
                    0%, 100% { 
                        box-shadow: 0 0 10px rgba(234, 179, 8, 0.5);
                    }
                    50% { 
                        box-shadow: 0 0 20px rgba(234, 179, 8, 0.8);
                    }
                }

                .player-slot {
                    transition: all 0.2s ease;
                }

                .player-slot.winner {
                    background: rgba(34, 197, 94, 0.2);
                    border-color: rgba(34, 197, 94, 0.5);
                }

                .player-slot.loser {
                    opacity: 0.5;
                }

                /* Tree connections */
                .bracket-tree {
                    display: flex;
                    gap: 80px;
                    padding: 40px;
                    overflow-x: auto;
                    min-height: 600px;
                }

                .round-column {
                    display: flex;
                    flex-direction: column;
                    justify-content: space-around;
                    min-width: 220px;
                    position: relative;
                }

                .round-header {
                    text-align: center;
                    margin-bottom: 20px;
                    position: sticky;
                    top: 0;
                    background: rgba(4, 7, 26, 0.9);
                    padding: 10px;
                    border-radius: 8px;
                    z-index: 10;
                }

                /* Lignes de connexion */
                .connector-line {
                    position: absolute;
                    background: rgba(59, 130, 246, 0.4);
                    z-index: 0;
                }

                .connector-horizontal {
                    height: 2px;
                }

                .connector-vertical {
                    width: 2px;
                }

                /* Animation des connexions */
                @keyframes flowRight {
                    0% { transform: translateX(-100%); }
                    100% { transform: translateX(100%); }
                }

                .connector-line.active::after {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 20px;
                    height: 100%;
                    background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.8), transparent);
                    animation: flowRight 2s ease-in-out infinite;
                }
            </style>
            
            <!-- Scanline effect -->
            <div class="absolute inset-0 pointer-events-none opacity-10">
                <div class="absolute w-full h-1 bg-blue-400" style="animation: scanline 8s linear infinite;"></div>
            </div>
        </div>

        <!-- Contenu principal -->
        <div class="relative z-10 min-h-screen flex flex-col">
            <!-- Header avec BackButton -->
            <header class="flex justify-between items-center px-8 py-6">
                <button 
                    onclick="history.back()" 
                    class="pixel-font px-6 py-3 neon-border bg-transparent text-blue-400 hover:bg-blue-500/10 transition-all"
                    id="back-button"
                >
                    ‚Üê BACK
                </button>
                
                <!-- Bouton Sign in -->
                <a href="/login" 
                   class="pixel-font bg-blue-500 text-black px-6 py-3 text-sm md:text-base hover:bg-blue-400 transition-all neon-border flex items-center gap-2">
                    <span>SIGN IN</span>
                </a>
            </header>

            <!-- Container principal -->
            <div class="flex-1 px-4 py-8">
                <!-- Loading state -->
                <div id="tournament-loading" class="text-center py-12">
                    <div class="inline-block animate-spin rounded-full h-16 w-16 border-4 border-blue-400 border-t-transparent"></div>
                    <p class="pixel-font text-blue-300 mt-4">Loading tournament...</p>
                </div>

                <!-- Content -->
                <div id="tournament-content" style="display: none;">
                    <!-- Header du tournoi -->
                    <div id="tournament-header" class="mb-8"></div>
                    
                    <!-- Brackets en arbre -->
                    <div id="tournament-brackets" class="bracket-tree"></div>
                </div>

                <!-- Error state -->
                <div id="tournament-error" style="display: none;" class="text-center py-12">
                    <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                    <h3 class="pixel-font text-2xl text-red-400 mb-2">Tournament not found</h3>
                    <p class="pixel-font text-sm text-blue-300/60">Unable to load tournament data</p>
                </div>
            </div>

            <!-- Footer -->
            <footer class="text-center py-6 pixel-font text-xs text-blue-400 opacity-50">
                <p>¬© 2025 PONG - SKILL ISSUE</p>
            </footer>
        </div>
    `;
};

export const bracketLogic = (params: RouteParams | undefined): CleanupFunction => {
    console.log('üéÆ BracketView: Initializing...');

    const tournamentId = params?.id;
    const myPlayerId = window.simpleAuth.getPlayerId();

    let pollInterval: number | null = null;
    let isFirstRender = true;
    let displayedMatchIds = new Set<string>();
    let currentTournamentState: Tournament | null = null;

    const cleanupIntervals = () => {
        if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
            console.log('üßπ Polling interval cleared');
        }
    };

    const fetchTournamentData = async (): Promise<void> => {
        try {
            const host = import.meta.env.VITE_HOST || 'localhost:8443';
            const response = await fetch(`https://${host}/tournamentback/tournaments/${tournamentId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const tournament = data.tournament;
            
            displayTournament(tournament);
            checkIfMyTurn(tournament);
        } catch (error) {
            console.error('Erreur lors de la r√©cup√©ration du tournoi:', error);
            showError();
        }
    };

    const checkIfMyTurn = (tournament: Tournament): void => {
        const myMatch = tournament.bracket.find(match => 
            match.status === 'in_progress' &&
            (match.player1?.id === myPlayerId || match.player2?.id === myPlayerId)
        );

        if (myMatch && myMatch.roomId) {
            console.log('Mon match est pr√™t ! Redirection...');
            
            cleanupIntervals();
            
            const host = import.meta.env.VITE_HOST;
            const endpoint = import.meta.env.VITE_GAME_ENDPOINT;
            const wsUrl = `wss://${host}${endpoint}/${myMatch.roomId}`;
            sessionStorage.setItem('gameWsURL', wsUrl);
            
            window.router.navigate(`/game/${myMatch.roomId}`);
        }
    };

    const displayTournament = (tournament: Tournament): void => {
        hideLoading();
        showContent();

        const headerNeedsUpdate = !currentTournamentState || 
            currentTournamentState.status !== tournament.status ||
            currentTournamentState.currentRound !== tournament.currentRound ||
            currentTournamentState.winner?.id !== tournament.winner?.id;

        if (headerNeedsUpdate) {
            updateHeader(tournament);
        }

        updateBrackets(tournament);

        currentTournamentState = tournament;
    };

    const updateHeader = (tournament: Tournament): void => {
        const headerElement = document.getElementById('tournament-header');
        if (headerElement) {
            headerElement.innerHTML = `
                <div class="neon-border bg-black/50 backdrop-blur-sm rounded-lg p-6 mb-6">
                    <div class="text-center">
                        <h2 class="pixel-font text-4xl text-red-500 mb-4" style="animation: neonPulse 2s ease-in-out infinite;">
                            üèÜ TOURNAMENT ${tournament.name.toUpperCase()} üèÜ
                        </h2>
                        <div class="flex justify-center gap-8 pixel-font text-sm text-blue-300">
                            <span>Status: <span class="text-yellow-400">${getStatusText(tournament.status)}</span></span>
                            <span>Round: <span class="text-green-400">${tournament.currentRound}</span></span>
                            ${tournament.winner ? `<span>Winner: <span class="text-yellow-400">üëë ${tournament.winner.username}</span></span>` : ''}
                        </div>
                    </div>
                </div>
            `;

            if (isFirstRender) {
                gsap.from(headerElement.querySelector('.neon-border'), {
                    scale: 0.9,
                    opacity: 0,
                    duration: 0.8,
                    ease: 'back.out'
                });
            }
        }
    };

    const updateBrackets = (tournament: Tournament): void => {
        const bracketsElement = document.getElementById('tournament-brackets');
        if (!bracketsElement) return;

        if (isFirstRender) {
            bracketsElement.innerHTML = generateTreeBrackets(tournament.bracket);
            tournament.bracket.forEach(match => displayedMatchIds.add(match.id));

            gsap.from('.round-column', {
                x: -50,
                opacity: 0,
                duration: 0.8,
                stagger: 0.2,
                ease: 'power2.out'
            });

            setTimeout(() => drawConnections(tournament.bracket), 1000);

            isFirstRender = false;
        } else {
            const newMatches = tournament.bracket.filter(match => !displayedMatchIds.has(match.id));
            
            if (newMatches.length > 0) {
                newMatches.forEach(match => {
                    displayedMatchIds.add(match.id);
                });
                
                bracketsElement.innerHTML = generateTreeBrackets(tournament.bracket);
                drawConnections(tournament.bracket);
            }

            tournament.bracket.forEach(match => {
                updateMatchElement(match);
            });
        }
    };

    const generateTreeBrackets = (matches: Match[]): string => {
        if (matches.length === 0) {
            return '<div class="text-center p-8 pixel-font text-blue-300/60">No matches available</div>';
        }

        const matchesByRound = matches.reduce((acc, match) => {
            if (!acc[match.round]) {
                acc[match.round] = [];
            }
            acc[match.round].push(match);
            return acc;
        }, {} as Record<number, Match[]>);

        const maxRound = Math.max(...Object.keys(matchesByRound).map(Number));

        let html = '';
        
        for (let round = 1; round <= maxRound; round++) {
            const roundMatches = matchesByRound[round] || [];
            html += generateRoundColumn(round, roundMatches, round === maxRound);
        }
        
        return html;
    };

    const generateRoundColumn = (round: number, matches: Match[], isFinal: boolean): string => {
        const roundTitle = isFinal ? 'FINAL' : `ROUND ${round}`;
        
        return `
            <div class="round-column" data-round="${round}">
                <div class="round-header">
                    <h3 class="pixel-font text-xl text-blue-400">
                        ${roundTitle}
                    </h3>
                </div>
                <div class="matches-container flex flex-col justify-around gap-8 flex-1">
                    ${matches.map(match => generateMatchCard(match)).join('')}
                </div>
            </div>
        `;
    };

    const generateMatchCard = (match: Match): string => {
        const getStatusColor = (status: string): string => {
            switch (status) {
                case 'ready': return 'bg-blue-500/20 border-blue-500/50 text-blue-400';
                case 'in_progress': return 'bg-yellow-500/20 border-yellow-500/50 text-yellow-400';
                case 'finished': return 'bg-green-500/20 border-green-500/50 text-green-400';
                default: return 'bg-gray-500/20 border-gray-500/50 text-gray-400';
            }
        };

        const isMyMatch = match.player1?.id === myPlayerId || match.player2?.id === myPlayerId;

        return `
            <div class="match-card neon-border rounded-lg p-4 ${match.status} ${isMyMatch ? 'ring-2 ring-red-500/50' : ''}" 
                 data-match-id="${match.id}"
                 data-round="${match.round}"
                 data-position="${match.position}">
                
                <!-- Header du match -->
                <div class="flex justify-between items-center mb-3">
                    <span class="match-status pixel-font text-xs ${getStatusColor(match.status)} px-2 py-1 rounded border">
                        ${getStatusText(match.status)}
                    </span>
                    ${isMyMatch ? '<span class="pixel-font text-xs text-red-400">‚Üê YOU</span>' : ''}
                </div>

                <!-- Players -->
                <div class="space-y-2">
                    <!-- Player 1 -->
                    <div class="player-slot player-1 neon-border p-3 rounded ${match.winner?.id === match.player1?.id ? 'winner' : match.winner ? 'loser' : ''}" 
                         data-player-id="${match.player1?.id || ''}">
                        <div class="flex items-center justify-between">
                            <span class="pixel-font text-sm text-blue-300">
                                ${match.player1?.username || 'TBD'}
                            </span>
                            ${match.winner?.id === match.player1?.id ? '<span class="text-xl winner-crown">üëë</span>' : ''}
                        </div>
                    </div>

                    <!-- VS -->
                    <div class="text-center pixel-font text-xs text-blue-400/40">VS</div>

                    <!-- Player 2 -->
                    <div class="player-slot player-2 neon-border p-3 rounded ${match.winner?.id === match.player2?.id ? 'winner' : match.winner ? 'loser' : ''}" 
                         data-player-id="${match.player2?.id || ''}">
                        <div class="flex items-center justify-between">
                            <span class="pixel-font text-sm text-blue-300">
                                ${match.player2?.username || 'TBD'}
                            </span>
                            ${match.winner?.id === match.player2?.id ? '<span class="text-xl winner-crown">üëë</span>' : ''}
                        </div>
                    </div>
                </div>
            </div>
        `;
    };

    const drawConnections = (matches: Match[]): void => {
        document.querySelectorAll('.connector-line').forEach(el => el.remove());

        const matchesByRound = matches.reduce((acc, match) => {
            if (!acc[match.round]) {
                acc[match.round] = [];
            }
            acc[match.round].push(match);
            return acc;
        }, {} as Record<number, Match[]>);

        const maxRound = Math.max(...Object.keys(matchesByRound).map(Number));

        for (let round = 1; round < maxRound; round++) {
            const currentRoundMatches = matchesByRound[round] || [];
            const nextRoundMatches = matchesByRound[round + 1] || [];

            currentRoundMatches.forEach((match, index) => {
                const nextMatchIndex = Math.floor(index / 2);
                const nextMatch = nextRoundMatches[nextMatchIndex];

                if (nextMatch) {
                    const currentCard = document.querySelector(`[data-match-id="${match.id}"]`) as HTMLElement;
                    const nextCard = document.querySelector(`[data-match-id="${nextMatch.id}"]`) as HTMLElement;

                    if (currentCard && nextCard) {
                        const currentRect = currentCard.getBoundingClientRect();
                        const nextRect = nextCard.getBoundingClientRect();
                        const container = document.getElementById('tournament-brackets');
                        
                        if (container) {
                            const containerRect = container.getBoundingClientRect();

                            const horizontalLine = document.createElement('div');
                            horizontalLine.className = 'connector-line connector-horizontal';
                            if (match.status === 'finished') {
                                horizontalLine.classList.add('active');
                            }
                            horizontalLine.style.left = `${currentRect.right - containerRect.left}px`;
                            horizontalLine.style.top = `${currentRect.top + currentRect.height / 2 - containerRect.top}px`;
                            horizontalLine.style.width = '40px';
                            container.appendChild(horizontalLine);

                            const junctionX = currentRect.right - containerRect.left + 40;
                            const junctionY = currentRect.top + currentRect.height / 2 - containerRect.top;
                            const nextJunctionY = nextRect.top + nextRect.height / 2 - containerRect.top;

                            if (index % 2 === 1) {
                                const verticalLine = document.createElement('div');
                                verticalLine.className = 'connector-line connector-vertical';
                                const prevMatch = currentRoundMatches[index - 1];
                                const prevCard = document.querySelector(`[data-match-id="${prevMatch.id}"]`) as HTMLElement;
                                
                                if (prevCard) {
                                    const prevRect = prevCard.getBoundingClientRect();
                                    const prevY = prevRect.top + prevRect.height / 2 - containerRect.top;
                                    
                                    verticalLine.style.left = `${junctionX}px`;
                                    verticalLine.style.top = `${Math.min(prevY, junctionY)}px`;
                                    verticalLine.style.height = `${Math.abs(junctionY - prevY)}px`;
                                    container.appendChild(verticalLine);
                                }

                                const finalHorizontal = document.createElement('div');
                                finalHorizontal.className = 'connector-line connector-horizontal';
                                finalHorizontal.style.left = `${junctionX}px`;
                                finalHorizontal.style.top = `${nextJunctionY}px`;
                                finalHorizontal.style.width = `${nextRect.left - containerRect.left - junctionX}px`;
                                container.appendChild(finalHorizontal);
                            }
                        }
                    }
                }
            });
        }
    };

    const updateMatchElement = (match: Match): void => {
        const matchElement = document.querySelector(`[data-match-id="${match.id}"]`);
        if (!matchElement) return;

        const statusEl = matchElement.querySelector('.match-status');
        if (statusEl) {
            const newStatus = getStatusText(match.status);
            if (statusEl.textContent !== newStatus) {
                statusEl.textContent = newStatus;
                
                const getStatusColor = (status: string): string => {
                    switch (status) {
                        case 'ready': return 'bg-blue-500/20 border-blue-500/50 text-blue-400';
                        case 'in_progress': return 'bg-yellow-500/20 border-yellow-500/50 text-yellow-400';
                        case 'finished': return 'bg-green-500/20 border-green-500/50 text-green-400';
                        default: return 'bg-gray-500/20 border-gray-500/50 text-gray-400';
                    }
                };
                
                statusEl.className = `match-status pixel-font text-xs px-2 py-1 rounded border ${getStatusColor(match.status)}`;
                
                matchElement.className = `match-card neon-border rounded-lg p-4 ${match.status} ${
                    match.player1?.id === myPlayerId || match.player2?.id === myPlayerId ? 'ring-2 ring-red-500/50' : ''
                }`;
            }
        }

        if (match.winner) {
            const player1Slot = matchElement.querySelector('.player-1');
            const player2Slot = matchElement.querySelector('.player-2');

            if (player1Slot && player2Slot) {
                const isPlayer1Winner = match.winner.id === match.player1?.id;
                const isPlayer2Winner = match.winner.id === match.player2?.id;

                const p1Classes = `player-slot player-1 neon-border p-3 rounded ${isPlayer1Winner ? 'winner' : 'loser'}`;
                if (player1Slot.className !== p1Classes) {
                    player1Slot.className = p1Classes;
                    if (isPlayer1Winner && !player1Slot.querySelector('.winner-crown')) {
                        const crownEl = document.createElement('span');
                        crownEl.className = 'text-xl winner-crown';
                        crownEl.textContent = 'üëë';
                        player1Slot.querySelector('div')?.appendChild(crownEl);
                    }
                }

                const p2Classes = `player-slot player-2 neon-border p-3 rounded ${isPlayer2Winner ? 'winner' : 'loser'}`;
                if (player2Slot.className !== p2Classes) {
                    player2Slot.className = p2Classes;
                    if (isPlayer2Winner && !player2Slot.querySelector('.winner-crown')) {
                        const crownEl = document.createElement('span');
                        crownEl.className = 'text-xl winner-crown';
                        crownEl.textContent = 'üëë';
                        player2Slot.querySelector('div')?.appendChild(crownEl);
                    }
                }
            }
        }
    };

    const getStatusText = (status: string): string => {
        switch (status) {
            case 'registration': return 'REGISTRATION';
            case 'in_progress': return 'IN PROGRESS';
            case 'finished': return 'FINISHED';
            case 'ready': return 'READY';
            case 'pending': return 'PENDING';
            default: return status.toUpperCase();
        }
    };

    const hideLoading = (): void => {
        const loading = document.getElementById('tournament-loading');
        if (loading) loading.style.display = 'none';
    };

    const showContent = (): void => {
        const content = document.getElementById('tournament-content');
        if (content) content.style.display = 'block';
    };

    const showError = (): void => {
        hideLoading();
        const error = document.getElementById('tournament-error');
        if (error) error.style.display = 'block';
    };

    fetchTournamentData();

    pollInterval = setInterval(() => {
        fetchTournamentData();
        if (currentTournamentState) {
            setTimeout(() => drawConnections(currentTournamentState!.bracket), 100);
        }
    }, 2000);
    console.log('üîÑ Started bracket polling');

    return (): void => {
        console.log('üßπ BracketView: Cleaning up...');
        
        cleanupIntervals();
        
        console.log('‚úÖ BracketView: Cleanup complete');
    };
};

// ==============================================
// üìÑ ./src/router/Router.ts
// ==============================================
import type { Route, CleanupFunction, RouteParams } from './types';
import { ComponentManager } from '../components/ComponantManager'
import { HomeView, homeLogic } from '../views/HomeView';
import { QuickPlayView, quickPlayLogic } from '../views/QuickPlayView';
import { WaitingRoomView, waitingRoomLogic } from '../views/WaitingRoomView';
import { GameView } from '../views/GameView';
import { StartGameView } from '../views/StartGameView';
import { LoginView } from '../views/LoginView';
import { CreateAccountView } from '../views/CreateAccountView';
import { tournamentLogic, TournamentView } from '../views/TournamentView';
import { BracketView, bracketLogic } from '../views/BracketView';
import { LocalGameView, localGameLogic } from '../views/LocalGameView';
import { LocalTournamentSetupView, localTournamentSetupLogic } from '../views/LocalTournamentSetupView';
import { LocalTournamentBracketView, localTournamentBracketLogic } from '../views/LocalTournamentBracketView';
import { HistoryView, historyLogic } from '../views/HistoryView';
import { GameDetailView, gameDetailLogic } from '../views/GameDetailView';
import { BlockchainView, blockchainLogic } from '../views/BlockchainView';
import { Game3dView } from '../views/Game3dView.ts';
import type { NavigationGuard } from './types';
import {
    logGuard,
    tournamentExistsGuard,
    roomExistsGuard
} from './Guards'
import { dbUserLogic, dbUserView } from '../views/DbUserView';

export class Router {
    private routes: Route[];
	private currentCleanup: CleanupFunction | null = null;
    private componentManager: ComponentManager;
    private currentRoute?: Route;
    private globalBeforeEach?: NavigationGuard;
    
    constructor()
    {
        this.routes = [];
        this.componentManager = new ComponentManager();
        this.setupRoutes();
		this.setupLinkInterception();
		this.setupHistoryNavigation();

        this.globalBeforeEach = logGuard;
    }
    
    private setupRoutes(): void
    {
        this.routes.push({
            path: '/',
            view: HomeView,
            onMount: homeLogic,
            title: 'Accueil'
        });

		this.routes.push({
            path: '/play',
            view: QuickPlayView,
            onMount: quickPlayLogic,
            title: 'QuickPlay'
        });

		this.routes.push({
            path: '/play/waiting',
            view: WaitingRoomView,
            onMount: waitingRoomLogic,
            title: 'Waiting Room'
        });

		this.routes.push({
            path: '/local',
            view: LocalGameView,
            onMount: localGameLogic,
            title: 'Local Game'
        });

		this.routes.push({
            path: '/local-tournament-setup',
            view: LocalTournamentSetupView,
            onMount: localTournamentSetupLogic,
            title: 'Local Tournament Setup'
        });

		this.routes.push({
            path: '/local-tournament-bracket',
            view: LocalTournamentBracketView,
            onMount: localTournamentBracketLogic,
            title: 'Local Tournament Bracket'
        });

		this.routes.push({
            path: '/game/:roomId',
            view: GameView,
            title: 'Pong gaming',
            beforeEnter: async (to, from, params) => {
                return await roomExistsGuard(to, from, params);
            },
        });

		this.routes.push({
            path: '/game3d/:roomId',
            view: Game3dView,
            title: 'Pong 3D gaming',
            beforeEnter: async (to, from, params) => {
                return await roomExistsGuard(to, from, params);
            },
        });

        this.routes.push({
            path: '/tournament',
            view: TournamentView,
            onMount: tournamentLogic,
            title: 'Tournament'
        });

        this.routes.push({
            path: '/tournament/:id',
            view: BracketView,
            onMount: bracketLogic,
            title: 'Tounament brackets',
            beforeEnter: async (to, from, params) => {
                return await tournamentExistsGuard(to, from, params);
            }
        });

        this.routes.push({
            path: '/dbuser',
            view: dbUserView,
            onMount: dbUserLogic,
            title: 'dbUser',
        });

		this.routes.push({
            path: '/startgame',
            view: StartGameView,
            title: 'Test'
        });

        this.routes.push({
            path: '/history',
            view: HistoryView,
            onMount: historyLogic,
            title: 'Historique des Parties'
        });

        this.routes.push({
            path: '/history/:id',
            view: GameDetailView,
            onMount: gameDetailLogic,
            title: 'D√©tails de la Partie'
        });

		this.routes.push({
            path: '/login',
            view: LoginView,
            title: 'Test'
        });

		this.routes.push({
            path: '/create',
            view: CreateAccountView,
            title: 'Test'
        });
		//wip temp road to work on the visual
		this.routes.push({
			path: '/dev3d',
			view: Game3dView,
			title: 'game 3D'
		});

		this.routes.push({
			path: '/blockchain',
			view: BlockchainView,
			onMount: blockchainLogic,
			title: 'Blockchain Registry'
		});

        this.compileRoutes();
    }

    private compileRoutes(): void {
        this.routes.forEach(route => {
            if (route.path.includes(':'))
            {
                const paramNames: string[] = [];
                
                const regexPattern = route.path.replace(/:([^/]+)/g, (match, paramName) => {
                    paramNames.push(paramName);
                    return '([^/]+)';
                });

                route.regex = new RegExp(`^${regexPattern}$`);
                route.paramNames = paramNames;
            }
        });
    }

	private setupLinkInterception(): void
    {
		document.addEventListener('click', (e: MouseEvent) => {
			const target = e.target as HTMLElement;
			const link = target.closest('a');
			
			if (link && link instanceof HTMLAnchorElement)
            {
				const href = link.getAttribute('href');
				
				if (!href) return;
				
				if (this.isExternalLink(href))
                {
					return;
				}
				
				e.preventDefault();
				this.navigateTo(href);
			}
		});
	}

	private isExternalLink(href: string): boolean
    {
		return /^(https?:\/\/|mailto:|tel:|ftp:)/.test(href);
	}

	private setupHistoryNavigation(): void
    {
        window.addEventListener('popstate', () => {
            this.navigate(window.location.pathname, false);
        });
    }

	public navigateTo(path: string): void
    {
        if (window.location.pathname !== path)
        {
            window.history.pushState({}, '', path);
            this.navigate(path);
        }
    }
    
    public async navigate(path: string, updateHistory: boolean = true): Promise<void> {
        this.cleanup();
        
        const matchResult = this.findRoute(path);
        if (matchResult) {
            const { route, params } = matchResult;

            if (this.globalBeforeEach)
            {
                const globalResult = await this.globalBeforeEach(
                    route, 
                    this.currentRoute, 
                    params
                );
                
                if (globalResult === false)
                {
                    console.log('Navigation unauthorized by global guard');
                    return;
                }
                
                if (typeof globalResult === 'string')
                {
                    console.log(`Global redirection to ${globalResult}`);
                    this.navigateTo(globalResult);
                    return;
                }
            }

            if (route.beforeEnter)
            {
                const guardResult = await route.beforeEnter(
                    route, 
                    this.currentRoute, 
                    params
                );
                
                if (guardResult === false)
                {
                    console.log('Navigation unauthorized by local path guard');
                    return;
                }
                
                if (typeof guardResult === 'string')
                {
                    console.log(`Redirection by local path guard to ${guardResult}`);
                    this.navigateTo(guardResult);
                    return;
                }
            }
            
            const htmlContent = route.view(params);
            const app = document.getElementById('app');
            if (app) {
                app.innerHTML = htmlContent;
            }
            
            document.title = route.title || 'Transcendence';
            
            if (updateHistory && window.location.pathname !== path) {
                window.history.pushState({}, '', path);
            }
            
            this.componentManager.scanAndMount();

            if (route.onMount) {
                const cleanup = route.onMount(params);
                if (cleanup && typeof cleanup === 'function') {
                    this.currentCleanup = cleanup;
                }
            }

            this.currentRoute = route;

        } else {
            this.show404();
        }
    }

	private cleanup(): void
    {
        this.componentManager.cleanupAll();

        if (this.currentCleanup)
        {
            this.currentCleanup();
            this.currentCleanup = null;
        }
    }
    
    private findRoute(path: string): { route: Route; params: RouteParams } | undefined {
        for (const route of this.routes)
        {
            if (!route.regex && route.path === path)
            {
                return { route, params: {} };
            }
            
            if (route.regex && route.paramNames)
            {
                const match = path.match(route.regex);
                if (match)
                {
                    const params: RouteParams = {};
                    
                    route.paramNames.forEach((paramName, index) => {
                        params[paramName] = match[index + 1];
                    });
                    
                    return { route, params };
                }
            }
        }
        
        return undefined;
    }
    
    private show404(): void
    {
        document.getElementById('app')!.innerHTML = '<h1>Erm... This page does not exist.</h1>';
    }

    public setGlobalGuard(guard: NavigationGuard): void {
        this.globalBeforeEach = guard;
    }
}

// ==============================================
// üìÑ ./src/router/Guards.ts
// ==============================================
import type { NavigationGuard } from './types';

export const roomExistsGuard: NavigationGuard = async (to, from, params) => {
    const roomId = params?.roomId;

    if (!roomId)
	{
        console.log('No room id provided');
        return '/';
    }

	// Check if this is a local tournament match
	const isLocalTournament = sessionStorage.getItem('localTournamentMatch');
	const localGameConfig = sessionStorage.getItem('localGameConfig');
	if (isLocalTournament && localGameConfig && roomId.startsWith('local-tournament-')) {
		console.log('Local tournament match detected, allowing navigation');
		return true;
	}

	const cachedWsUrl = sessionStorage.getItem('gameWsURL');
    if (cachedWsUrl && cachedWsUrl.includes(roomId)) {
        console.log('Room URL found in cache, allowing navigation');
        return true;
    }
    
    try {
        const host = import.meta.env.VITE_HOST || 'localhost:8443';
        const response = await fetch(
            `https://${host}/quickplay/status/${roomId}`,
            {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            }
        );
        
        if (!response.ok) {
            console.log('Invalid room');
            return '/';
        }
        
        const data = await response.json();
        
        if (data.status === 'ready' && data.gameServerURL) {
            console.log('Room exists, statut ready');
            sessionStorage.setItem('gameWsURL', data.gameServerURL);
            return true;
        } else if (data.status === 'waiting') {
            console.log('Room is waiting for players, redirection');
            return '/play';
        } else if (data.status === 'finished') {
            console.log('Room is finished, redirection');
            return '/play';
        } else {
            console.log('Invalid room status:', data.status);
            return '/play';
        }
    } catch (err) {
        console.error('Error while guard checking the room', err);
        return '/';
    }
};

export const tournamentExistsGuard: NavigationGuard = async (to, from, params) => {
    if (!params?.id) {
        console.log('No tournament id provided');
        return '/tournament';
    }
    
    try {
        const host = import.meta.env.VITE_HOST || 'localhost:8443';
        const response = await fetch(
            `https://${host}/tournamentback/tournaments/${params.id}`
        );
        
        if (!response.ok) {
            console.log('Tournament not found');
            return '/tournament';
        }
        
        return true;
    } catch (err) {
        console.error('Error while fetching tournament:', err);
        return '/tournament';
    }
};

export const logGuard: NavigationGuard = (to, from, params) => {
    console.log('üìç Navigation:', {
        from: from?.path || 'initial',
        to: to.path,
        params
    });
    return true;
};

// ==============================================
// üìÑ ./src/router/types.ts
// ==============================================

export interface Route
{
	path: string;
	view: ViewFunction;
	onMount?: (params?: RouteParams) => CleanupFunction | void;
	title?: string;
	regex?: RegExp;
    paramNames?: string[];

	beforeEnter?: NavigationGuard;
    meta?: Record<string, any>;
}

export type GuardResult = boolean | string | Promise<boolean | string>;

export type NavigationGuard = (
	to: Route,
    from?: Route,
    params?: RouteParams
) => GuardResult;

export type ViewFunction = (params?: RouteParams) => string;
export type CleanupFunction = () => void;
export type RouteParams = Record<string, string>;

// ==============================================
// üìÑ ./src/main.ts
// ==============================================
import './style.css'
import { Router } from './router/Router';
import { registerComponents } from './components';
import { SimpleAuth } from './simpleAuth/SimpleAuth'

declare global {
    interface Window {
        router: Router;
        simpleAuth: SimpleAuth;
    }
}

registerComponents(); 

const auth = new SimpleAuth()
window.simpleAuth = auth;

const router = new Router();

const currentPath = window.location.pathname;
router.navigate(currentPath);

window.router = router;

// ==============================================
// üìÑ ./src/net/wsClient.ts
// ==============================================
export type PublicState = {
	leftPaddle: {y: number; speed: number; intention: number};
	rightPaddle: {y: number; speed: number; intention: number};
	balls: {x: number; y: number; vx: number; vy: number; radius: number}[];
	score: {left: number; right: number};
	isPaused: boolean;
	isGameOver: boolean;
	winner: '' | 'left' | 'right';
	countdownValue: number;
	powerUps: {x: number, y: number, radius: number, type: string}[];
	splitActive: boolean;
	clock: number;
	blackoutLeft: boolean;
	blackoutRight: boolean;
	blackoutLeftIntensity: number;
	blackoutRightIntensity: number;
	blackholeActive: boolean;
	blackholeProgress: number;
	blackholeCenterX: number;
	blackholeCenterY: number;
	selectedSkills: {
		left: 'smash' | 'dash';
		right: 'smash' | 'dash';
	};
	skillStates: {
		left: {cooldownRemaining: number; lastActivationAt: number};
		right: {cooldownRemaining: number; lastActivationAt: number};
	};
};

type ServerMsg = 
	| {type: 'welcome'; side: 'left' | 'right'; isTournament?: boolean; tournamentId?: string; players?: {left?: string; right?: string}}
	| {type: 'state'; state: PublicState; serverTime: number}
	| {type: 'countdown'; value: number}
	| {type: 'paused' | 'resumed'}
    | {type: 'timeout_status'; left: {active: boolean; remainingMs: number};
                               right: {active: boolean; remainingMs: number};}
	| {type: 'gameover'; winner: 'left' | 'right'; isTournament?: boolean; tournamentId?: string}
	| {type: 'pong'; t: number};

// apps/frontend/src/net/wsClient.ts
export class WSClient {
	private ws?: WebSocket;
	side: 'left' | 'right' = 'left';

	isTournament: boolean = false;
	tournamentId?: string;
	playerNames: {left?: string; right?: string} = {};
	private playerIdOverride?: string;

	onState?: (s: PublicState) => void;
	onCountdown?: (v: number) => void;
	onGameOver?: (w: 'left' | 'right', isTournament?: boolean, tournamentId?: string) => void;
	onPaused?: () => void;
	onResumed?: () => void;
	onTimeoutStatus?: (status: {
		left: {active: boolean; remainingMs: number};
		right: {active: boolean; remainingMs: number}
	}) => void;
	onWelcome?: (side: 'left' | 'right' | 'spectator', playerNames?: {left?: string; right?: string}) => void;
	onPong?: (serverTime: number) => void;

	connect(url?: string, options?: { playerId?: string }) {
		const host = import.meta.env.VITE_HOST
		const endpoint = import.meta.env.VITE_GAME_ENDPOINT
		const defaultUrl = (host && endpoint) ? `wss://${host}${endpoint}`
					: undefined;
		const finalUrl = url ?? defaultUrl;
		this.playerIdOverride = options?.playerId;
		if (!finalUrl)
		{
			console.warn('WSClient: no URL provided and no defaultUrl');
			return;
		}
		console.log('WSClient: connecting to', finalUrl);
		this.ws = new WebSocket(finalUrl);
		this.ws.onopen = () => {
			const playerId = this.playerIdOverride ?? window.simpleAuth.getPlayerId();
			console.log('WebSocket opened, sending logIn with ID:', playerId);
			if (!playerId) {
				console.warn('WSClient: no playerId available, closing connection');
				this.ws?.close();
				return;
			}
			this.ws?.send(JSON.stringify({
				type: 'logIn', 
				id: playerId
			}));
		};
		this.ws.onmessage = (ev) => {
			const msg = JSON.parse(ev.data) as ServerMsg;
			switch (msg.type) {
				case 'welcome':
					console.log('Welcome from server');
					this.side = msg.side;
					this.playerNames = msg.players || {};
					this.onWelcome?.(msg.side, msg.players);
					break;
				case 'state':
					this.onState?.(msg.state);
					break;
				case 'countdown':
					this.onCountdown?.(msg.value);
					break;
				case 'paused':
					this.onPaused?.();
					break;
				case 'resumed':
					this.onResumed?.();
					break;
				case 'timeout_status':
					this.onTimeoutStatus?.(msg);
					break;
				case 'gameover':
					this.onGameOver?.(msg.winner, msg.isTournament, msg.tournamentId);
					break;
				case 'pong':
					this.onPong?.(msg.t);
					break;
			}
		};
	}

	sendInput(up: boolean, down: boolean) {
		this.ws?.send(JSON.stringify({ type: 'input', up, down }));
	}

	pause() {
		this.ws?.send(JSON.stringify({ type: 'pause' }));
	}

	resume() {
		this.ws?.send(JSON.stringify({ type: 'resume' }));
	}

	useSkill() {
		this.ws?.send(JSON.stringify({ type: 'skill' }));
	}

	forfeit() {
		this.ws?.send(JSON.stringify({ type: 'forfeit' }));
	}

	sendPing() {
		this.ws?.send(JSON.stringify({ type: 'ping', t: Date.now() }));
	}

	debugActivatePowerUp(kind: 'split' | 'blackout' | 'blackhole') {
		this.ws?.send(JSON.stringify({ 
			type: 'debug', 
			action: 'activate_powerup', 
			payload: { kind } 
		}));
	}

	debugClearPowerUps() {
		this.ws?.send(JSON.stringify({ type: 'debug', action: 'clear_powerups' }));
	}

	debugScoreChange(side: 'left' | 'right', amount: number) {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'score_change', payload: { side, amount }
		}));
	}

	debugResetScore() {
		this.ws?.send(JSON.stringify({ type: 'debug', action: 'reset_score' }));
	}

	debugSetScore(left: number, right: number) {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'set_score', payload: { left, right }
		}));
	}

	debugBallControl(mode: 'add' | 'remove' | 'reset') {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'ball_control', payload: { mode }
		}));
	}

	debugBallSpeed(mode: 'multiply' | 'divide' | 'freeze') {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'ball_speed', payload: { mode }
		}));
	}

	debugTimeScale(scale: number) {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'time_scale', payload: { scale }
		}));
	}

	debugChangeSkill(side: 'left' | 'right', skill: 'smash' | 'dash') {
		this.ws?.send(JSON.stringify({
			type: 'debug', action: 'change_skill', payload: { side, skill }
		}));
	}

	disconnect(): void {
		if (this.ws) {
			console.log('WSClient: disconnecting...');
	
			this.ws.onopen = null;
			this.ws.onmessage = null;
			this.ws.onerror = null;
			this.ws.onclose = null;
			
			if (this.ws.readyState === WebSocket.OPEN || 
				this.ws.readyState === WebSocket.CONNECTING) {
				this.ws.close();
			}
			
			this.ws = undefined;
		}
	}

	cleanup(): void {
		console.log('WSClient: cleaning up...');
		
		this.onState = undefined;
		this.onCountdown = undefined;
		this.onGameOver = undefined;
		this.onPaused = undefined;
		this.onResumed = undefined;
		this.onTimeoutStatus = undefined;
		this.onWelcome = undefined;
		this.onPong = undefined;
		
		this.disconnect();
		
		this.side = 'left';
		this.isTournament = false;
		this.tournamentId = undefined;
		this.playerNames = {};
		this.playerIdOverride = undefined;
	}
}
